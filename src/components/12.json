[
    {
        "start_id": "CH1",
        "start_labels": [
            "Subject"
        ],
        "start_properties": {
            "id": "CH1",
            "name": "第1章 软件与软件工程"
        },
        "relation": "Next_SB",
        "relation_properties": {},
        "end_id": "CH3",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH3",
            "name": "第3章 敏捷和敏捷过程"
        }
    },
    {
        "start_id": "T1.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.1",
            "name": "1.1 软件的本质"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T1.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.2",
            "name": "1.2 定义软件工程学科"
        }
    },
    {
        "start_id": "S1.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.1.1",
            "name": "1.1.1 定义软件"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S1.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.2",
            "name": "1.1.2 软件应用领域"
        }
    },
    {
        "start_id": "SS1.1.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.1.1",
            "content": "①软件是一种产品：扮演着信息转换的角色；产生、管理、查询、修改、显示、传递信息。\n②软件是生产产品的载体，提供以下基础平台：计算机控制 (e.g., 操作系统)信息通信 (e.g., 网络软件)应用软件开发 (e.g., 软件工具)",
            "name": "1.1.1.1 软件的双重角色"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS1.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.1.2",
            "content": "软件是一组要素的集合：程序、文档、数据。\n\n①程序的正常运行离不开必要的文档和数据：\n②文档是开发、使用和维护程序所需要的图文资料；\n③数据是使程序能够适当地处理信息的数据结构（包括数据库、一些配置文件等）。",
            "name": "1.1.1.2 什么是软件"
        }
    },
    {
        "start_id": "SS1.1.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.1.2",
            "content": "软件是一组要素的集合：程序、文档、数据。\n\n①程序的正常运行离不开必要的文档和数据：\n②文档是开发、使用和维护程序所需要的图文资料；\n③数据是使程序能够适当地处理信息的数据结构（包括数据库、一些配置文件等）。",
            "name": "1.1.1.2 什么是软件"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS1.1.1.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.1.3",
            "content": "软件是逻辑的而非物理的系统元素。因此，软件和硬件具有完全不同的特性：软件不会“磨损”。",
            "name": "1.1.1.3 软件与硬件具有不同的特性"
        }
    },
    {
        "start_id": "P1.1.1.3.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.1.3.1",
            "content": "软件是设计开发的，而不是传统意义上生产制造的：硬件和软件可通过优秀的设计获得高品质产品，然而硬件在制造阶段可能会引入质量问题，这在软件中并不存在（或者易于纠正）；\n软件产品成本主要在于开发设计，硬件的成本在批量生产时仍然很高。",
            "name": "1.1.1.3.1 软件是设计开发出的产品"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.1.1.3.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.1.1.3.2",
            "content": "①磨损的硬件部件可以用备用部件替换，而软件却不存在备用部件。\n②每个软件的缺陷都暗示了设计的缺陷或者在从设计转化到机器可执行代码（实现）的过程中产生的错误。\n③软件维护要应对变更请求，比硬件维护更为复杂。\n④不断的变更是软件退化的根本原因。",
            "name": "1.1.1.3.2 软件不会“磨损”"
        }
    },
    {
        "start_id": "P1.1.1.3.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.1.3.2",
            "content": "①磨损的硬件部件可以用备用部件替换，而软件却不存在备用部件。\n②每个软件的缺陷都暗示了设计的缺陷或者在从设计转化到机器可执行代码（实现）的过程中产生的错误。\n③软件维护要应对变更请求，比硬件维护更为复杂。\n④不断的变更是软件退化的根本原因。",
            "name": "1.1.1.3.2 软件不会“磨损”"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.1.1.3.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.1.1.3.3",
            "content": "工程学科的发展将产生一系列标准的设计器件。可复用构件的使用可以使得工程师专心于设计中真正创新的部分。在硬件设计中，构件复用是工程进程中通用的方法 (例如，标准螺丝钉、可订购的集成电路)。\n\n现代可复用软件构件封装了数据和对数据的处理。例如，图形窗口、下拉菜单和各种交互机制。",
            "name": "1.1.1.3.3 基于构件的构造模式"
        }
    },
    {
        "start_id": "S1.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.1.2",
            "name": "1.1.2 软件应用领域"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S1.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.3",
            "name": "1.1.3 遗留软件"
        }
    },
    {
        "start_id": "P1.1.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.1",
            "content": "系统软件是一整套服务于其他程序的程序：\n①某些系统软件（例如编译器、编辑器、文件管理软件）处理复杂但确定的信息结构。\n②另一些系统应用程序（例如操作系统构件、驱动程序、网络软件、远程通信处理器）主要处理的是不确定的数据。\n\n系统软件多具有以下特点：\n①和计算机硬件大量交互；\n②多用户大量使用；\n③需要调度、资源共享和复杂进程管理的同步操作；\n④复杂的数据结构以及多种外部接口。",
            "name": "1.1.2.1.1 系统软件"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.1.2.1.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.1.2.1.2",
            "content": "应用软件是解决特定业务需要的独立应用程序。这类应用软件处理商务或技术数据，以协助业务操作或协助做出管理/技术决策。",
            "name": "1.1.2.1.2 应用软件"
        }
    },
    {
        "start_id": "P1.1.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.2",
            "content": "应用软件是解决特定业务需要的独立应用程序。这类应用软件处理商务或技术数据，以协助业务操作或协助做出管理/技术决策。",
            "name": "1.1.2.1.2 应用软件"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.1.2.1.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.1.2.1.3",
            "content": "工程／科学软件：这类软件通常带着“数值计算”算法的特征，工程和科学软件涵盖了广泛的应用领域，天文学到火山学，从自动压力分析到轨道动力学，从计算机辅助设计到分子生物学，从遗传分\n析到气象学。",
            "name": "1.1.2.1.3 工程/科学软件"
        }
    },
    {
        "start_id": "P1.1.2.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.3",
            "content": "工程／科学软件：这类软件通常带着“数值计算”算法的特征，工程和科学软件涵盖了广泛的应用领域，天文学到火山学，从自动压力分析到轨道动力学，从计算机辅助设计到分子生物学，从遗传分\n析到气象学。",
            "name": "1.1.2.1.3 工程/科学软件"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.1.2.1.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.1.2.1.4",
            "content": "嵌入式软件存在于某个产品或者系统中，可实现和控制面向最终用户和系统本身的特性和功能。\n①嵌入式软件可以执行有限的和内部的功能（例如微波炉的按键控制）\n②可以提供重要的功能和控制能力（例如汽车中的燃油控制、仪表板显示、刹车系统等汽车电子功能）。",
            "name": "1.1.2.1.4 嵌入式软件"
        }
    },
    {
        "start_id": "P1.1.2.1.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.4",
            "content": "嵌入式软件存在于某个产品或者系统中，可实现和控制面向最终用户和系统本身的特性和功能。\n①嵌入式软件可以执行有限的和内部的功能（例如微波炉的按键控制）\n②可以提供重要的功能和控制能力（例如汽车中的燃油控制、仪表板显示、刹车系统等汽车电子功能）。",
            "name": "1.1.2.1.4 嵌入式软件"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.1.2.1.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.1.2.1.5",
            "content": "产品线软件包括可复用的构件，并为多个不同用户的使用提供特定功能。其关注有限的及内部的市场（例如库存控制产品）或者大众消费品市场。\n软件产品线都使用相同的底层应用软件和数据体系结构来开发，并使用可在整个产品线中进行复用的一组软件构件来实现。",
            "name": "1.1.2.1.5 产品线软件"
        }
    },
    {
        "start_id": "P1.1.2.1.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.5",
            "content": "产品线软件包括可复用的构件，并为多个不同用户的使用提供特定功能。其关注有限的及内部的市场（例如库存控制产品）或者大众消费品市场。\n软件产品线都使用相同的底层应用软件和数据体系结构来开发，并使用可在整个产品线中进行复用的一组软件构件来实现。",
            "name": "1.1.2.1.5 产品线软件"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.1.2.1.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.1.2.1.6",
            "content": "Web/移动App：以网络为中心，其概念涵盖了宽泛的应用软件产品，包括基于浏览器的App、云计算、基于服务的计算和安装在移动设备上的软件。\n最简单可以是一组超文本链接文件，仅仅用文本和有限的图形表达信息。随着Web 2.0的出现，网络应用正在发展为复杂的计算环境：比如，网游、网络社区应用。",
            "name": "1.1.2.1.6 Web/移动app"
        }
    },
    {
        "start_id": "P1.1.2.1.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.6",
            "content": "Web/移动App：以网络为中心，其概念涵盖了宽泛的应用软件产品，包括基于浏览器的App、云计算、基于服务的计算和安装在移动设备上的软件。\n最简单可以是一组超文本链接文件，仅仅用文本和有限的图形表达信息。随着Web 2.0的出现，网络应用正在发展为复杂的计算环境：比如，网游、网络社区应用。",
            "name": "1.1.2.1.6 Web/移动app"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.1.2.1.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.1.2.1.7",
            "content": "人工智能软件。利用启发式方法（非数值算法）解决常规计算和直接分析无法解决的复杂问题。\n这个领域的应用程序包括机器人、决策系统、模式识别（图像和语音）机器学习、定理证明和博弈等。",
            "name": "1.1.2.1.7 人工智能软件"
        }
    },
    {
        "start_id": "SS1.1.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.3.1",
            "content": "遗留软件是那些已经过时但仍在运行的软件，它们：①开发年代久远；②一直在使用；③在使用过程中被不断地修改以满足商业需要和计算平台的变化；④可能仍然支持着核心业务。\n它们通常难以维护和升级，但对业务至关重要，因此需要特别的关注和管理。\n\n“遗留软件系统……他们在几十年前诞生，他们不断被修改以满足商业需要和计算平台的变化。这类系统的繁衍使得大型机构十分头痛，因为他们的维护代价高昂且系统演化风险高。”——Dayani-Fard",
            "name": "1.1.3.1 遗留软件的定义"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS1.1.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.3.2",
            "content": "遗留软件通常具有数不清的问题：\n设计难以扩展；\n代码令人费解；\n文档混乱，可能缺失；\n变更管理混乱；\n测试记录未归档；\n……",
            "name": "1.1.3.2 遗留软件的“质量差”问题"
        }
    },
    {
        "start_id": "SS1.1.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.3.2",
            "content": "遗留软件通常具有数不清的问题：\n设计难以扩展；\n代码令人费解；\n文档混乱，可能缺失；\n变更管理混乱；\n测试记录未归档；\n……",
            "name": "1.1.3.2 遗留软件的“质量差”问题"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS1.1.3.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.3.3",
            "content": "由于遗留软件常常支撑着核心业务，对其变更必须非常谨慎。如果它能够满足用户的需求并可靠运行，则不要修改它。\n然而，随着时间的推移，遗留系统经常会出于下述原因而发生演化：\n①进行适应性变化，以满足新的计算环境或者技术的需要；（满足新需求）\n②根据新的业务需求进行升级；（升级）\n③扩展以及具有与更多现代系统或数据库的协作能力；（扩展）\n④改建以适应多样化的网络环境；（改建）",
            "name": "1.1.3.3 遗留软件为什么要演化?"
        }
    },
    {
        "start_id": "T1.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.2",
            "name": "1.2 定义软件工程学科"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T1.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.3",
            "content": "软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。\n①活动(activity)主要实现宽泛的目标（如与利益相关者进行沟通)，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系。\n②动作(action，如体系结构设计）包含主要工作产品(如体系结构设计模型)生产过程中的一系列任务。\n③任务(task)关注小而明确的目标，能够产生实际产品（如构建一个单元测试)。\n\n在软件工程领域，过程不是对如何构建计算机软件的严格规定，而是一种具有可适应性的调整方法，以便于工作人员(软件团队）可以挑选适合的工作动作和任务集合。\n其目标通常是【及时、高质量地交付软件】，以满足软件项目资助方和最终用户的需求。\n \n当开发产品或构建系统时，遵循一系列可预测的步骤（即路线图）是非常重要的，它有助于及时交付高质量的产品。\n软件开发中所遵循的路线图就称为“软件过程”。",
            "name": "1.3 软件过程"
        }
    },
    {
        "start_id": "S1.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.2.1",
            "content": "①软件工程：将系统化的、规范化的、可量化的方法应用于软件的开发、运行和维护，即将工程化的方法应用于软件；  ——IEEE [IEEE93a]\n②软件工程：建立和使用一套合理的工程原则，从而经济地获得可靠的、可在实际机器上高效运行的软件。   ——Fritz Bauer [Nau69]",
            "name": "1.2.1 软件工程的定义"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S1.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.2.2",
            "content": "软件工程是一种层次化技术。任何工程方法（包括软件工程）必须构建在质量承诺的基础之上。你也许听说过全面质量管理（TQM）、六西格玛和类似的理念促进了持续不断的过程改进文化，正是这种文化最终引导人们开发出更有效地软件工程方法。支撑软件工程的根基在于【质量关注点】。",
            "name": "1.2.2 软件工程是一种层次化技术"
        }
    },
    {
        "start_id": "P1.2.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.2.2.1.1",
            "content": "软件工程的基础是【过程】层。过程定义了一个框架，给出了开发步骤，构建该框架是有效实施软件工程技术必不可少的。\n软件过程将各个技术层次结合在一起，使得合理、及时地开发计算机软件成为可能。软件过程构成了软件项目管理控制的基础，建立了工作环境以便应用技术方法、提交工作产品（模型、文档、数据、报告、表格等）、建立里程碑、保证质量以及正确地管理变更。",
            "name": "1.2.2.1.1 过程层"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.2.2.1.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.2.2.1.2",
            "content": "软件工程【方法】为构建软件提供技术上的解决方法（“如何做”）。\n方法覆盖面很广，包括沟通、需求分析、设计建模、编程、测试和技术支持。",
            "name": "1.2.2.1.2 方法层"
        }
    },
    {
        "start_id": "P1.2.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.2.2.1.2",
            "content": "软件工程【方法】为构建软件提供技术上的解决方法（“如何做”）。\n方法覆盖面很广，包括沟通、需求分析、设计建模、编程、测试和技术支持。",
            "name": "1.2.2.1.2 方法层"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.2.2.1.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.2.2.1.3",
            "content": "软件工程【工具】为过程和方法提供自动化或半自动化的支持。\n这些工具可以集成起来，使得一个工具产生的信息可被另外一个工具使用，这样就建立了软件开发的支撑系统。成为“计算机辅助软件工程”。",
            "name": "1.2.2.1.3 工具层"
        }
    },
    {
        "start_id": "T1.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.3",
            "content": "软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。\n①活动(activity)主要实现宽泛的目标（如与利益相关者进行沟通)，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系。\n②动作(action，如体系结构设计）包含主要工作产品(如体系结构设计模型)生产过程中的一系列任务。\n③任务(task)关注小而明确的目标，能够产生实际产品（如构建一个单元测试)。\n\n在软件工程领域，过程不是对如何构建计算机软件的严格规定，而是一种具有可适应性的调整方法，以便于工作人员(软件团队）可以挑选适合的工作动作和任务集合。\n其目标通常是【及时、高质量地交付软件】，以满足软件项目资助方和最终用户的需求。\n \n当开发产品或构建系统时，遵循一系列可预测的步骤（即路线图）是非常重要的，它有助于及时交付高质量的产品。\n软件开发中所遵循的路线图就称为“软件过程”。",
            "name": "1.3 软件过程"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T1.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.4",
            "name": "1.4 软件工程实践"
        }
    },
    {
        "start_id": "S1.3.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.3.1",
            "content": "框架是事物的基本组织、结构。\n\n过程框架定义了若干个框架活动，为实现完整的软件工程奠定了基础的框架：\n①定义了若干小的框架活动，为完整的软件开发过程建立了基础；\n②每一个活动由一组软件工程动作组成：\n③每一个动作都包括一系列相互关联的可考核的任务。（每一个任务完成一个动作定义的一部分工作。）",
            "name": "1.3.1 过程框架"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S1.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.3.2",
            "content": "软件过程框架活动由很多普适性活动来补充实现。通常这些普适性活动贯穿软件项目始终，以帮助软件团队管理和控制项目进度、质量、变更和风险。",
            "name": "1.3.2 普适性活动"
        }
    },
    {
        "start_id": "P1.3.1.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.1",
            "content": "在技术工作开始之前，和客户（及其他利益相关者）的沟通与协作是极其重要\n的，其目的是理解利益相关者的项目目标，并收集需求以定义软件特性和功能。",
            "name": "1.3.1.1.1 沟通"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.1.1.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.1.1.2",
            "content": "如果有地图，任何复杂的旅程都可以变得简单。软件项目好比是一个复杂的旅程，策划活动就是创建一个\"地图\"，以指导团队的项目旅程，这个地图称为软件项目计划，它定义和描述了软件工程工作，包括需要执行的技术任务、可能的风险、资源需求、工作产品和工作进度计划。",
            "name": "1.3.1.1.2 策划"
        }
    },
    {
        "start_id": "P1.3.1.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.2",
            "content": "如果有地图，任何复杂的旅程都可以变得简单。软件项目好比是一个复杂的旅程，策划活动就是创建一个\"地图\"，以指导团队的项目旅程，这个地图称为软件项目计划，它定义和描述了软件工程工作，包括需要执行的技术任务、可能的风险、资源需求、工作产品和工作进度计划。",
            "name": "1.3.1.1.2 策划"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.1.1.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.1.1.3",
            "content": "无论你是庭园设计师、桥梁建造者、航空工程师、木匠还是建筑师，每天的工作都离不开模型。你会画一张草图来辅助理解整个项目大的构想——体系结构、不同的构件如何结合，以及其他一些特性。如果需要，可以把草图不断细化，以便更好地理解问题并找到解决方案。软件工程师也是如此，需要利用模型来更好地理解软件需求，并完成符合这些需求的软件设计。",
            "name": "1.3.1.1.3 建模"
        }
    },
    {
        "start_id": "P1.3.1.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.3",
            "content": "无论你是庭园设计师、桥梁建造者、航空工程师、木匠还是建筑师，每天的工作都离不开模型。你会画一张草图来辅助理解整个项目大的构想——体系结构、不同的构件如何结合，以及其他一些特性。如果需要，可以把草图不断细化，以便更好地理解问题并找到解决方案。软件工程师也是如此，需要利用模型来更好地理解软件需求，并完成符合这些需求的软件设计。",
            "name": "1.3.1.1.3 建模"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.1.1.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.1.1.4",
            "content": "必须对所做的设计进行构建，包括编码（手写的或者自动生成的）和测试，后者用于发现编码中的错误。",
            "name": "1.3.1.1.4 构建"
        }
    },
    {
        "start_id": "P1.3.1.1.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.4",
            "content": "必须对所做的设计进行构建，包括编码（手写的或者自动生成的）和测试，后者用于发现编码中的错误。",
            "name": "1.3.1.1.4 构建"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.1.1.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.1.1.5",
            "content": "软件（全部或者部分增量）交付给用户，用户对其进行评测并基于评测给出反馈意见。",
            "name": "1.3.1.1.5 部署"
        }
    },
    {
        "start_id": "S1.3.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.3.2",
            "content": "软件过程框架活动由很多普适性活动来补充实现。通常这些普适性活动贯穿软件项目始终，以帮助软件团队管理和控制项目进度、质量、变更和风险。",
            "name": "1.3.2 普适性活动"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S1.3.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.3.3",
            "content": "软件工程过程并不是教条的法则，不要求软件团队机械地执行；而应该是灵活可适应的（根据软件所需解决的问题、项目特点、开发团队和组织文化等进行适应性调整）。因此，不同项目所采用的项目过程可能有很大不同。\n\n这些不同主要体现在以下几个方面：\n1.活动、动作和任务的总体流程以及相互依赖关系。\n2.在每一个框架活动中，动作和任务细化的程度。\n3.工作产品的定义和要求的程度。\n4.质量保证活动应用的方式。\n5.项目跟踪和控制活动应用的方式。\n6.过程描述的详细程度和严谨程度。\n7.客户和利益相关者对项目的参与程度。\n8.软件团队所赋予的自主权。\n9.团队组织和角色的明确程度。",
            "name": "1.3.3 过程的适应性调整"
        }
    },
    {
        "start_id": "P1.3.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.1",
            "content": "项目组根据计划来评估项目进度，并且采取必要的措施来保证项目按进度计划进行。",
            "name": "1.3.2.1.1 软件项目跟踪和控制"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.2.1.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.2.1.2",
            "content": "对可能影响项目成果或者产品质量的风险进行评估。",
            "name": "1.3.2.1.2 风险管理"
        }
    },
    {
        "start_id": "P1.3.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.2",
            "content": "对可能影响项目成果或者产品质量的风险进行评估。",
            "name": "1.3.2.1.2 风险管理"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.2.1.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.2.1.3",
            "content": "确定和执行保证软件质量的活动。",
            "name": "1.3.2.1.3 软件质量保证"
        }
    },
    {
        "start_id": "P1.3.2.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.3",
            "content": "确定和执行保证软件质量的活动。",
            "name": "1.3.2.1.3 软件质量保证"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.2.1.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.2.1.4",
            "content": "评估软件工程产品，尽量在传播到下一个活动之前发现错误并清除。",
            "name": "1.3.2.1.4 技术评审"
        }
    },
    {
        "start_id": "P1.3.2.1.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.4",
            "content": "评估软件工程产品，尽量在传播到下一个活动之前发现错误并清除。",
            "name": "1.3.2.1.4 技术评审"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.2.1.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.2.1.5",
            "content": "定义和收集过程、项目以及产品的度量，以帮助团队在发布软件时满足利益相关者的要求。同时，测量还可与其他框架活动和普适性活动配合使用。",
            "name": "1.3.2.1.5 测量"
        }
    },
    {
        "start_id": "P1.3.2.1.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.5",
            "content": "定义和收集过程、项目以及产品的度量，以帮助团队在发布软件时满足利益相关者的要求。同时，测量还可与其他框架活动和普适性活动配合使用。",
            "name": "1.3.2.1.5 测量"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.2.1.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.2.1.6",
            "content": "在整个软件过程中管理变更所带来的影响。",
            "name": "1.3.2.1.6 软件配置管理"
        }
    },
    {
        "start_id": "P1.3.2.1.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.6",
            "content": "在整个软件过程中管理变更所带来的影响。",
            "name": "1.3.2.1.6 软件配置管理"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.2.1.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.2.1.7",
            "content": "定义工作产品（包括软件构件）复用的标准，并且建立构件复用机制。",
            "name": "1.3.2.1.7 可复用性管理"
        }
    },
    {
        "start_id": "P1.3.2.1.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.7",
            "content": "定义工作产品（包括软件构件）复用的标准，并且建立构件复用机制。",
            "name": "1.3.2.1.7 可复用性管理"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.3.2.1.8",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.3.2.1.8",
            "content": "包括生成产品（如建模、文档、日志、表格和列表等）所必需的活动。",
            "name": "1.3.2.1.8 工作产品的准备和生产"
        }
    },
    {
        "start_id": "T1.4",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.4",
            "name": "1.4 软件工程实践"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T1.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.5",
            "name": "1.5 这一切都是如何开始的"
        }
    },
    {
        "start_id": "S1.4.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.4.1",
            "name": "1.4.1 软件工程实践的精髓"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S1.4.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.4.2",
            "name": "1.4.2 通用原则"
        }
    },
    {
        "start_id": "SS1.4.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.4.1.1",
            "content": "虽然难于承认，但我们遇到的问题很多都源于我们的傲慢。我们只听了几秒钟就断言“好，我懂了，让我们开始解决这个问题吧”。不幸的是，理解一个问题不总是那么容易，需要花一点时间回答几个简单问题：\n①谁将从问题的解决中获益？也就是说，谁是利益相关者？\n②有哪些是未知的？哪些数据、功能、特征和行为是解决问题必需的？\n③问题可以划分吗？是否可以描述为更小、更容易理解的问题？\n④问题可以图形化描述吗？可以建立分析模型吗？",
            "name": "1.4.1.1 理解问题"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS1.4.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.1.2",
            "content": "现在你理解了要解决的问题（或者你这样认为），并迫不及待地开始编码。在编码之前，稍稍慢下来做一点点设计：\n①以前曾经见过类似问题吗？在潜在的解决方案中，是否可以识别一些模式？\n②是否已经有软件实现了所需要的数据、功能、特征和行为？\n③类似问题是否解决过？如果是，解决方案所包含元素是否可以复用？\n④可以定义子问题吗？如果可以，子问题是否已有解决方案？\n⑤能用一种可以快速实现的方式来描述解决方案吗？能构建出设计模型吗？",
            "name": "1.4.1.2 策划解决方案"
        }
    },
    {
        "start_id": "SS1.4.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.4.1.2",
            "content": "现在你理解了要解决的问题（或者你这样认为），并迫不及待地开始编码。在编码之前，稍稍慢下来做一点点设计：\n①以前曾经见过类似问题吗？在潜在的解决方案中，是否可以识别一些模式？\n②是否已经有软件实现了所需要的数据、功能、特征和行为？\n③类似问题是否解决过？如果是，解决方案所包含元素是否可以复用？\n④可以定义子问题吗？如果可以，子问题是否已有解决方案？\n⑤能用一种可以快速实现的方式来描述解决方案吗？能构建出设计模型吗？",
            "name": "1.4.1.2 策划解决方案"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS1.4.1.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.1.3",
            "content": "前面所创建的设计勾画了所要构建的系统的路线图。也许存在没有想到的路径，也可能在实施过程中会发现更好的解决路径，但是这个计划可以保证在实施过程中不至于迷失方向。需要考虑的问题是：\n①解决方案和计划一致吗？\n②源码是否可追溯到设计模型？\n③解决方案的每个组成部分是否可以证明正确？\n④设计和代码是否经过评审？\n⑤或者更好的算法是否经过正确性证明？",
            "name": "1.4.1.3 实施计划"
        }
    },
    {
        "start_id": "SS1.4.1.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.4.1.3",
            "content": "前面所创建的设计勾画了所要构建的系统的路线图。也许存在没有想到的路径，也可能在实施过程中会发现更好的解决路径，但是这个计划可以保证在实施过程中不至于迷失方向。需要考虑的问题是：\n①解决方案和计划一致吗？\n②源码是否可追溯到设计模型？\n③解决方案的每个组成部分是否可以证明正确？\n④设计和代码是否经过评审？\n⑤或者更好的算法是否经过正确性证明？",
            "name": "1.4.1.3 实施计划"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS1.4.1.4",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.1.4",
            "content": "你不能保证你的解决方案是最完美的，但是你可以保证设计足够的测试来发现尽可能多的错误。为此，需回答：\n①能否测试解决方案的每个部分？\n②是否实现了合理的测试策略？\n③解决方案是否产生了与所要求的数据、功能、特征和行为一致的结果？\n④是否按照项目共同利益者的需求进行了确认？",
            "name": "1.4.1.4 检查结果"
        }
    },
    {
        "start_id": "P1.4.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.1",
            "content": "一个软件系统因能为用户提供价值而具有存在价值，所有的决策都应该基于这个思想。在确定系统需求之前，在关注系统功能之前，在决定硬件平台或者开发过程之前，问问你自己：这确实能为系统增加真正的价值吗？如果答案是不，那就坚决不做。所有的其他原则都以这条原则为基础。",
            "name": "1.4.2.1.1 第一原则：存在价值"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.4.2.1.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.4.2.1.2",
            "content": "在软件设计中需要考虑很多因素。所有的设计都应该尽可能简洁，但不是过于简化。这有助于构建更易于理解和易于维护的系统。这并不是说有些特性应该以“简洁”为借口而取消。的确，优雅的设计通常也是简洁的设计，但简洁不意味着“快速和粗糙”。事实上，它经常是经过大量思考和多次工作迭代才达到的，这样做的回报是所得到的软件更易于维护且错误更少。",
            "name": "1.4.2.1.2 第二原则：保持简洁"
        }
    },
    {
        "start_id": "P1.4.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.2",
            "content": "在软件设计中需要考虑很多因素。所有的设计都应该尽可能简洁，但不是过于简化。这有助于构建更易于理解和易于维护的系统。这并不是说有些特性应该以“简洁”为借口而取消。的确，优雅的设计通常也是简洁的设计，但简洁不意味着“快速和粗糙”。事实上，它经常是经过大量思考和多次工作迭代才达到的，这样做的回报是所得到的软件更易于维护且错误更少。",
            "name": "1.4.2.1.2 第二原则：保持简洁"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.4.2.1.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.4.2.1.3",
            "content": "在软件设计中需要考虑很多因素。所有的设计都应该尽可能简洁，但不是过于简化。这有助于构建更易于理解和易于维护的系统。这并不是说有些特性应该以“简洁”为借口而取消。的确，优雅的设计通常也是简洁的设计，但简洁不意味着“快速和粗糙”。事实上，它经常是经过大量思考和多次工作迭代才达到的，这样做的回报是所得到的软件更易于维护且错误更少。",
            "name": "1.4.2.1.3 第三原则：保持愿景"
        }
    },
    {
        "start_id": "P1.4.2.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.3",
            "content": "在软件设计中需要考虑很多因素。所有的设计都应该尽可能简洁，但不是过于简化。这有助于构建更易于理解和易于维护的系统。这并不是说有些特性应该以“简洁”为借口而取消。的确，优雅的设计通常也是简洁的设计，但简洁不意味着“快速和粗糙”。事实上，它经常是经过大量思考和多次工作迭代才达到的，这样做的回报是所得到的软件更易于维护且错误更少。",
            "name": "1.4.2.1.3 第三原则：保持愿景"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.4.2.1.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.4.2.1.4",
            "content": "在需求说明、设计、编写文档和实现过程中，牢记要让别人理解你所做的事情。对于任何一个软件产品，其工作产品都可能有很多用户。进行需求说明时应时刻想到用户，设计中始终想到实现，编码时考虑到那些要维护和扩展系统的人。一些人可能不得不调试你所编写的代码，这使得他们成了你所编写代码的使用者，尽可能地使他们的工作简单化会大大提升系统的价值。",
            "name": "1.4.2.1.4 第四原则：关注使用者"
        }
    },
    {
        "start_id": "P1.4.2.1.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.4",
            "content": "在需求说明、设计、编写文档和实现过程中，牢记要让别人理解你所做的事情。对于任何一个软件产品，其工作产品都可能有很多用户。进行需求说明时应时刻想到用户，设计中始终想到实现，编码时考虑到那些要维护和扩展系统的人。一些人可能不得不调试你所编写的代码，这使得他们成了你所编写代码的使用者，尽可能地使他们的工作简单化会大大提升系统的价值。",
            "name": "1.4.2.1.4 第四原则：关注使用者"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.4.2.1.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.4.2.1.5",
            "content": "在现今的计算环境中，需求规格说明随时会改变，硬件平台几个月后就会淘汰，软件生命周期都是以月而不是年来衡量的。然而，真正具有“产业实力”的软件系统必须持久耐用。为了做到这一点，系统必须能适应各种变化，能成功做到这一点的系统都是那些一开始就以这种路线来设计的系统。永远不要把自己的设计局限于一隅，经常问问“如果出现……应该怎样应对”，构建可以解决通用问题的系统，为各种可能的方案做好准备，而不是仅仅针对某一个具体问题。[2]",
            "name": "1.4.2.1.5 第五原则：面向未来"
        }
    },
    {
        "start_id": "P1.4.2.1.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.5",
            "content": "在现今的计算环境中，需求规格说明随时会改变，硬件平台几个月后就会淘汰，软件生命周期都是以月而不是年来衡量的。然而，真正具有“产业实力”的软件系统必须持久耐用。为了做到这一点，系统必须能适应各种变化，能成功做到这一点的系统都是那些一开始就以这种路线来设计的系统。永远不要把自己的设计局限于一隅，经常问问“如果出现……应该怎样应对”，构建可以解决通用问题的系统，为各种可能的方案做好准备，而不是仅仅针对某一个具体问题。[2]",
            "name": "1.4.2.1.5 第五原则：面向未来"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.4.2.1.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.4.2.1.6",
            "content": "复用既省时又省力。软件系统开发过程中，高水平的复用是一个很难实现的目标。曾有人宣称代码和设计复用是面向对象技术带来的主要好处，然而，这种投入的回报不会自动实现。提前做好复用计划将降低开发费用，并增加可复用构件以及构件化系统的价值。",
            "name": "1.4.2.1.6 第六原则：提前计划复用"
        }
    },
    {
        "start_id": "P1.4.2.1.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.6",
            "content": "复用既省时又省力。软件系统开发过程中，高水平的复用是一个很难实现的目标。曾有人宣称代码和设计复用是面向对象技术带来的主要好处，然而，这种投入的回报不会自动实现。提前做好复用计划将降低开发费用，并增加可复用构件以及构件化系统的价值。",
            "name": "1.4.2.1.6 第六原则：提前计划复用"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P1.4.2.1.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P1.4.2.1.7",
            "content": "这最后一条规则可能是最容易被忽略的。在行动之前清晰定位、完整思考通常能产生更好的结果。仔细思考可以提高做好事情的可能性，而且也能获得更多的知识，明确如何把事情再次做好。如果仔细思考过后还是把事情做错了，那么，这就变成了很有价值的经验。思考就是学习和了解本来一无所知的事情，使其成为研究答案的起点。把明确的思想应用在系统中，就产生了价值。使用前6条原则需要认真思考，这将带来巨大的潜在回报。",
            "name": "1.4.2.1.7 第七原则：认真思考"
        }
    },
    {
        "start_id": "T1.5",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.5",
            "name": "1.5 这一切都是如何开始的"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T1.6",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.6",
            "content": "软件是以计算机为基础的系统和产品中的关键部分，并且是世界舞台上最重要的技术之一。在过去的60年里，软件已经从特定问题求解和信息分析的工具发展为独立的产业。如何在有限的时间内利用有限的资金开发高质量的软件，仍然是我们所面对的难题。\n\n软件——程序、数据和描述信息——覆盖了技术和应用的很多领域。遗留软件仍旧给维护人员带来了特殊的挑战。\n软件工程包括【过程、方法和工具】，这些工具使得快速构建高质量的复杂计算机系统成为可能。\n软件过程包括五个框架活动——沟通、策划、建模、构建和部署，这些活动适用于所有的软件项目。\n\n软件工程实践按照一组核心原则，是一项解决问题的活动。随着你对于软件工程的了解越来越多，你会逐渐理解开始一个软件工程项目的时候为什么要考虑这些原则。",
            "name": "1.6 小结"
        }
    },
    {
        "start_id": "CH3",
        "start_labels": [
            "Subject"
        ],
        "start_properties": {
            "id": "CH3",
            "name": "第3章 敏捷和敏捷过程"
        },
        "relation": "Next_SB",
        "relation_properties": {},
        "end_id": "CH6",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH6",
            "name": "第6章 指导实践的原则"
        }
    },
    {
        "start_id": "T3.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.1",
            "name": "3.1 什么是敏捷"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T3.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.2",
            "name": "3.2 敏捷及变更成本"
        }
    },
    {
        "start_id": "S3.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.1.1",
            "content": "1.个体与交互胜过过程与工具\n2.可用的软件胜过完备的文档\n3.客户协作胜过合同谈判\n4.响应变化胜过遵循计划",
            "name": "3.1.1 敏捷宣言"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.2",
            "name": "3.1.2 敏捷价值观"
        }
    },
    {
        "start_id": "S3.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.1.2",
            "name": "3.1.2 敏捷价值观"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.3",
            "content": "敏捷开发是一种软件开发方法论，可以应对客户快速变更的需求。它强调以人为核心，采用迭代的方式，循序渐进地开发软件。",
            "name": "3.1.3 敏捷开发"
        }
    },
    {
        "start_id": "S3.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.1",
            "content": "不但要促进你团队内部的开发人员之间沟通、还能够促进你的团队和你的project stakeholder之间的沟通。",
            "name": "3.1.2.1 沟通"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "S3.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "S3.1.2.2",
            "content": "画一两张图表来代替几十甚至几百行的代码，类似这种方法成为简化软件和软件（开发）过程的关键。这一点对开发人员而言非常重要－它简单，容易发现出新的想法，随着你（对软件）的理解的加深，也能够很容易的改进。",
            "name": "3.1.2.2 简单"
        }
    },
    {
        "start_id": "S3.1.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.2",
            "content": "画一两张图表来代替几十甚至几百行的代码，类似这种方法成为简化软件和软件（开发）过程的关键。这一点对开发人员而言非常重要－它简单，容易发现出新的想法，随着你（对软件）的理解的加深，也能够很容易的改进。",
            "name": "3.1.2.2 简单"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "S3.1.2.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "S3.1.2.3",
            "content": "Kent Beck在Extreme Programming Explained中有句话讲得非常好：“过度自信是编程的职业病，反馈则是其处方。”通过图表来交流你的想法，你可以快速获得反馈，并能够按照建议行事。",
            "name": "3.1.2.3 反馈"
        }
    },
    {
        "start_id": "S3.1.2.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.3",
            "content": "Kent Beck在Extreme Programming Explained中有句话讲得非常好：“过度自信是编程的职业病，反馈则是其处方。”通过图表来交流你的想法，你可以快速获得反馈，并能够按照建议行事。",
            "name": "3.1.2.3 反馈"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "S3.1.2.4",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "S3.1.2.4",
            "content": "1、有勇气主动挑战工作，并承担责任。\n2、有勇气只进行简单的设计，并相信它能够满足客户需求。\n3、有勇气编写测试代码，并相信测试代码能够满足需求。\n4、有勇气拥抱变化，积极适应变化，响应客户需求。\n5、有勇气在需求变化时重构代码。\n6、有勇气不断采用新的开发技术或方法，不断改进，以提高用户满意度。\n7、有勇气对自己的阶段工作进行回顾，总结自己错误的行为并及时纠正。\n8、有勇气面对各种困难和风险，鼓励并带领伙伴一起齐心协力、克服困难、渡过难关。\n9、有勇气向客户承诺并达到它。\n10、有勇气对用户说“不”。尊重用户价值，对用户负责，不欺瞒用户。\n11、有勇气挑战权威，表达自己正确的见解并用实践证明。\n12、有勇气接受任何成员的好建议并改进之。",
            "name": "3.1.2.4 勇气"
        }
    },
    {
        "start_id": "S3.1.2.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.4",
            "content": "1、有勇气主动挑战工作，并承担责任。\n2、有勇气只进行简单的设计，并相信它能够满足客户需求。\n3、有勇气编写测试代码，并相信测试代码能够满足需求。\n4、有勇气拥抱变化，积极适应变化，响应客户需求。\n5、有勇气在需求变化时重构代码。\n6、有勇气不断采用新的开发技术或方法，不断改进，以提高用户满意度。\n7、有勇气对自己的阶段工作进行回顾，总结自己错误的行为并及时纠正。\n8、有勇气面对各种困难和风险，鼓励并带领伙伴一起齐心协力、克服困难、渡过难关。\n9、有勇气向客户承诺并达到它。\n10、有勇气对用户说“不”。尊重用户价值，对用户负责，不欺瞒用户。\n11、有勇气挑战权威，表达自己正确的见解并用实践证明。\n12、有勇气接受任何成员的好建议并改进之。",
            "name": "3.1.2.4 勇气"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "S3.1.2.5",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "S3.1.2.5",
            "content": "最优秀的开发人员都拥有谦逊的美德，他们总能认识到自己并不是无所不知的。事实上，无论是开发人员还是客户，甚至所有的 project stakeholder，都有他们自己的专业领域，都能够为项目做出贡献。一个有效的做法是假设参与项目的每一个人都有相同的价值，都应该被尊重。\n",
            "name": "3.1.2.4 尊重（谦逊）"
        }
    },
    {
        "start_id": "S3.1.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.1.3",
            "content": "敏捷开发是一种软件开发方法论，可以应对客户快速变更的需求。它强调以人为核心，采用迭代的方式，循序渐进地开发软件。",
            "name": "3.1.3 敏捷开发"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.1.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.4",
            "name": "3.1.4 敏捷"
        }
    },
    {
        "start_id": "SS3.1.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.1.4.1",
            "content": "敏捷团队是能够适当响应变化的灵活团队：\n变化就是软件开发本身，软件构建有变化、团队成员在变化、使用新技术会带来变化。\n各种变化都会对开发的软件产品以及项目本身造成影响。我们必须接受“支持变化”的思想，它应当根植于软件开发的每一件事中，因为它是软件的心脏与灵魂。\n敏捷团队意识到软件是由团队中所有人共同开发完成的，这些人的个人技能和合作能力是项目成功的关键所在。 \n普遍存在的变化是敏捷的基本动力。",
            "name": "3.1.4.1 变化以及敏捷团队"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS3.1.4.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.1.4.2",
            "content": "它鼓励能够形成沟通（组员之间、技术和商务人员之间、软件工程师和经理之间）更便利的团队结构和协作态度。\n它强调可运行软件的快速交付而不那么看重中间产品（这并不总是好事情）；\n它将客户作为开发团队的成员以消除一直普遍存在多数软件项目中的“区分你我”的态度；\n它意识到在不确定的世界里计划是有局限性的，项目计划必须是可以灵活调整的。",
            "name": "3.1.4.2 敏捷不仅仅是有效地响应变化"
        }
    },
    {
        "start_id": "T3.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.2",
            "name": "3.2 敏捷及变更成本"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T3.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.3",
            "name": "3.3 什么是敏捷过程"
        }
    },
    {
        "start_id": "S3.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.2.1",
            "content": "软件开发的传统方法中（有几十年的开发经验作支持），变更的成本费用随着计划的进展成非线性增长。这种方法在软件开发团队收集需求时（在项目的早期）相对容易适应变更。\n\n如果我们在经过数月的开发时间之后将会怎么样？团队在进行确认测试的过程中（也许是在项目后期的某个活动中），一个重要的利益相关者要求变更一个主要的功能：这一变更需要对软件的体系结构设计进行修改，包括设计和构建三个新组件，修改另外五个组件，设计新的测试等。费用会迅速升级，而这方面的开销则是可观的。",
            "name": "3.2.1 传统软件开发方法的变更"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.2.2",
            "content": "敏捷的拥护者认为，一个设计良好的敏捷过程“拉平”了变更成本曲线，使软件开发团队在没有超常规的时间和费用影响的情况下，在软件项目后期能够适应各种变化。\n敏捷过程包括增量交付。当增量交付与其他敏捷实践耦合时，例如连续单元测试及结对编程，引起变更的费用会衰减。\n虽然关于拉平曲线的程度的讨论仍然在进行，但是证据表明，敏捷变更费用显著降低。",
            "name": "3.2.2  敏捷的变更"
        }
    },
    {
        "start_id": "T3.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.3",
            "name": "3.3 什么是敏捷过程"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T3.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.4",
            "name": "3.4 Scrum"
        }
    },
    {
        "start_id": "S3.3.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.3.1",
            "content": "1. 我们最优先要做的是通过尽早、持续地交付有价值的软件来使客户满意。\n2. 即使在开发的后期，也欢迎需求变更。敏捷过程利用变更为客户创造竞争优势。\n3. 经常交付可运行软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。\n4. 在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。\n5. 围绕有积极性的个人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。\n6. 在团队内部，最富有效果和效率的信息传递方法是面对面交谈。\n7. 可运行软件是进度的首要度量标准。\n8. 敏捷过程提倡可持续的开发速度。责任人（sponsor）、开发者和用户应该能够保持一个长期的、恒定的开发速度 。\n9. 不断地关注优秀的技能和好的设计会增强敏捷能力。\n10. 简单是必要的。\n11. 最好的架构、需求和设计出自于自组织团队。\n12. 每隔一定时间，团队会反省如何才能更有效地工作，并相应调整自己的行为。\n★并不是每一个敏捷模型都同等使用这12项原则，一些模型可以选择忽略（或至少淡化）一个或多个原则的重要性。",
            "name": "3.3.1 敏捷原则"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.3.2",
            "name": "3.3.2 敏捷过程的特征"
        }
    },
    {
        "start_id": "S3.3.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.3.2",
            "name": "3.3.2 敏捷过程的特征"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.3.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.3.3",
            "name": "3.3.3 人的因素"
        }
    },
    {
        "start_id": "SS3.3.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.3.2.1",
            "content": "任何敏捷软件过程的特征都是以某种方式提出若干关键假设，这些假设适用于大多数软件项目：\n1. 提前预测哪些需求是稳定的以及那些需求会变更是非常困难的。同样，预测项目开发过程中客户优先级的变更也很困难。\n2. 对很多软件来说，设计和构建是交错进行的。也就是说，两种活动应当顺序开展以保证通过构建实施来验证设计模型，而在通过构建验证之前很难估计应该设计到什么程度。\n3. 分析、设计、构建和测试并不像我们设想的那么容易预测。（从制定计划的角度来看）。",
            "name": "3.3.2.1 敏捷过程的三大假设"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS3.3.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.2.2",
            "content": "“如何建立能解决不可预测性的过程？”\n答案就在于过程的可适应性（对于快速变更的项目和技术条件）。因此，敏捷过程必须具有可适应性",
            "name": "3.3.2.2 敏捷过程的一个重要问题"
        }
    },
    {
        "start_id": "SS3.3.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.3.3.1",
            "content": "“敏捷开发关注个人的才智和技巧，根据特定人员和团队来塑造过程。”这一描述的关键点在于“构造可以满足人员及团队需求的过程模型”，而非选择其他的过程模型。",
            "name": "3.3.3.1 构造而非选择"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS3.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        }
    },
    {
        "start_id": "P3.3.3.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.1",
            "content": "同在传统软件工程中一样，在敏捷开发中，“能力”一词包含了个人内在才能、特定的软件相关技能以及对所选过程的全局知识。",
            "name": "3.3.3.2.1 基本能力"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.3.3.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.3.3.2.2",
            "content": "虽然敏捷团队成员能完成不同的任务，为项目提供不同的技能，但是所有人必须瞄准同一个目标，即在承诺的时间内向客户提交可运行的软件增量。为了实现这一目标，项目组还应当做出或大或小的连续的适应性变化，以使过程更适合于团队的需要。",
            "name": "3.3.3.2.2 共同目标"
        }
    },
    {
        "start_id": "P3.3.3.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.2",
            "content": "虽然敏捷团队成员能完成不同的任务，为项目提供不同的技能，但是所有人必须瞄准同一个目标，即在承诺的时间内向客户提交可运行的软件增量。为了实现这一目标，项目组还应当做出或大或小的连续的适应性变化，以使过程更适合于团队的需要。",
            "name": "3.3.3.2.2 共同目标"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.3.3.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.3.3.2.3",
            "content": "项目组成员之间，项目组与所有其他利益相关者之间必须精诚合作。",
            "name": "3.3.3.2.3 精诚合作"
        }
    },
    {
        "start_id": "P3.3.3.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.3",
            "content": "项目组成员之间，项目组与所有其他利益相关者之间必须精诚合作。",
            "name": "3.3.3.2.3 精诚合作"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.3.3.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.3.3.2.4",
            "content": "包括敏捷团队在内，任何一个好的软件项目组必须有能够掌握自身命运的自由。这意味着应当赋予项目组在技术和项目问题上的自主决策权。",
            "name": "3.3.3.2.4 决策能力"
        }
    },
    {
        "start_id": "P3.3.3.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.4",
            "content": "包括敏捷团队在内，任何一个好的软件项目组必须有能够掌握自身命运的自由。这意味着应当赋予项目组在技术和项目问题上的自主决策权。",
            "name": "3.3.3.2.4 决策能力"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.3.3.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.3.3.2.5",
            "content": "软件项目经理应当认识到：敏捷项目组被迫不断面对不确定的事情，被迫不断和变更作斗争。有时，项目组不得不接受今天正在解决的问题明天根本不需解决这样的现实。",
            "name": "3.3.3.2.5 模糊问题解决能力"
        }
    },
    {
        "start_id": "P3.3.3.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.5",
            "content": "软件项目经理应当认识到：敏捷项目组被迫不断面对不确定的事情，被迫不断和变更作斗争。有时，项目组不得不接受今天正在解决的问题明天根本不需解决这样的现实。",
            "name": "3.3.3.2.5 模糊问题解决能力"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.3.3.2.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.3.3.2.6",
            "content": "敏捷团队必须成为具有凝聚力的团队，这样的团队展现出的相互信任和尊重使其形成“一个强有力的组织，确保整体的实力大于各部分实力之和”。",
            "name": "3.3.3.2.6 相互信任和尊重"
        }
    },
    {
        "start_id": "P3.3.3.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.6",
            "content": "敏捷团队必须成为具有凝聚力的团队，这样的团队展现出的相互信任和尊重使其形成“一个强有力的组织，确保整体的实力大于各部分实力之和”。",
            "name": "3.3.3.2.6 相互信任和尊重"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.3.3.2.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.3.3.2.7",
            "content": "自组织在敏捷开发中具有三重含义：\n（1）敏捷团队组织自身以完成工作 (组织团队)；\n（2）团队组织最能适应当前环境的过程 (组织过程)；\n（3）团队组织最好的进度安排以完成软件增量交付 (组织进度)。\n\n自组织具有一些技术上的好处，但是更为重要的是它能促进合作，鼓舞士气。本质上，这也就是项目组的自我管理。",
            "name": "3.3.3.2.7 自组织"
        }
    },
    {
        "start_id": "T3.4",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.4",
            "name": "3.4 Scrum"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T3.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.5",
            "name": "3.5 其他敏捷过程"
        }
    },
    {
        "start_id": "S3.4.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.1",
            "content": "Scrum原则与敏捷宣言是一致的，应用Scrum原则指导过程中的开发活动，过程由“需求、分析、设计、演化和交付”等框架性活动组成。",
            "name": "3.4.1 Scrum团队和制品"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.4.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.4.2",
            "content": "在开始每个冲刺之前，产品负责人会提出他的开发目标，以在即将开始的冲刺中完成增量。",
            "name": "3.4.2 冲刺规划会议"
        }
    },
    {
        "start_id": "S3.4.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.2",
            "content": "在开始每个冲刺之前，产品负责人会提出他的开发目标，以在即将开始的冲刺中完成增量。",
            "name": "3.4.2 冲刺规划会议"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.4.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.4.3",
            "content": "Scrum会议可帮助团队尽早发现潜在的问题。",
            "name": "3.4.3 每日Scrum会议"
        }
    },
    {
        "start_id": "S3.4.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.3",
            "content": "Scrum会议可帮助团队尽早发现潜在的问题。",
            "name": "3.4.3 每日Scrum会议"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.4.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.4.4",
            "content": "开发团队认为增量已完成时，就要召开冲刺评审会议，时间安排在冲刺结束时。",
            "name": "3.4.4 冲刺评审会议"
        }
    },
    {
        "start_id": "S3.4.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.4",
            "content": "开发团队认为增量已完成时，就要召开冲刺评审会议，时间安排在冲刺结束时。",
            "name": "3.4.4 冲刺评审会议"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.4.5",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.4.5",
            "content": "理想情况下，在开始另一个冲刺规划会议前， Scrum master将与开发团队一起安排一场3小时的“冲刺回顾”会议。在会议上，团队将讨论：在冲刺中哪些方面进展顺利？哪些方面需要改进？ 团队在下一个冲刺中将致力于改进什么？",
            "name": "3.4.5 冲刺回顾"
        }
    },
    {
        "start_id": "T3.5",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.5",
            "name": "3.5 其他敏捷过程"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T3.6",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.6",
            "content": "在现代经济中，市场条件变化迅速，客户和最终用户的要求不断更新，新一轮竞争威胁会没有任何征兆地出现。从业者必须使软件工程工作保持敏捷——要定义灵活机动、有适应能力和精益的过程以适应现代商务的需求。\n软件工程的敏捷理念强调4个关键问题:自组织团队对所开展工作具有控制力的重要性;团队成员之间以及开发参与者和客户之间的交流与合作;对“变更代表机遇”的认识;强调快速交付让客户满意的软件。敏捷过程模型能解决上述问题。\n现实情况是，没有一种敏捷方法适合每个项目。敏捷开发人员在自主团队中工作，并有权创建自己的过程模型。\nScrum强调使用一组软件过程模式，这些模式已证明对时间紧迫、需求变更和业务关键的项目有效。Scrum团队没有理由不使用看板图来帮助其组织日常规划会议\n极限编程(XP）按照策划、设计、编码和测试4个框架活动组织，并提出一系列新颖且有力的技术，以保证敏捷团队创建的体现利益相关者指定优先级特征和功能的软件能频繁发布。没有什么能部阻止人们使用DevOps技术来缩短部署时间。",
            "name": "3.6 小结"
        }
    },
    {
        "start_id": "S3.5.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.5.1",
            "name": "3.5.1 XP框架"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.5.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.5.2",
            "name": "3.5.2 看板法"
        }
    },
    {
        "start_id": "SS3.5.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.1.1",
            "content": "极限编程Extreme Programming是使用最广泛的敏捷过程。其具有三个特点：\n1.是一些相互关联的准则和惯例的集合；\n2.追求变更曲线平坦化；\n3.适合于小团队、高风险的项目。",
            "name": "3.5.1.1 极限编程介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS3.5.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.1.2",
            "content": "XP使用面向对象方法作为推荐的开发范型，它包含了策划、设计、编码和测试4个框架活动的规则和实践。",
            "name": "3.5.1.2 极限编程活动"
        }
    },
    {
        "start_id": "P3.5.1.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.1.2.1",
            "content": "1.创建“故事”卡片，描述软件所需功能与特性，由客户用自然语言书写。\n2.评估每个故事，确定开发成本（以周数为单位）。\n3.客户与XP团队共同决定故事分组，确定下一个发行版本（软件增量）。\n4.对发布版本做出基本承诺。\n排序待开发故事：先实现快速、高权值、高风险的故事。\n5.首个版本发布后，XP团队计算项目速度。\n6.开发中，客户可增删改故事或调整权值，XP团队据此调整计划。",
            "name": "3.5.1.2.1 策划"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.1.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.1.2.2",
            "content": "1.严格遵循KIS原则，即追求简洁而非复杂。避免为假定未来需求而设计额外功能。\n2.推荐使用CRC卡来明确与当前软件增量相关的面向对象类。CRC卡包括类、责任和协作者。\n3.在故事设计遇阻时，应立即构建可执行原型（Spike解决方案），通过实践验证设计，降低实现风险，并确认初步估计。\n4.鼓励重构，即在保持代码外部行为不变的前提下，改进其内部结构。重构旨在优化设计和代码，但工作量随软件规模增长而显著增加。",
            "name": "3.5.1.2.2 设计"
        }
    },
    {
        "start_id": "P3.5.1.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.1.2.2",
            "content": "1.严格遵循KIS原则，即追求简洁而非复杂。避免为假定未来需求而设计额外功能。\n2.推荐使用CRC卡来明确与当前软件增量相关的面向对象类。CRC卡包括类、责任和协作者。\n3.在故事设计遇阻时，应立即构建可执行原型（Spike解决方案），通过实践验证设计，降低实现风险，并确认初步估计。\n4.鼓励重构，即在保持代码外部行为不变的前提下，改进其内部结构。重构旨在优化设计和代码，但工作量随软件规模增长而显著增加。",
            "name": "3.5.1.2.2 设计"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.1.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.1.2.3",
            "content": "1.推荐在故事开发和初步设计后，先开发覆盖所有故事的单元测试，再开始编码。这样能在编码完成后立即测试，提供即时反馈。\n2.提倡结对编程，两人共用一台计算机开发代码，实时解决问题和保证质量，同时专注手头问题。\n3.结对编程中，成员角色略有不同，一人负责编码细节，另一人确保编码标准。\n4.完成工作后，代码需与其他人集成。团队或结对者自己负责集成，后者采用“连续集成”策略，避免兼容性和接口问题。",
            "name": "3.5.1.2.3 编码"
        }
    },
    {
        "start_id": "P3.5.1.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.1.2.3",
            "content": "1.推荐在故事开发和初步设计后，先开发覆盖所有故事的单元测试，再开始编码。这样能在编码完成后立即测试，提供即时反馈。\n2.提倡结对编程，两人共用一台计算机开发代码，实时解决问题和保证质量，同时专注手头问题。\n3.结对编程中，成员角色略有不同，一人负责编码细节，另一人确保编码标准。\n4.完成工作后，代码需与其他人集成。团队或结对者自己负责集成，后者采用“连续集成”策略，避免兼容性和接口问题。",
            "name": "3.5.1.2.3 编码"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.1.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.1.2.4",
            "content": "1.单元测试应使用自动框架，便于执行与重复，支持代码修改后的即时回归测试。\n2.个人测试集成到“通用测试集”，每日系统验证，为XP团队提供进度指示并及早预警。\n3.频繁小修比截止期前大修更省时。\n4.XP验收测试由客户主导，针对用户故事实现的功能与特征。",
            "name": "3.5.1.2.4 测试"
        }
    },
    {
        "start_id": "S3.5.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.5.2",
            "name": "3.5.2 看板法"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S3.5.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.5.3",
            "name": "3.5.3 DevOps"
        }
    },
    {
        "start_id": "SS3.5.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.2.1",
            "content": "看板法是一种精益方法学，提供了描述改进过程或工作流的方法。",
            "name": "3.5.2.1 看板法介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS3.5.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        }
    },
    {
        "start_id": "SS3.5.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS3.5.2.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.3",
            "content": "看板法的团队回合与Scrum框架中的会议类似。如果将看板法引入现有项目，则并非所有项目都将在待定项栏目中启动。",
            "name": "3.5.2.3 团队会议"
        }
    },
    {
        "start_id": "P3.5.2.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.1",
            "content": "1.使用看板图可视化工作流。看板图按列组织，分别表示软件功能的每个元素的发展阶段。板上的卡片应包含单个用户故事或最近发现的写在便利贴上的缺陷，团队会随着项目进展将标记从“要做”推进到“正在进行”，再到“已完成”。",
            "name": "3.5.2.2.1 可视化工作流"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.2.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.2.2.2",
            "content": "2.在给定时间内要限制当下工作负荷。鼓励开发人员在开始另一项任务之前完成当前任务。这将缩短交付时间，提高工作质量，并提高团队向利益相关者频繁交付软件功能的能力。",
            "name": "3.5.2.2.2 限制工作负荷"
        }
    },
    {
        "start_id": "P3.5.2.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.2",
            "content": "2.在给定时间内要限制当下工作负荷。鼓励开发人员在开始另一项任务之前完成当前任务。这将缩短交付时间，提高工作质量，并提高团队向利益相关者频繁交付软件功能的能力。",
            "name": "3.5.2.2.2 限制工作负荷"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.2.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.2.2.3",
            "content": "3.通过了解当前价值流，分析停滞位置，定义变更以及实施变更来管理工作流以减少浪费。",
            "name": "3.5.2.2.3 减少浪费"
        }
    },
    {
        "start_id": "P3.5.2.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.3",
            "content": "3.通过了解当前价值流，分析停滞位置，定义变更以及实施变更来管理工作流以减少浪费。",
            "name": "3.5.2.2.3 减少浪费"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.2.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.2.2.4",
            "content": "4.明确的过程策略。",
            "name": "3.5.2.2.4 明确过程策略"
        }
    },
    {
        "start_id": "P3.5.2.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.4",
            "content": "4.明确的过程策略。",
            "name": "3.5.2.2.4 明确过程策略"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.2.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.2.2.5",
            "content": "5.通过创建反馈循环聚焦持续改进，基于过程数据引入变更，并在进行变更后评价变更对过程的影响。",
            "name": "3.5.2.2.5 创建反馈循环"
        }
    },
    {
        "start_id": "P3.5.2.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.5",
            "content": "5.通过创建反馈循环聚焦持续改进，基于过程数据引入变更，并在进行变更后评价变更对过程的影响。",
            "name": "3.5.2.2.5 创建反馈循环"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.2.2.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.2.2.6",
            "content": "6.过程变更中要相互合作，并根据需要让所有团队成员和其他利益相关人参与进来。",
            "name": "3.5.2.2.6 变更中的相互合作"
        }
    },
    {
        "start_id": "SS3.5.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.3.1",
            "content": "DevOps由Patrick DeBois创建，旨在将开发和运维相结合。",
            "name": "3.5.3.1 DevOps介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS3.5.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.3.2",
            "name": "3.5.3.2 DevOps的5个持续循环阶段"
        }
    },
    {
        "start_id": "P3.5.3.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.1",
            "content": "将软件可交付成果分解到多次冲刺中开发，增量由开发团队的质量保证成员进行测试。",
            "name": "3.5.3.2.1 持续开发"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.3.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.3.2.2",
            "content": "自动化测试工具用于帮助团队成员同时测试多个代码增量，以确保在集成之前他们没有缺陷。",
            "name": "3.5.3.2.2 持续测试"
        }
    },
    {
        "start_id": "P3.5.3.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.2",
            "content": "自动化测试工具用于帮助团队成员同时测试多个代码增量，以确保在集成之前他们没有缺陷。",
            "name": "3.5.3.2.2 持续测试"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.3.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.3.2.3",
            "content": "将具有新功能的代码段添加到现有代码和运行环境中，然后对其进行检查以确保部署后没有错误。",
            "name": "3.5.3.2.3 持续集成"
        }
    },
    {
        "start_id": "P3.5.3.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.3",
            "content": "将具有新功能的代码段添加到现有代码和运行环境中，然后对其进行检查以确保部署后没有错误。",
            "name": "3.5.3.2.3 持续集成"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.3.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.3.2.4",
            "content": "在此阶段，将继承代码部署（安装）到生产环境，其中包括准备接收新功能的分布在全球的多个站点。",
            "name": "3.5.3.2.4 持续部署"
        }
    },
    {
        "start_id": "P3.5.3.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.4",
            "content": "在此阶段，将继承代码部署（安装）到生产环境，其中包括准备接收新功能的分布在全球的多个站点。",
            "name": "3.5.3.2.4 持续部署"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P3.5.3.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P3.5.3.2.5",
            "content": "开发团队成员的运维人员通过监控软件在生产环境中的性能，并在用户发现问题之前主动查找问题，以提高软件质量。",
            "name": "3.5.3.2.5 持续监控"
        }
    },
    {
        "start_id": "CH6",
        "start_labels": [
            "Subject"
        ],
        "start_properties": {
            "id": "CH6",
            "name": "第6章 指导实践的原则"
        },
        "relation": "Next_SB",
        "relation_properties": {},
        "end_id": "CH8",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH8",
            "name": "第8章 需求建模——一种推荐的方法"
        }
    },
    {
        "start_id": "T6.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T6.1",
            "name": "6.1 核心原则"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T6.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.2",
            "name": "6.2 指导每个框架活动的原则"
        }
    },
    {
        "start_id": "S6.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.1.1",
            "name": "6.1.1 指导过程的原则"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S6.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.1.2",
            "name": "6.1.2 指导实践的原则"
        }
    },
    {
        "start_id": "SS6.1.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.1.1.1",
            "name": "6.1.1.1 介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "P6.1.1.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.1",
            "content": "关于你所选择的过程模型是传统的还是敏捷的，敏捷开发的基本原则会提供判断方法。你所做的工作的每方面都应着重于活动的经济性——保持你的技术方法尽可能简单，保持你的工作产品尽可能简洁，无论何时尽可能根据具体情况做出决定。",
            "name": "6.1.1.2.1 原则1：敏捷"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.1.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.1.2.2",
            "content": "每个过程活动、动作及任务的出口条件都应关注所生产的工作产品的质量。",
            "name": "6.1.1.2.2 原则2：每一步都关注质量"
        }
    },
    {
        "start_id": "P6.1.1.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.2",
            "content": "每个过程活动、动作及任务的出口条件都应关注所生产的工作产品的质量。",
            "name": "6.1.1.2.2 原则2：每一步都关注质量"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.1.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.1.2.3",
            "content": "过程不是信奉经验，其中没有信条。必要的时候，就让你的方法适应于由问题、人员以及项目本身施加的限制。",
            "name": "6.1.1.2.3 原则3：做好适应的准备"
        }
    },
    {
        "start_id": "P6.1.1.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.3",
            "content": "过程不是信奉经验，其中没有信条。必要的时候，就让你的方法适应于由问题、人员以及项目本身施加的限制。",
            "name": "6.1.1.2.3 原则3：做好适应的准备"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.1.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.1.2.4",
            "content": "软件工程过程和实践是重要的，但最根本的还是人。必须建立一个彼此信任和尊重的自组织团队。",
            "name": "6.1.1.2.4 原则4：建立一个有效的团队"
        }
    },
    {
        "start_id": "P6.1.1.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.4",
            "content": "软件工程过程和实践是重要的，但最根本的还是人。必须建立一个彼此信任和尊重的自组织团队。",
            "name": "6.1.1.2.4 原则4：建立一个有效的团队"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.1.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.1.2.5",
            "content": "建立沟通和协调机制。项目失败是由于遗漏了重要信息，或是利益相关者未能尽力去创造一个成功的最终产品。这些属于管理的问题，必须设法解决。",
            "name": "6.1.1.2.5 原则5：建立沟通和协调机制"
        }
    },
    {
        "start_id": "P6.1.1.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.5",
            "content": "建立沟通和协调机制。项目失败是由于遗漏了重要信息，或是利益相关者未能尽力去创造一个成功的最终产品。这些属于管理的问题，必须设法解决。",
            "name": "6.1.1.2.5 原则5：建立沟通和协调机制"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.1.2.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.1.2.6",
            "content": "管理变更。管理变更的方法可以是正式的或非正式的，但是必须建立一 种机制，来管理变更要求的提出、变更的评估、变更的批准以及变更实施的方式。",
            "name": "6.1.1.2.6 原则6：管理变更"
        }
    },
    {
        "start_id": "P6.1.1.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.6",
            "content": "管理变更。管理变更的方法可以是正式的或非正式的，但是必须建立一 种机制，来管理变更要求的提出、变更的评估、变更的批准以及变更实施的方式。",
            "name": "6.1.1.2.6 原则6：管理变更"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.1.2.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.1.2.7",
            "content": "在进行软件开发时会出现很多问题。建立应急计划是非常重要的。某些应急计划会成为安全工程任务的基准(第18章)。",
            "name": "6.1.1.2.7 原则7：评估风险"
        }
    },
    {
        "start_id": "P6.1.1.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.7",
            "content": "在进行软件开发时会出现很多问题。建立应急计划是非常重要的。某些应急计划会成为安全工程任务的基准(第18章)。",
            "name": "6.1.1.2.7 原则7：评估风险"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.1.2.8",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.1.2.8",
            "content": "唯有那些能为其他过程活动、动作或任务提供价值的工作产品才值得创造。每一个工作产品都会作为软件工程实践的一部分传递给别人。一定要确保工作产品所传达的是必要信息，不会模棱两可或残缺不全。",
            "name": "6.1.1.2.8 原则8：创造能给别人带来价值的工作产品"
        }
    },
    {
        "start_id": "SS6.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.1.2.1",
            "name": "6.1.2.1 介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "P6.1.2.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.1",
            "content": "更具技术性的表达方式是：分析和设计中应经常强调关注点分离( Separation of Concerns, SoCs)。一个大问题分解为一组小元素(或关注点)之后就比较容易求解。",
            "name": "6.1.2.2.1 原则1：分治策略（分割和攻克）"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.2.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.2.2.2",
            "content": "在这一核心原则中， 抽象就是对系统中些复杂元素的简单化、用一个专业用语来交流信息。我使用报表这一抽象概念，是假设你可以理解什么是报表，报表表示的是目录的普通结构，可以将经典的功能应用其中。在软件工程实践中可以使用许多不同层次的抽象，每个抽象都通告或暗示着必须交流的信息。在分析和设计中，软件团队通常从高度抽象的模型开始(如报表)然后逐渐将这些模型提炼成软低层次的抽象(如专栏或SUM功能)。",
            "name": "6.1.2.2.2 原则2：理解抽象的使用"
        }
    },
    {
        "start_id": "P6.1.2.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.2",
            "content": "在这一核心原则中， 抽象就是对系统中些复杂元素的简单化、用一个专业用语来交流信息。我使用报表这一抽象概念，是假设你可以理解什么是报表，报表表示的是目录的普通结构，可以将经典的功能应用其中。在软件工程实践中可以使用许多不同层次的抽象，每个抽象都通告或暗示着必须交流的信息。在分析和设计中，软件团队通常从高度抽象的模型开始(如报表)然后逐渐将这些模型提炼成软低层次的抽象(如专栏或SUM功能)。",
            "name": "6.1.2.2.2 原则2：理解抽象的使用"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.2.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.2.2.3",
            "content": "无论是创建分析模型、开发软件设计、开发源代码还是创建测试用例、一致性原则都建议采用用户熟悉的上下文以使软件易于使用。例如，为手机应用设计一个用户界面，一致的菜单选择、一致的色彩设计以及一致的可识别图标都有助于增强用户体验。",
            "name": "6.1.2.2.3 原则3：力求一致性"
        }
    },
    {
        "start_id": "P6.1.2.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.3",
            "content": "无论是创建分析模型、开发软件设计、开发源代码还是创建测试用例、一致性原则都建议采用用户熟悉的上下文以使软件易于使用。例如，为手机应用设计一个用户界面，一致的菜单选择、一致的色彩设计以及一致的可识别图标都有助于增强用户体验。",
            "name": "6.1.2.2.3 原则3：力求一致性"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.2.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.2.2.4",
            "content": "软件所涉及的信息传送是多方面的——从数据库到最终用户、从遗留的应用系统到WebApp、从最终用户到图形用户界面(GUI)、从操作系统到应用、从一个软件构件到另一个构件，这个列表几乎是无穷无尽的。在每一种情况下，信息都会流经界面，因而，就有可能出现错误、遗漏或者歧义的情况。这一原则的含义是必须特别注意界面的分析、设计、构建以及测试。",
            "name": "6.1.2.2.4 原则4：关注信息传送"
        }
    },
    {
        "start_id": "P6.1.2.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.4",
            "content": "软件所涉及的信息传送是多方面的——从数据库到最终用户、从遗留的应用系统到WebApp、从最终用户到图形用户界面(GUI)、从操作系统到应用、从一个软件构件到另一个构件，这个列表几乎是无穷无尽的。在每一种情况下，信息都会流经界面，因而，就有可能出现错误、遗漏或者歧义的情况。这一原则的含义是必须特别注意界面的分析、设计、构建以及测试。",
            "name": "6.1.2.2.4 原则4：关注信息传送"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.2.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.2.2.5",
            "content": "对重要事务的分制(原则1)建立了软件的哲学.模块化则提供了实现这一哲学的机制。任何一个复杂的系统都可以被分割成许多模块(构件)、但是好的软件工程实践不仅如此，它还要求模块必须是有效的。也就是说，每个模块都应该专门集中表示系统中约束良好的一个方面。另外，模块应当以相对简单的方式与其他模块、数据源以及环境方面关联。",
            "name": "6.1.2.2.5 原则5：构建能展示有效模块化的软件"
        }
    },
    {
        "start_id": "P6.1.2.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.5",
            "content": "对重要事务的分制(原则1)建立了软件的哲学.模块化则提供了实现这一哲学的机制。任何一个复杂的系统都可以被分割成许多模块(构件)、但是好的软件工程实践不仅如此，它还要求模块必须是有效的。也就是说，每个模块都应该专门集中表示系统中约束良好的一个方面。另外，模块应当以相对简单的方式与其他模块、数据源以及环境方面关联。",
            "name": "6.1.2.2.5 原则5：构建能展示有效模块化的软件"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.2.2.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.2.2.6",
            "content": "软件工程师使用模式为他们过去遇到的问题进行分类，并重用其解决方案。通过允许复杂系统中的构件独立发展，可以将这些设计模式应用于更广泛的系程和系统集成问题。模式将在第14章中进一步讨论。",
            "name": "6.1.2.2.6 原则6：寻找模型"
        }
    },
    {
        "start_id": "P6.1.2.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.6",
            "content": "软件工程师使用模式为他们过去遇到的问题进行分类，并重用其解决方案。通过允许复杂系统中的构件独立发展，可以将这些设计模式应用于更广泛的系程和系统集成问题。模式将在第14章中进一步讨论。",
            "name": "6.1.2.2.6 原则6：寻找模型"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.2.2.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.2.2.7",
            "content": "当我们用大量不同的观点检测一个问题及其求解方法时，就很有能获得更深刻的认识，并发现错误和遗漏。统一建模语言（UML）提供了一种从多个视角描述问题解决方案的方式。",
            "name": "6.1.2.2.7 原则7：在可能的时候，用大量不同的观点描述问题及其的解决办法"
        }
    },
    {
        "start_id": "P6.1.2.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.7",
            "content": "当我们用大量不同的观点检测一个问题及其求解方法时，就很有能获得更深刻的认识，并发现错误和遗漏。统一建模语言（UML）提供了一种从多个视角描述问题解决方案的方式。",
            "name": "6.1.2.2.7 原则7：在可能的时候，用大量不同的观点描述问题及其的解决办法"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.1.2.2.8",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.1.2.2.8",
            "content": "从长期看，缺陷暴露出来时，软件需要修正；环境发生变化时，软件需要适应；利益相关者需要更多功能时，软件需要增强。如果可靠的软件工程能够贯穿于整个软件过程，就会便于这些维护活动的实施。",
            "name": "6.1.2.2.8 原则8：记住，有人将要对软件进行维护"
        }
    },
    {
        "start_id": "T6.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T6.2",
            "name": "6.2 指导每个框架活动的原则"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T6.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.3",
            "content": "\"需求建模的目标是创建各种表现形式，用其描述什么是客户需求，为生成的软件设计建立基础，一旦软件建立这些需求将用于验证。需求模型在系统级表示层和软件设计之间构造了桥梁。系统表示层描述了整个系统和业务功能，软件设计描述了软件应用的体系结构、用户接口和构建级的结构。\n  基于场景的模型从用户的角度描述软件需求。用例是主要的建模元素，它以叙述方式或以模板驱动方式描述了参与者和软件之间的交互活动。在需求获取过程中得到的用地定义了特定功能或交互活动的关键步骤。用例的正式程度和详细程度各不相同,但它们可以为所有的其他分析建模活动提供必要的输入。还可以使用活动图说明场景，活动图是描述特定场景内的处理流的图形表现形式。用例中的时序关系可以使用顺序图来建模。\n  为了识别分析类，基于类的建模使用从用例和其他编写的应用描述中导出的信息。可以使用语法解析从文本说明中提取候选类、属性和操作，并使用解析结果制定用于定义类的标准。\n  CRC索引卡可以用于定义类之间的联系。此外，可以使用各种UML建模方法定义类之间的层次、关系、关联、聚合和依赖。\n  在需求分析阶段的行为建模描述了软件的动态，行为建模采用来自基于场景和基于类的输入来表达分析类的状态。为达到这一目的，要识别状态，定义引起类（或系统）由一种状态转换到另一个状态的事件，还要识别完成转换后发生活动。UML状态图、活动图、泳道图和顺序图可以被用于行为建模。\"",
            "name": "6.3 小结"
        }
    },
    {
        "start_id": "S6.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.1",
            "name": "6.2.1 沟通原则"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S6.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.2",
            "name": "6.2.2 策划原则"
        }
    },
    {
        "start_id": "SS6.2.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.1.1",
            "name": "6.2.1.1 介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.1",
            "content": "在沟通之前，一定要确保你能够理解他人的观点，对对方的需求有所了解，然后再倾听。仔细倾听讲话者的每一句话，而不是急于叙述你对这些话的看法。如果有什么事情不清楚，可以要求他澄清，但是不要经常打断别人的讲述。当别人正在陈述的时候不要在言语或动作上表现出异议(比如转动眼睛或者摇头)。",
            "name": "6.2.1.2.1 原则1：倾听"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.2",
            "content": "在与其他人碰面之前花点时间去理解问题。如果必要的话，做一些调查来理解业务领域的术语。如果你负责主持一个会议，那么在开会之前准备一个议事日程。",
            "name": "6.2.1.2.2原则2：有准备的沟通"
        }
    },
    {
        "start_id": "P6.2.1.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.2",
            "content": "在与其他人碰面之前花点时间去理解问题。如果必要的话，做一些调查来理解业务领域的术语。如果你负责主持一个会议，那么在开会之前准备一个议事日程。",
            "name": "6.2.1.2.2原则2：有准备的沟通"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.3",
            "content": "每个沟通会议都应该有个主持人(推动者），其作用是：\n(1)保持会议向着有效的方向进行；\n(2)调解会议中发生的冲突；\n(3)确保遵循我们所说的沟通原则。",
            "name": "6.2.1.2.3 原则3：沟通活动需要有人推动"
        }
    },
    {
        "start_id": "P6.2.1.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.3",
            "content": "每个沟通会议都应该有个主持人(推动者），其作用是：\n(1)保持会议向着有效的方向进行；\n(2)调解会议中发生的冲突；\n(3)确保遵循我们所说的沟通原则。",
            "name": "6.2.1.2.3 原则3：沟通活动需要有人推动"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.4",
            "content": "但是，如果能以一些其他表示方式把相关信息是现出来，通常可以工作得更好，例如可以在集中讨论中使用草图或文档草稿。",
            "name": "6.2.1.2.4 原则4：最好当面沟通"
        }
    },
    {
        "start_id": "P6.2.1.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.4",
            "content": "但是，如果能以一些其他表示方式把相关信息是现出来，通常可以工作得更好，例如可以在集中讨论中使用草图或文档草稿。",
            "name": "6.2.1.2.4 原则4：最好当面沟通"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.5",
            "content": "任何解决方法都可能有缺陷。参与沟通的记录员应该记录下所有要点和决定。",
            "name": "6.2.1.2.5 原则5：记笔记并且记录所有决定"
        }
    },
    {
        "start_id": "P6.2.1.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.5",
            "content": "任何解决方法都可能有缺陷。参与沟通的记录员应该记录下所有要点和决定。",
            "name": "6.2.1.2.5 原则5：记笔记并且记录所有决定"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.6",
            "content": "当项目组成员的想法需要汇集在一起用以阐述一个产品或者某个系统的功能或特性时，就产生了协作与合作的问题。每次小型的协作都可能建立起项目成员间的相互信任，并且为项目组创建一致的目标。",
            "name": "6.2.1.2.6 原则6：保持通力合作"
        }
    },
    {
        "start_id": "P6.2.1.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.6",
            "content": "当项目组成员的想法需要汇集在一起用以阐述一个产品或者某个系统的功能或特性时，就产生了协作与合作的问题。每次小型的协作都可能建立起项目成员间的相互信任，并且为项目组创建一致的目标。",
            "name": "6.2.1.2.6 原则6：保持通力合作"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.7",
            "content": "在任何交流中，参与的人越多，话题转移到其他地方的可能性就越大。推动者应该保持谈话模块化，只有某个话题完全解决之后才能开始别的话题(不过还应该注意原则9)。",
            "name": "6.2.1.2.7 原则7：把讨论集中在限定的范围内"
        }
    },
    {
        "start_id": "P6.2.1.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.7",
            "content": "在任何交流中，参与的人越多，话题转移到其他地方的可能性就越大。推动者应该保持谈话模块化，只有某个话题完全解决之后才能开始别的话题(不过还应该注意原则9)。",
            "name": "6.2.1.2.7 原则7：把讨论集中在限定的范围内"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.8",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.8",
            "content": "语言沟通的效果很有限，当语言无法表述某项工作的时候，草图或者绘图通常可以让表述变得更为清晰。",
            "name": "6.2.1.2.8 原则8：如果某些东西很难表述清楚，就采用图形表示"
        }
    },
    {
        "start_id": "P6.2.1.2.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.8",
            "content": "语言沟通的效果很有限，当语言无法表述某项工作的时候，草图或者绘图通常可以让表述变得更为清晰。",
            "name": "6.2.1.2.8 原则8：如果某些东西很难表述清楚，就采用图形表示"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.9",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.9",
            "content": "交流如同所有其他软件工程活动一样需要时间，与其永无止境地迭代，不如让参与者认识到还有很多话题需要讨论(参见原则2),“转换话题”有时是达到敏捷交流的最好方式。",
            "name": "6.2.1.2.9 原则9：敏捷地转换话题"
        }
    },
    {
        "start_id": "P6.2.1.2.9",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.9",
            "content": "交流如同所有其他软件工程活动一样需要时间，与其永无止境地迭代，不如让参与者认识到还有很多话题需要讨论(参见原则2),“转换话题”有时是达到敏捷交流的最好方式。",
            "name": "6.2.1.2.9 原则9：敏捷地转换话题"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.1.2.10",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.1.2.10",
            "content": "很多时候软件工程师和利益相关者必须商讨一些问题，如功能和特性、优先级和交付日期等。若要团队合作得好，那么各方要有一个共同的目标，并且协商还需要各方的协调。",
            "name": "6.2.1.2.10 原则10：协商不是一场竞赛或者一场游戏，双赢才能发挥协商的最大价值"
        }
    },
    {
        "start_id": "S6.2.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.2",
            "name": "6.2.2 策划原则"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S6.2.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.3",
            "name": "6.2.3 建模原则"
        }
    },
    {
        "start_id": "SS6.2.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.2.1",
            "name": "6.2.2.1 介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.1",
            "content": "如果你不知道要去哪里，就不可能使用路线图。范围可以为软件开发团队提供一个目的地。",
            "name": "6.2.2.2.1 原则1：理解项目范围"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.2",
            "content": "为了适应这种情况，软件工程师必须经常商谈交付的顺序、时间表以及其他与项目相关的问题。",
            "name": "6.2.2.2.2 原则2：让利益相关者参与策划"
        }
    },
    {
        "start_id": "P6.2.2.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.2",
            "content": "为了适应这种情况，软件工程师必须经常商谈交付的顺序、时间表以及其他与项目相关的问题。",
            "name": "6.2.2.2.2 原则2：让利益相关者参与策划"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.3",
            "content": "在工作开始的时候，有很多事情有可能改变，那么就必须调整计划以适应这些变化。另外，在付每个软件增量之后，迭代式增量过程模型应该包含根据用户反馈的信息来修改计划的时间。",
            "name": "6.2.2.2.3 原则3：要认识道计划的指定应按照迭代方式进行"
        }
    },
    {
        "start_id": "P6.2.2.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.3",
            "content": "在工作开始的时候，有很多事情有可能改变，那么就必须调整计划以适应这些变化。另外，在付每个软件增量之后，迭代式增量过程模型应该包含根据用户反馈的信息来修改计划的时间。",
            "name": "6.2.2.2.3 原则3：要认识道计划的指定应按照迭代方式进行"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.4",
            "content": "估算的目的是基于项目组对将要完成工作的当前理解，提供一种关于工作量、成本和任务工期的指标。如果信息是含糊的\n或者不可靠的，估算也将是不可靠的。",
            "name": "6.2.2.2.4 原则4：基于已知的估算"
        }
    },
    {
        "start_id": "P6.2.2.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.4",
            "content": "估算的目的是基于项目组对将要完成工作的当前理解，提供一种关于工作量、成本和任务工期的指标。如果信息是含糊的\n或者不可靠的，估算也将是不可靠的。",
            "name": "6.2.2.2.4 原则4：基于已知的估算"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.5",
            "content": "如果团队已经明确了哪些风险最容易发生且影响最大，那么应急计划就是必需的了。另外，项目计划（包括进度计划）应该可以调整，以适应那些可能发生的一种或多种风险。",
            "name": "6.2.2.2.5 原则5：计划时考虑风险"
        }
    },
    {
        "start_id": "P6.2.2.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.5",
            "content": "如果团队已经明确了哪些风险最容易发生且影响最大，那么应急计划就是必需的了。另外，项目计划（包括进度计划）应该可以调整，以适应那些可能发生的一种或多种风险。",
            "name": "6.2.2.2.5 原则5：计划时考虑风险"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.6",
            "content": "人们不能每天百分百地投入工作。变化总是在发生。甚至最好的软件工程师都会犯错误，这些现实情况都应该在项目制定计划的时候考虑。",
            "name": "6.2.2.2.6 原则6：保证可实现性"
        }
    },
    {
        "start_id": "P6.2.2.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.6",
            "content": "人们不能每天百分百地投入工作。变化总是在发生。甚至最好的软件工程师都会犯错误，这些现实情况都应该在项目制定计划的时候考虑。",
            "name": "6.2.2.2.6 原则6：保证可实现性"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.7",
            "content": "粒度指的是表示或者执行某些计划要素的细节。“细粒度”的计划可以提供重要的工作任务细节，这些细节是在相对短的时间段内计划完成的（这样就常常会有跟踪和控制的问题)。“粗粒度”的计划提供了更宽泛的长时间工作任务。通常，粒度随项目的进行而从细到粗。在很多个月内都不会发生的活动则不需要细化（太多的东西将会发生变化）。",
            "name": "6.2.2.2.7 原则7：调整计划粒度"
        }
    },
    {
        "start_id": "P6.2.2.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.7",
            "content": "粒度指的是表示或者执行某些计划要素的细节。“细粒度”的计划可以提供重要的工作任务细节，这些细节是在相对短的时间段内计划完成的（这样就常常会有跟踪和控制的问题)。“粗粒度”的计划提供了更宽泛的长时间工作任务。通常，粒度随项目的进行而从细到粗。在很多个月内都不会发生的活动则不需要细化（太多的东西将会发生变化）。",
            "name": "6.2.2.2.7 原则7：调整计划粒度"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.8",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.8",
            "content": "计划中应该确定软件开发团队如何确保开发的质量。如果要执行正式技术评审°的话，应该将其列入进度；如果在构建过程中用到了结对编程（第3章)，那么在计划中要明确描述。",
            "name": "6.2.2.2.8 原则8：制定计划一确保质量"
        }
    },
    {
        "start_id": "P6.2.2.2.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.8",
            "content": "计划中应该确定软件开发团队如何确保开发的质量。如果要执行正式技术评审°的话，应该将其列入进度；如果在构建过程中用到了结对编程（第3章)，那么在计划中要明确描述。",
            "name": "6.2.2.2.8 原则8：制定计划一确保质量"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.9",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.9",
            "content": "即使最好的策划也有可能被无法控制的变化破坏。软件开发团队应该确定在软件开发过程中如何适应变化，例如，客户会随时提出变更吗？如果提出了一个变更，团队是不是要立即实现？变更会带来怎样的影响和开销？",
            "name": "6.2.2.2.9 原则9：描述如何适应变化"
        }
    },
    {
        "start_id": "P6.2.2.2.9",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.9",
            "content": "即使最好的策划也有可能被无法控制的变化破坏。软件开发团队应该确定在软件开发过程中如何适应变化，例如，客户会随时提出变更吗？如果提出了一个变更，团队是不是要立即实现？变更会带来怎样的影响和开销？",
            "name": "6.2.2.2.9 原则9：描述如何适应变化"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.2.2.10",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.2.2.10",
            "content": "项目每次会落后进度一天的时间。因此，需要每天都追踪计划的进展，找出计划与实际执行不一致的问题所在，当任务进行出现延误时，计划也要随之做出调整。",
            "name": "6.2.2.2.10 原则10：经常跟踪并根据需要调整计划"
        }
    },
    {
        "start_id": "S6.2.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.3",
            "name": "6.2.3 建模原则"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S6.2.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.4",
            "name": "6.2.4 构建原则"
        }
    },
    {
        "start_id": "SS6.2.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.3.1",
            "name": "6.2.3.1 介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.1",
            "content": "敏捷的意义是尽可能快地将软件提供给用户。可以达到这个目标的模型是值得软件团队构建的，但是，我们需要避免那些降低了开发过程的速度以及不能提供新的见解的模型。",
            "name": "6.2.3.2.1 原则1：软件团队的主要目标是构建软件而不是创建模型"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.2",
            "content": "每次发生变化时，创建的模型必须是最新的。更重要的是，每创建一个新模型所花费的时间，还不如花费在构建软件（编码或测试)。因此，只创建那些可以使软件的构建更加简便和快速的模型。",
            "name": "6.2.3.2.2 原则2：轻装前进——不要创建任何不需要的模型"
        }
    },
    {
        "start_id": "P6.2.3.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.2",
            "content": "每次发生变化时，创建的模型必须是最新的。更重要的是，每创建一个新模型所花费的时间，还不如花费在构建软件（编码或测试)。因此，只创建那些可以使软件的构建更加简便和快速的模型。",
            "name": "6.2.3.2.2 原则2：轻装前进——不要创建任何不需要的模型"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.3",
            "content": "不要建造过于复杂的软件保持模型简单，产生的软件必然也会简单。最终的结果是，软件易于集成、易于测试且易于维护（对于变更）。另外，简单的模型易于开发团队成员理解和评判，从而使得持续不断的反馈可以对最终结果进行优化。",
            "name": "6.2.3.2.3 原则3：尽量创建能描述问题和软件的最简单模型"
        }
    },
    {
        "start_id": "P6.2.3.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.3",
            "content": "不要建造过于复杂的软件保持模型简单，产生的软件必然也会简单。最终的结果是，软件易于集成、易于测试且易于维护（对于变更）。另外，简单的模型易于开发团队成员理解和评判，从而使得持续不断的反馈可以对最终结果进行优化。",
            "name": "6.2.3.2.3 原则3：尽量创建能描述问题和软件的最简单模型"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.4",
            "content": "假设模型将要发生变化，但做这种假设并不草率。问题在于，如果没有相当完整的需求模型，那么所创建的设计（设计模型）会常常丢失重要功能和特性。",
            "name": "6.2.3.2.4原则4：用能适应变化的方式构建模型"
        }
    },
    {
        "start_id": "P6.2.3.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.4",
            "content": "假设模型将要发生变化，但做这种假设并不草率。问题在于，如果没有相当完整的需求模型，那么所创建的设计（设计模型）会常常丢失重要功能和特性。",
            "name": "6.2.3.2.4原则4：用能适应变化的方式构建模型"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.5",
            "content": "每次创建模型时，都问一下自己为什么这么做。如果不能为模型的存在提供可靠的理由，就不要再在这个模型上花费时间。",
            "name": "6.2.3.2.5 原则5：明确描述创建每一个模型的目的"
        }
    },
    {
        "start_id": "P6.2.3.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.5",
            "content": "每次创建模型时，都问一下自己为什么这么做。如果不能为模型的存在提供可靠的理由，就不要再在这个模型上花费时间。",
            "name": "6.2.3.2.5 原则5：明确描述创建每一个模型的目的"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.6",
            "content": "例如，一个电子游戏应用需要的建模技术与自动驾驶汽车所使用的实时嵌入式的巡航定速软件所需的建模技术或许会完全不同。",
            "name": "6.2.3.2.6 原则6：调整模型来适应待开发系统"
        }
    },
    {
        "start_id": "P6.2.3.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.6",
            "content": "例如，一个电子游戏应用需要的建模技术与自动驾驶汽车所使用的实时嵌入式的巡航定速软件所需的建模技术或许会完全不同。",
            "name": "6.2.3.2.6 原则6：调整模型来适应待开发系统"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.7",
            "content": "当构建需求模型和设计模型时，软件工程师要达到减少返工的目的。也就是说，努力使模型绝对完美和内部一致的做法是不值当的。无休止地使模型“完美”并不能满足敏捷的要求。",
            "name": "6.2.3.2.7 原则7：尽量构建有用的模型而不是完美的模型"
        }
    },
    {
        "start_id": "P6.2.3.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.7",
            "content": "当构建需求模型和设计模型时，软件工程师要达到减少返工的目的。也就是说，努力使模型绝对完美和内部一致的做法是不值当的。无休止地使模型“完美”并不能满足敏捷的要求。",
            "name": "6.2.3.2.7 原则7：尽量构建有用的模型而不是完美的模型"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.8",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.8",
            "content": "如果模型能够成功地传递信息，那么表述形式是次要的。虽然软件团队的每个人在建模期间都应使用一致的表达方式，但模型最重要的特性是交流信息，以便软件工程执行下一个任务。如果模型可以成功地做到这一点，不正确的表达方式就可以忽略。",
            "name": "6.2.3.2.8 原则8：对于模型的构造方法不要过于死板。"
        }
    },
    {
        "start_id": "P6.2.3.2.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.8",
            "content": "如果模型能够成功地传递信息，那么表述形式是次要的。虽然软件团队的每个人在建模期间都应使用一致的表达方式，但模型最重要的特性是交流信息，以便软件工程执行下一个任务。如果模型可以成功地做到这一点，不正确的表达方式就可以忽略。",
            "name": "6.2.3.2.8 原则8：对于模型的构造方法不要过于死板。"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.9",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.9",
            "content": "如果你是个有经验的软件工程师，就应相信直觉。软件工作中有许多教训——其中有些是潜意识的。如果有些事情告诉你设计的模型注定会失败（尽管你不能明确地证明），你就有理由再花一些时间来检查模型或开发另一个模型。",
            "name": "6.2.3.2.9 原则9：仔细注意模型"
        }
    },
    {
        "start_id": "P6.2.3.2.9",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.9",
            "content": "如果你是个有经验的软件工程师，就应相信直觉。软件工作中有许多教训——其中有些是潜意识的。如果有些事情告诉你设计的模型注定会失败（尽管你不能明确地证明），你就有理由再花一些时间来检查模型或开发另一个模型。",
            "name": "6.2.3.2.9 原则9：仔细注意模型"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.3.2.10",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.3.2.10",
            "content": "任何模型都是为了传递信息，模型应该能够独立地表达信息，不需要任何人去解释它。每个模型都应经过软件团队的评审。评审的目的是提供反馈，用于纠正模型中的错误、改变误解，并增加不经意遗漏的功能和特性。",
            "name": "6.2.3.2.10 原则10：尽可能快地获得反馈"
        }
    },
    {
        "start_id": "S6.2.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.4",
            "name": "6.2.4 构建原则"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S6.2.5",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.5",
            "name": "6.2.5 部署原则"
        }
    },
    {
        "start_id": "SS6.2.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.4.1",
            "name": "6.2.4.1 介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.2",
            "name": "6.2.4.2 编码原则"
        }
    },
    {
        "start_id": "SS6.2.4.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.4.2",
            "name": "6.2.4.2 编码原则"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.2.1",
            "content": "原则1：理解所要解决的问题。\n原则2：理解基本的设计原则和概念。\n原则3：选择一种能够满足构建软件以及运行环境要求的编程语言。\n原则4：选择一种能提供工具以简化工作的编程环境。\n原则5：构件级编码完成后进行单元测试。",
            "name": "6.2.4.2.1 准备原则"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.2.2",
            "content": "原则6：遵循结构化编程方法来约束算法。\n原则7：考虑使用结对编程。\n原则8：选择能满足设计要求的数据结构。\n原则9：理解软件体系结构并开发出与其相符的接口。",
            "name": "6.2.4.2.2 编程原则"
        }
    },
    {
        "start_id": "P6.2.4.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.2.2",
            "content": "原则6：遵循结构化编程方法来约束算法。\n原则7：考虑使用结对编程。\n原则8：选择能满足设计要求的数据结构。\n原则9：理解软件体系结构并开发出与其相符的接口。",
            "name": "6.2.4.2.2 编程原则"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.2.3",
            "content": "原则10：适当进行代码走查。\n原则11：进行单元测试并改正所发现的错误。\n原则12：重构代码来改进代码质量。",
            "name": "6.2.4.2.3 确认原则"
        }
    },
    {
        "start_id": "P6.2.4.3.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.1",
            "name": "6.2.4.3.1 介绍"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.2",
            "content": "件测试的目标就是要揭示错误。而最严重的错误（从用户的角度来看）是那种导致程序无法满足需求的错误。",
            "name": "6.2.4.3.2 原则1：所有的测试都应该可以追溯到用户需求"
        }
    },
    {
        "start_id": "P6.2.4.3.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.2",
            "content": "件测试的目标就是要揭示错误。而最严重的错误（从用户的角度来看）是那种导致程序无法满足需求的错误。",
            "name": "6.2.4.3.2 原则1：所有的测试都应该可以追溯到用户需求"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.3",
            "content": "测试计划（第19章）在分析模型一完成就应该开始。测试用例的详细定义可以在设计模型确定以后开始。因此，所有的测试在编码前都应该计划和设计好了。",
            "name": "6.2.4.33 原则2：测试计划应该远在测试之前就开始着手"
        }
    },
    {
        "start_id": "P6.2.4.3.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.3",
            "content": "测试计划（第19章）在分析模型一完成就应该开始。测试用例的详细定义可以在设计模型确定以后开始。因此，所有的测试在编码前都应该计划和设计好了。",
            "name": "6.2.4.33 原则2：测试计划应该远在测试之前就开始着手"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.4",
            "content": "简单地说，Pareto原则认为在软件测试过程中80%的错误都可以在大概20%的程序构件中找到根源。接下来的问题当然就是要分离那些可疑的构件，然后对其进行彻底的测试。",
            "name": "6.2.4.3.4 原则3：将Pareto原则应用于软件测试"
        }
    },
    {
        "start_id": "P6.2.4.3.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.4",
            "content": "简单地说，Pareto原则认为在软件测试过程中80%的错误都可以在大概20%的程序构件中找到根源。接下来的问题当然就是要分离那些可疑的构件，然后对其进行彻底的测试。",
            "name": "6.2.4.3.4 原则3：将Pareto原则应用于软件测试"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.5",
            "content": "最初计划并执行的测试通常着眼于单个程序模块，随着测试的进行，着眼点要慢慢转向在集成的构件簇中寻找错误，最后在整个系统中寻找错误。",
            "name": "6.2.4.3.5 原则4：测试应该从“微观”开始，逐步走向“宏观”"
        }
    },
    {
        "start_id": "P6.2.4.3.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.5",
            "content": "最初计划并执行的测试通常着眼于单个程序模块，随着测试的进行，着眼点要慢慢转向在集成的构件簇中寻找错误，最后在整个系统中寻找错误。",
            "name": "6.2.4.3.5 原则4：测试应该从“微观”开始，逐步走向“宏观”"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.6",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.6",
            "content": "即便是一个中等大小的程序，其路径排列组合的数目都非常庞大。因此，在测试中对每个路径组合进行测试是不可能的。然而，充分覆盖程序逻辑并确保构件级设计中的所有条件都通过测试是有可能的。",
            "name": "6.2.4.3.6 原则5：穷举测试是不可能的"
        }
    },
    {
        "start_id": "P6.2.4.3.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.6",
            "content": "即便是一个中等大小的程序，其路径排列组合的数目都非常庞大。因此，在测试中对每个路径组合进行测试是不可能的。然而，充分覆盖程序逻辑并确保构件级设计中的所有条件都通过测试是有可能的。",
            "name": "6.2.4.3.6 原则5：穷举测试是不可能的"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.7",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.7",
            "content": "通常在最新的模块或者开发人员缺乏理解的模块中进行这些测试",
            "name": "6.2.4.3.7 原则6：为系统的每个模块做相应的缺陷密度测试"
        }
    },
    {
        "start_id": "P6.2.4.3.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.7",
            "content": "通常在最新的模块或者开发人员缺乏理解的模块中进行这些测试",
            "name": "6.2.4.3.7 原则6：为系统的每个模块做相应的缺陷密度测试"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.8",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.8",
            "content": "有超过85%的软件缺陷源于软件文档（需求、规格说明、代码走查和用户手册）。这对系统文档测试是有价值的。",
            "name": "6.2.4.3.8 原则7：静态测试技术能得到很好的结果"
        }
    },
    {
        "start_id": "P6.2.4.3.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.8",
            "content": "有超过85%的软件缺陷源于软件文档（需求、规格说明、代码走查和用户手册）。这对系统文档测试是有价值的。",
            "name": "6.2.4.3.8 原则7：静态测试技术能得到很好的结果"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.9",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.9",
            "content": "未发现的缺陷总数是软件质量好坏的指示器，未发现的缺陷类型可以很好地度量软件的稳定性。统计超时发现缺陷的模式可以预测缺陷的期望值。",
            "name": "6.2.4.3.9 原则8：跟踪缺陷，查找并测试未覆盖缺陷的模式"
        }
    },
    {
        "start_id": "P6.2.4.3.9",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.9",
            "content": "未发现的缺陷总数是软件质量好坏的指示器，未发现的缺陷类型可以很好地度量软件的稳定性。统计超时发现缺陷的模式可以预测缺陷的期望值。",
            "name": "6.2.4.3.9 原则8：跟踪缺陷，查找并测试未覆盖缺陷的模式"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.4.3.10",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.4.3.10",
            "content": "在维护和修改软件构件时，未预料到的交互操作会无意识地影响另外的一些构件。在软件产品变更后要准备检测系统行为，进行一组回归测试（第19章）是很重要的。",
            "name": "6.2.4.3.10 原则9：包含在演示软件中的测试用例是正确的行为"
        }
    },
    {
        "start_id": "SS6.2.5.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.5.1",
            "name": "6.2.5.1 介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS6.2.5.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.5.2",
            "name": "6.2.5.2 部署的5个原则"
        }
    },
    {
        "start_id": "P6.2.5.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.1",
            "content": "客户期望的结果通常比软件团队承诺交付的要多，这会很快令客户失望。这将导致客户反馈变得没有积极意义并且还会挫伤软件开发团队的士气。建议软件工程师必须认真地处理与客户有冲突的信息。（例如，对不可能在交付时完成的工作做出了承诺；在某次软件增量交付时交付了多于当初承诺要交付的工作，这将使得下次增量所要做的工作随之变少。）",
            "name": "6.2.5.2.1 原则1：客户对于软件的期望必须得到管理"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.5.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.5.2.2",
            "content": "所有可执行软件、支持数据文件、支持文档和一些相关的信息都必须组装起来，并经过实际用户的完整测试。所有的安装脚本和其他一些可操作的功能都应该在所有可能的计算配置（例如硬件、操作系统、外围设备、网络)环境中实施充分的检验。",
            "name": "6.2.5.2.2 原则2：完整的交付包应该经过安装和测试"
        }
    },
    {
        "start_id": "P6.2.5.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.2",
            "content": "所有可执行软件、支持数据文件、支持文档和一些相关的信息都必须组装起来，并经过实际用户的完整测试。所有的安装脚本和其他一些可操作的功能都应该在所有可能的计算配置（例如硬件、操作系统、外围设备、网络)环境中实施充分的检验。",
            "name": "6.2.5.2.2 原则2：完整的交付包应该经过安装和测试"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.5.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.5.2.3",
            "content": "最终用户希望在问题发生时能得到及时的响应和准确的信息。如果技术支持跟不上或者根本就没有技术支持，那么客户会立即表示不满。支持应该是有计划的，准备好支持的材料并且建立适当的记录保持机制，这样软件开发团队就能按照支持请求种类进行分类评估。",
            "name": "6.2.5.2.3 原则3：技术支持必须在软件交付之前就确定下来"
        }
    },
    {
        "start_id": "P6.2.5.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.3",
            "content": "最终用户希望在问题发生时能得到及时的响应和准确的信息。如果技术支持跟不上或者根本就没有技术支持，那么客户会立即表示不满。支持应该是有计划的，准备好支持的材料并且建立适当的记录保持机制，这样软件开发团队就能按照支持请求种类进行分类评估。",
            "name": "6.2.5.2.3 原则3：技术支持必须在软件交付之前就确定下来"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.5.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.5.2.4",
            "content": "必须为最终用户提供适当的说明材料。软件开发团队交付的不仅仅是软件本破身，也应该提供培训材料（如果需要的话）和故障解决方案，还应该发布关于“本次增量与以前版本有何不同”的描述。",
            "name": "6.2.5.2.4 原则4：必须为最终用户提供适当的说明材料"
        }
    },
    {
        "start_id": "P6.2.5.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.4",
            "content": "必须为最终用户提供适当的说明材料。软件开发团队交付的不仅仅是软件本破身，也应该提供培训材料（如果需要的话）和故障解决方案，还应该发布关于“本次增量与以前版本有何不同”的描述。",
            "name": "6.2.5.2.4 原则4：必须为最终用户提供适当的说明材料"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P6.2.5.2.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P6.2.5.2.5",
            "content": "迫于时间的压力，某些软件组织会交付一些低质量的增量，还会在增量中向客户提出警告：这些缺陷将在下次发布时解决。这样做是错误的。在软件商务活动中有这样一条谚语：“客户在几天后就会忘掉你所交付的高质量软件，但是他们永远忘不掉那些低质量的产品所出现的问题。软件会时刻提醒着问题的存在。”",
            "name": "6.2.5.2.5 原则5：有缺陷的软件应该显改正再交付"
        }
    },
    {
        "start_id": "CH8",
        "start_labels": [
            "Subject"
        ],
        "start_properties": {
            "id": "CH8",
            "name": "第8章 需求建模——一种推荐的方法"
        },
        "relation": "Next_SB",
        "relation_properties": {},
        "end_id": "CH15",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH15",
            "name": "第15章 质量概念"
        }
    },
    {
        "start_id": "T8.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.1",
            "name": "8.1 需求分析"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T8.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.2",
            "name": "8.2 基于场景建模"
        }
    },
    {
        "start_id": "S8.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.1.1",
            "name": "8.1.1 总体目标和原理"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        }
    },
    {
        "start_id": "SS8.1.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.1.1",
            "content": "在整个需求建模过程中，软件工程师的主要关注点集中在“做什么”而不是“怎么做”方面。包括：\n在特定环境下发生哪些用户交互？\n系统处理什么对象？\n系统必须执行什么功能？\n系统展示什么行为？\n定义什么接口？\n有什么约束？",
            "name": "8.1.1.1 主要关注点"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.1.2",
            "content": "需求模型的三个主要目标：\n(1) 描述客户需要什么，分析正确性； \n(2) 为软件设计奠定基础；\n(3) 定义在软件完成后可以被确认的一组需求。",
            "name": "8.1.1.2 三个主要目标"
        }
    },
    {
        "start_id": "S8.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.3",
            "name": "8.1.3 需求建模原则"
        }
    },
    {
        "start_id": "SS8.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.1",
            "content": "模型应关注在问题或业务域内可见的需求，抽象的级别应该相对高一些。“不要陷入细节”，即不要试图解释系统将如何工作。",
            "name": "8.1.2.1 模型关注可见需求"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.2.2",
            "content": "需求模型的每个元素都应能增加对软件需求的整体理解，并提供对信息域、功能和系统行为的深入理解。(存在即有用)",
            "name": "8.1.2.2 模型元素存在即有用"
        }
    },
    {
        "start_id": "SS8.1.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.2",
            "content": "需求模型的每个元素都应能增加对软件需求的整体理解，并提供对信息域、功能和系统行为的深入理解。(存在即有用)",
            "name": "8.1.2.2 模型元素存在即有用"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.2.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.2.3",
            "content": "关于基础结构和其他非功能的模型应推延到设计阶段再考虑。",
            "name": "8.1.2.3 基础结构和非功能模型暂缓考虑"
        }
    },
    {
        "start_id": "SS8.1.2.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.3",
            "content": "关于基础结构和其他非功能的模型应推延到设计阶段再考虑。",
            "name": "8.1.2.3 基础结构和非功能模型暂缓考虑"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.2.4",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.2.4",
            "content": "最小化整个系统内的关联。类和功能之间的联系非常重要，但是，如果“互联”的层次非常高，应该想办法减少互联。",
            "name": "8.1.2.4 最小化整个系统内联"
        }
    },
    {
        "start_id": "SS8.1.2.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.4",
            "content": "最小化整个系统内的关联。类和功能之间的联系非常重要，但是，如果“互联”的层次非常高，应该想办法减少互联。",
            "name": "8.1.2.4 最小化整个系统内联"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.2.5",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.2.5",
            "content": "确认需求模型为所有利益相关者都带来价值。对模型来说，每个客户都有自己的使用目的。\n例如利益相关的业务人员将使用模型确认需求，设计人员将使用模型作为设计的基础；质量保证人员将使用模型帮助规划验收测试。",
            "name": "8.1.2.5 确认需求模型为所有利益相关者都带来价值"
        }
    },
    {
        "start_id": "SS8.1.2.5",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.5",
            "content": "确认需求模型为所有利益相关者都带来价值。对模型来说，每个客户都有自己的使用目的。\n例如利益相关的业务人员将使用模型确认需求，设计人员将使用模型作为设计的基础；质量保证人员将使用模型帮助规划验收测试。",
            "name": "8.1.2.5 确认需求模型为所有利益相关者都带来价值"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.2.6",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.2.6",
            "content": "尽可能保持模型简洁。如果没有提供新的信息，不要添加附加图表；如果一个简单列表就够用，就不要使用复杂的表示方法。",
            "name": "8.1.2.6 保持模型简洁"
        }
    },
    {
        "start_id": "SS8.1.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.1",
            "content": "信息域包含流入系统（来自终端用户、其他系统或外部设备）的数据，流出系统（通过用户界面、网络界面、图形或者其他形式的数据，以及数据存储区中收集和整理的永久保存的数据。",
            "name": "8.1.3.1 原则1：问题的信息域必须得到表达和理解"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.3.2",
            "content": "软件功能可以为终端用户带来直接好处，而那些为用户课件的功能提供内部支持的功能也可以直接受益。一些功能可以变换流入系统的数据。在其他情况下，功能会在某种程度上影响内部软件处理或外部系统元素的控制。",
            "name": "8.1.3.2 原则2：必须定义软件执行的功能"
        }
    },
    {
        "start_id": "SS8.1.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.2",
            "content": "软件功能可以为终端用户带来直接好处，而那些为用户课件的功能提供内部支持的功能也可以直接受益。一些功能可以变换流入系统的数据。在其他情况下，功能会在某种程度上影响内部软件处理或外部系统元素的控制。",
            "name": "8.1.3.2 原则2：必须定义软件执行的功能"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.3.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.3.3",
            "content": "计算机软件的行为受其与外部环境的交互作用的驱动。终端用户提供的输入、外部系统提供的控制数据或通过网络收集的监视数据都使软件以特定方式运行。",
            "name": "8.1.3.3 原则3：必须表示软件的行为"
        }
    },
    {
        "start_id": "SS8.1.3.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.3",
            "content": "计算机软件的行为受其与外部环境的交互作用的驱动。终端用户提供的输入、外部系统提供的控制数据或通过网络收集的监视数据都使软件以特定方式运行。",
            "name": "8.1.3.3 原则3：必须表示软件的行为"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.3.4",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.3.4",
            "content": "需求建模是解决软件工程问题的第一步，为更好地理解问题并为解决方案（设计）建立基础。复杂的问题很难整体解决，因此应该使用分而治之的策略，将一个大而复杂的问题划分为多个子问题，直到每个子问题都相对容易理解为止。（关注点的划分或分离）",
            "name": "8.1.3.4 原则4：描述信息、功能和行为的模型必须以分层的方式进行分割以揭示细节"
        }
    },
    {
        "start_id": "SS8.1.3.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.4",
            "content": "需求建模是解决软件工程问题的第一步，为更好地理解问题并为解决方案（设计）建立基础。复杂的问题很难整体解决，因此应该使用分而治之的策略，将一个大而复杂的问题划分为多个子问题，直到每个子问题都相对容易理解为止。（关注点的划分或分离）",
            "name": "8.1.3.4 原则4：描述信息、功能和行为的模型必须以分层的方式进行分割以揭示细节"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.1.3.5",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.1.3.5",
            "content": "分析建模首先从终端用户的角度描述问题。描述问题的“本质”时没有考虑解决方案的实现方式。\n例如，电子游戏要求玩家在进入危险的迷宫时向其主角“指示”前进的方向（问题的本质）。\n实现细节指出如何实现问题的本质。对于电子游戏，可能会使用语音输入、键入键盘指令、游戏手柄等方法实现。",
            "name": "8.1.3.5 原则5：分析任务应从基本信息转向实现细节"
        }
    },
    {
        "start_id": "T8.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.2",
            "name": "8.2 基于场景建模"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T8.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.3",
            "name": "8.3 基于类建模"
        }
    },
    {
        "start_id": "S8.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.2.1",
            "name": "8.2.1 参与者和用户概要文件"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.2",
            "name": "8.2.2 创建用例"
        }
    },
    {
        "start_id": "SS8.2.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.1.1",
            "content": "UML参与者对与系统对象进行交互的实体进行建模。",
            "name": "8.2.1.1 参与者"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.2.1.2",
            "content": "UML profile提供了一种将现有模型扩展到其他域或平台的方法。",
            "name": "8.2.1.2 用户概要文件"
        }
    },
    {
        "start_id": "S8.2.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.2.2",
            "name": "8.2.2 创建用例"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.2.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.3",
            "name": "8.2.3 编写用例"
        }
    },
    {
        "start_id": "SS8.2.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.2.1",
            "content": "用例的定义 [Ivar Jacobson] ：用例只是帮助定义系统之外存在什么以及系统应完成什么。",
            "name": "8.2.2.1 用例的定义"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.2.2.2",
            "content": "用例从某个特定参与者的角度出发，采用简明的语言描述一个特定的使用场景。问题是：\n(1) 编写什么?\n(2) 写多少?\n(3) 编写说明应该多详细? \n(4) 如何组织说明?",
            "name": "8.2.2.2 创建用例的疑问"
        }
    },
    {
        "start_id": "P8.2.2.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.2.2.2.1",
            "content": "用例应该基于需求工程工作（起始和获取）提供的信息来编写，包括确定利益相关者、定义问题范围、说明运行目标、建立优先级顺序、概述功能需求以及描述系统将处理的信息（对象）。用例从特定参与者的角度出发，描述一个特定的使用场景，通常通过需求收集会议、与利益相关者的交流或评估活动图来获得",
            "name": "8.2.2.2.1 编写什么？ "
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P8.2.2.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P8.2.2.2.2",
            "content": "用例的数量取决于所需系统功能的列表，每个功能或活动都可能对应一个用例。随着与利益相关者的交谈增多，需求收集团队将为每个标记的功能开发用例。",
            "name": "8.2.2.2.2 写多少？"
        }
    },
    {
        "start_id": "P8.2.2.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.2.2.2.2",
            "content": "用例的数量取决于所需系统功能的列表，每个功能或活动都可能对应一个用例。随着与利益相关者的交谈增多，需求收集团队将为每个标记的功能开发用例。",
            "name": "8.2.2.2.2 写多少？"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P8.2.2.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P8.2.2.2.3",
            "content": "用例的描述可以是非正式的描述性风格，也可以是更正式的结构化形式。用例描述应该详细到能够捕捉信息的产生者、使用者和系统本身之间的交互，包括主场景和次场景，以及异常处理。",
            "name": "8.2.2.2.3 编写说明应该有多详细？"
        }
    },
    {
        "start_id": "P8.2.2.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.2.2.2.3",
            "content": "用例的描述可以是非正式的描述性风格，也可以是更正式的结构化形式。用例描述应该详细到能够捕捉信息的产生者、使用者和系统本身之间的交互，包括主场景和次场景，以及异常处理。",
            "name": "8.2.2.2.3 编写说明应该有多详细？"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P8.2.2.2.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P8.2.2.2.4",
            "content": "用例可以通过用户活动的顺序序列来表现交互，每个行动由声明性的语句表示。\n组织说明时，应该包括主场景（主要的交互步骤）和次场景（可供选择的行为或错误条件）。\n异常处理描述了导致系统展示出不同行为的场景，包括失败条件或参与者选择了替代方案。\n组织用例时，可以使用“头脑风暴”来推动团队合理地完成每个用例中的异常处理。",
            "name": "8.2.2.2.4 如何组织说明？"
        }
    },
    {
        "start_id": "SS8.2.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.3.1",
            "content": "当用例需要包括关键活动或描述具有大量异常处理的复杂步骤时，非正式用例可能不足以满足需求，因此需要更正式的方法。",
            "name": "8.2.3.1 为什么需要正式的用例描述？"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.2.3.2",
            "content": "包括用例名称、选代、主要参与者、情境目标、前提条件、触发器、场景、异常处理、优先级、何时有效、使用频率、参与者的连接渠道、次要参与者及其连接渠道、未解决的问题。",
            "name": "8.2.3.2 SafeHome监视的用例模板中包含的关键元素"
        }
    },
    {
        "start_id": "SS8.2.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.3.2",
            "content": "包括用例名称、选代、主要参与者、情境目标、前提条件、触发器、场景、异常处理、优先级、何时有效、使用频率、参与者的连接渠道、次要参与者及其连接渠道、未解决的问题。",
            "name": "8.2.3.2 SafeHome监视的用例模板中包含的关键元素"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.2.3.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.2.3.3",
            "content": "每种需求建模方法都有其局限性，用例方法也无例外：\n1.如果描述不清晰，用例可能会误导或有歧义。\n2.对于必须特别详细和精准的需求建模情景 (例如安全关键系统)，图形化的表示方法更有助于理解。",
            "name": "8.2.3.3 图形化用户场景"
        }
    },
    {
        "start_id": "T8.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.3",
            "name": "8.3 基于类建模"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T8.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.4",
            "name": "8.4 功能建模"
        }
    },
    {
        "start_id": "S8.3.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.3.1",
            "name": "8.3.1 识别分析类"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.2",
            "name": "8.3.2 定义属性和操作"
        }
    },
    {
        "start_id": "SS8.3.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.1.1",
            "content": "通过检查问题描述进行。\n从名词中筛选：\n  ①外部实体 (其他系统、设备、人员)\n  ②事物 (报告、显示、字母、信号)\n  ③偶发事件或事件\n  ④角色 (经理、工程师、销售人员)\n  ⑤组织单元 (部门、组、团队) \n  ⑥场地 (制造车间或码头)\n  ⑦结构 (传感器、四轮交通工具、计算机)\n统称信息(过于宽泛)、基本属性(过于简单)、纯操作不宜选做类",
            "name": "8.3.1.1 识别类"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.3.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.1.2",
            "content": "分析师考虑在每个潜在类是否应使用如下基本特征：\n①保留信息：必须记录潜在类的信息才能保证系统正常工作\n②所需服务：有一组可确认的，能改变属性值的操作\n③多个属性：只有一个属性的类可能在设计中有用，但在分析阶段，更适合作为另一个类的某个属性\n④公共属性：可定义一组属性，它们适用于该潜在类的所有实例\n⑤公共操作：可定义一组操作，它们适用于该潜在类的所有实例\n⑥必要需求：在问题空间中出现的外部实体、或者任何系统解决方案的运行所必需的信息\n应注意到：\n(1)某些被拒绝的潜在类将成为被接受类的属性；\n(2)对问题的不同陈述可能导致作出“接受或拒绝”不同的决定。",
            "name": "8.3.1.2 分析类——寻找潜在类"
        }
    },
    {
        "start_id": "S8.3.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.3.2",
            "name": "8.3.2 定义属性和操作"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.3.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.3",
            "content": "分析师能通过考虑对象间所发生的通信获得对其他操作更为深入的了解。对象通过传递信息与另一个对象通信。在继续对操作进行说明之前，我们探测到了更详实的信息。在许多情况下，两个分析类以某种方式彼此关联。在UML中，这些关系称为关联。",
            "name": "8.3.3 UML类模型"
        }
    },
    {
        "start_id": "SS8.3.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.2.1",
            "content": "为了给分析类开发一个有意义的属性集合，软件工程师应该研究用例并选择那些合理的\"属于\"类的\"事物\"。\n\n属性： “属于”类的事物。\n属性描述已经被选择包含在分析模型中的对象。在本质上，正是属性定义了对象——它们阐明了在问题空间中对象意味着什么。每个类都应回答如下问题：什么数据项（组合项或基本项）能够在当前问题环境内完整地定义这个类？此外，如果有超过一个项和某个类相关联，就应避免把这个项定义为属性。",
            "name": "8.3.2.1 属性定义"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.3.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.2.2",
            "content": "操作定义了某个对象的行为。尽管存在很多不同类型的操作，但通常可以粗略地划分为4种类型：(1）以某种方式操作数据（例如添加、删除、重新格式化、选择）;(2）执行计算的操作；(3）请求某个对象的状态的操作；(4）监视某个对象发生某个控制事件的操作。",
            "name": "8.3.2.2 操作定义"
        }
    },
    {
        "start_id": "S8.3.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.3.3",
            "content": "分析师能通过考虑对象间所发生的通信获得对其他操作更为深入的了解。对象通过传递信息与另一个对象通信。在继续对操作进行说明之前，我们探测到了更详实的信息。在许多情况下，两个分析类以某种方式彼此关联。在UML中，这些关系称为关联。",
            "name": "8.3.3 UML类模型"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.4",
            "name": "8.3.4 类–职责–协作者建模"
        }
    },
    {
        "start_id": "SS8.3.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.1",
            "content": "类﹣职责﹣协作者（CRC）建模提供了一个简单方法，可以识别和组织与系统或产品需求相关的类。职责是和类相关的属性和操作。协作者是提供完成某个职责所需要信息或动作的类。\n\n类，在前面的8.3.1节中已经介绍了识别类和对象的基本原则。\n职责，8.3.2节介绍了识别职责（属性和操作）的基本原则。\n协作。类用一种或两种方法来实现其职责，(1）类可以使用其自身的操作控制各自的属性，从而实现特定的职责；(2）类可以和其他类协作。要识别协作可以通过确认类本身是否能够实现自身的每个职责。如果不能实现每个职责，那么需要和其他类交互。",
            "name": "8.3.4.1 模型介绍"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.2",
            "content": "1.实体类，也称模型或业务类，是从问题说明中直接提取出来的。\n2.边界类用于创建用户可见的和在使用软件时交互的接口(如交互屏幕或打印的报表)。\n3.控制类用于管理“工作单元”。控制类可以管理：\n(1) 实体类的创建或更新；(2) 边界类获取信息后的实例化。(3) 对象集合间的复杂通信。(4) 对象间或用户和应用系统间交换数据的确认。",
            "name": "8.3.4.2 拓展类的三种分类方式"
        }
    },
    {
        "start_id": "SS8.3.4.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.2",
            "content": "1.实体类，也称模型或业务类，是从问题说明中直接提取出来的。\n2.边界类用于创建用户可见的和在使用软件时交互的接口(如交互屏幕或打印的报表)。\n3.控制类用于管理“工作单元”。控制类可以管理：\n(1) 实体类的创建或更新；(2) 边界类获取信息后的实例化。(3) 对象集合间的复杂通信。(4) 对象间或用户和应用系统间交换数据的确认。",
            "name": "8.3.4.2 拓展类的三种分类方式"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.3",
            "name": "8.3.4.3 职责的5个指导原则"
        }
    },
    {
        "start_id": "SS8.3.4.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.3",
            "name": "8.3.4.3 职责的5个指导原则"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.4",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.4",
            "name": "8.3.4.4 协作的必要性"
        }
    },
    {
        "start_id": "P8.3.4.3.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.1",
            "content": "1.把“不灵巧”类(几乎没有职责的类)作为一些“灵巧”类(有很多职责的类)的从属。\n2.每个对象只了解和执行一些事情 (通常是适度集中)，并提高系统的内聚性，这将提高软件的可维护性并减少变更的副作用影响。\n3.应该评估每个CRC模型索引卡上标记的职责，以确定某个类是否应该具有超长的职责列表，如果有这种情况就表明职责太集中，需要将一个类分成多个类或子系统。\n4.每个类的职责应表现在同一抽象层上；",
            "name": "8.3.4.3.1 智能系统应分布在所有类中以求最佳地满足问题的需求"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P8.3.4.3.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P8.3.4.3.2",
            "content": "在类的层级结构的上层保持职责 (属性和操作)的通用性，(因为它们更有一般性，将适用于所有的子类)。\n",
            "name": "8.3.4.3.2 每个职责的说明应尽可能具有普遍性"
        }
    },
    {
        "start_id": "P8.3.4.3.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.2",
            "content": "在类的层级结构的上层保持职责 (属性和操作)的通用性，(因为它们更有一般性，将适用于所有的子类)。\n",
            "name": "8.3.4.3.2 每个职责的说明应尽可能具有普遍性"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P8.3.4.3.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P8.3.4.3.3",
            "content": "这实现了面向对象原则中的封装，数据和操作数据的处理应包装在一个内聚单元中。",
            "name": "8.3.4.3.3 信息和与之相关的行为应放在同一个类中"
        }
    },
    {
        "start_id": "P8.3.4.3.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.3",
            "content": "这实现了面向对象原则中的封装，数据和操作数据的处理应包装在一个内聚单元中。",
            "name": "8.3.4.3.3 信息和与之相关的行为应放在同一个类中"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P8.3.4.3.4",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P8.3.4.3.4",
            "content": "通常应由一个单独的类负责保存和操作某特定类型的信息。通常这个职责不应由多个类分担。如果信息是分布的，软件将变得更加难以维护，测试也会面临更多挑战。",
            "name": "8.3.4.3.4 某个事物的信息应局限于一个类中而不要分布在多个类中"
        }
    },
    {
        "start_id": "P8.3.4.3.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.4",
            "content": "通常应由一个单独的类负责保存和操作某特定类型的信息。通常这个职责不应由多个类分担。如果信息是分布的，软件将变得更加难以维护，测试也会面临更多挑战。",
            "name": "8.3.4.3.4 某个事物的信息应局限于一个类中而不要分布在多个类中"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P8.3.4.3.5",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P8.3.4.3.5",
            "content": "很多情况下，各种相关对象必须在同一时间展示同样的行为；\n例如，一个视频游戏，必须显示如下类：Player, PlayerBody, PlayerArms, PlayerLegs, PlayerHead。每个类都有各自的属性，并且所有这些属性都需要在用户操作游戏时进行更新和显示。因此，每个对象必须共享职责update()和display()。",
            "name": "8.3.4.3.5 职责应由相关类共享"
        }
    },
    {
        "start_id": "SS8.3.4.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.4",
            "name": "8.3.4.4 协作的必要性"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.5",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.5",
            "content": "当开发出一个完整的CRC模型时，利益相关者代表可以使用如下方法评审模型1．所有参加（CRC模型）评审的人员拿到一部分CRC模型索引卡。每个评审员不能有两张存在协作关系的卡片。2．评审组长细致地阅读用例。当评审组长看到一个已命名的对象时，给拥有相应类索引卡的人员一个令牌。3．当令牌传递时，该类卡的拥有者需要描述卡上记录的职责。评审组确定（一个或多个）职责是否满足用例需求。4．如果发现错误，则对索引卡进行修改。修改可能包括定义新类（和相关的CRC索引卡），或者在已有的卡上修改职责和协作列表。",
            "name": "8.3.4.5 评审模型"
        }
    },
    {
        "start_id": "T8.4",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.4",
            "name": "8.4 功能建模"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T8.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.5",
            "name": "8.5 行为建模"
        }
    },
    {
        "start_id": "S8.4.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.4.1",
            "name": "8.4.1 介绍"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.4.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.4.2",
            "content": "无论过程抽象的层次如何，UML活动图都可以用来表示处理细节。从分析阶段，仅在功能相对复杂的情况下才会使用活动图。UML活动图通过提供特定场景内交互流的图形化表示来补充用例，类似于流程图。活动图使用圆角矩形表示特定的系统功能，箭头表示通过系统的流，菱形表示决策分支（标记菱形发出的每个箭头），实水平线表示并行发生的活动。",
            "name": "8.4.2 过程视图"
        }
    },
    {
        "start_id": "S8.4.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.4.2",
            "content": "无论过程抽象的层次如何，UML活动图都可以用来表示处理细节。从分析阶段，仅在功能相对复杂的情况下才会使用活动图。UML活动图通过提供特定场景内交互流的图形化表示来补充用例，类似于流程图。活动图使用圆角矩形表示特定的系统功能，箭头表示通过系统的流，菱形表示决策分支（标记菱形发出的每个箭头），实水平线表示并行发生的活动。",
            "name": "8.4.2 过程视图"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.4.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.4.3",
            "content": "UML 顺序图可用于行为建模。顺序图还可用于显示事件如何引发从一个对象到另一个对象的转移。一旦通过检查用例确定了事件，建模人员就创建了一个顺序图，即用时间函数表示事件是如何引发从一个对象流到另一个对象。顺序图是用例的简化版本，它表示了导致行为从一个类流到另一个类的关键类和事件。\n一旦构建了完整的序列图，就可以将导致系统对象之间转换的所有事件整理为一组输人事件和输出事件集合（来自对象）。对于将要构建的系统而言，这些信息对于创建系统的有效设计很有用。",
            "name": "8.4.3 UML顺序图"
        }
    },
    {
        "start_id": "T8.5",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.5",
            "name": "8.5 行为建模"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T8.6",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.6",
            "content": "\"需求建模的目标是创建各种表现形式，用其描述什么是客户需求，为生成的软件设计建立基础，一旦软件建立这些需求将用于验证。需求模型在系统级表示层和软件设计之间构造了桥梁。系统表示层描述了整个系统和业务功能，软件设计描述了软件应用的体系结构、用户接口和构建级的结构。\n  基于场景的模型从用户的角度描述软件需求。用例是主要的建模元素，它以叙述方式或以模板驱动方式描述了参与者和软件之间的交互活动。在需求获取过程中得到的用地定义了特定功能或交互活动的关键步骤。用例的正式程度和详细程度各不相同,但它们可以为所有的其他分析建模活动提供必要的输入。还可以使用活动图说明场景，活动图是描述特定场景内的处理流的图形表现形式。用例中的时序关系可以使用顺序图来建模。\n  为了识别分析类，基于类的建模使用从用例和其他编写的应用描述中导出的信息。可以使用语法解析从文本说明中提取候选类、属性和操作，并使用解析结果制定用于定义类的标准。\n  CRC索引卡可以用于定义类之间的联系。此外，可以使用各种UML建模方法定义类之间的层次、关系、关联、聚合和依赖。\n  在需求分析阶段的行为建模描述了软件的动态，行为建模采用来自基于场景和基于类的输入来表达分析类的状态。为达到这一目的，要识别状态，定义引起类（或系统）由一种状态转换到另一个状态的事件，还要识别完成转换后发生活动。UML状态图、活动图、泳道图和顺序图可以被用于行为建模。\"",
            "name": "8.6 小结"
        }
    },
    {
        "start_id": "S8.5.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.5.1",
            "name": "8.5.1 介绍"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.5.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.5.2",
            "content": "用例与事件的关系：用例描述了参与者和系统之间的活动顺序，事件则是系统和参与者之间交换信息的事实。 事件的识别：在用例场景中，加下划线的部分表示事件。每个事件都需要确认参与者，并标记交换的所有信息，同时列出所有条件或限制。 事件的例子：以“房主使用键盘键入4位密码”为例，这是一个由房主（Homeowner）向控制面板（ControlPanel）发送的事件，称为输入密码。这个事件传输的信息是4位数字密码，但重要的是已交换信息的事实，而不是信息本身。 事件对控制流的影响：某些事件对用例的控制流有明显影响，而其他事件则没有直接影响。例如，“输入密码”事件不会明显改变控制流，但“比较密码”的结果会明显影响信息流和控制流。 事件的分配：一旦确定了所有事件，这些事件将被分配给所涉及的对象，对象负责生成事件或识别已经在其他地方发生的事件。",
            "name": "8.5.2 识别用例事件"
        }
    },
    {
        "start_id": "S8.5.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.5.2",
            "content": "用例与事件的关系：用例描述了参与者和系统之间的活动顺序，事件则是系统和参与者之间交换信息的事实。 事件的识别：在用例场景中，加下划线的部分表示事件。每个事件都需要确认参与者，并标记交换的所有信息，同时列出所有条件或限制。 事件的例子：以“房主使用键盘键入4位密码”为例，这是一个由房主（Homeowner）向控制面板（ControlPanel）发送的事件，称为输入密码。这个事件传输的信息是4位数字密码，但重要的是已交换信息的事实，而不是信息本身。 事件对控制流的影响：某些事件对用例的控制流有明显影响，而其他事件则没有直接影响。例如，“输入密码”事件不会明显改变控制流，但“比较密码”的结果会明显影响信息流和控制流。 事件的分配：一旦确定了所有事件，这些事件将被分配给所涉及的对象，对象负责生成事件或识别已经在其他地方发生的事件。",
            "name": "8.5.2 识别用例事件"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.5.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.5.3",
            "content": "UML状态图用于展示系统中每个类的状态变化，包括主动状态和被动状态，以及导致状态变化的事件（触发器）。\n状态转移涉及守卫（必须满足的条件）和动作（与状态转移相关的行为），这些要素帮助详细描述对象在不同状态下的行为和响应。",
            "name": "8.5.3 UML状态图"
        }
    },
    {
        "start_id": "S8.5.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.5.3",
            "content": "UML状态图用于展示系统中每个类的状态变化，包括主动状态和被动状态，以及导致状态变化的事件（触发器）。\n状态转移涉及守卫（必须满足的条件）和动作（与状态转移相关的行为），这些要素帮助详细描述对象在不同状态下的行为和响应。",
            "name": "8.5.3 UML状态图"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S8.5.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.5.4",
            "name": "8.5.4 UML活动图"
        }
    },
    {
        "start_id": "SS8.5.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.5.4.1",
            "content": "UML活动图通过展示特定场景下的迭代流来补充用例，提供了系统如何对内部事件做出反应的图形化表示。它能够展示用例中无法直接描述的额外细节，例如用户尝试输入账号和密码的次数限制。",
            "name": "8.5.4.1 UML活动图的作用"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS8.5.4.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.5.4.2",
            "content": "UML泳道图是活动图的变形，它允许建模人员展示活动流，并指出哪个参与者或分析类负责特定的活动。泳道图通过纵向分割图中的并行条（泳道）来表示职责，类似于游泳池中的泳道。\n活动图和泳道图都是以过程为导向的，它们可以一起表示参与者如何调用特定功能以满足系统需求。通过将活动图重新排列并分配到相应的泳道中，可以更清晰地展示不同分析类或参与者的职责和活动。",
            "name": "8.5.4.2 UML泳道图的应用"
        }
    },
    {
        "start_id": "T15.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.1",
            "name": "15.1 什么是质量"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T15.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.2",
            "name": "15.2 软件质量"
        }
    },
    {
        "start_id": "S15.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.1.1",
            "name": "15.1.1 David-Garvin关于质量的5个观点"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.2",
            "name": "15.1.2 设计质量和符合质量"
        }
    },
    {
        "start_id": "SS15.1.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.1",
            "content": "先验论观点认为质量是马上就能识别的东西，却不能清楚地定义。",
            "name": "15.1.1.1 先验论观点"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.1.1.2",
            "content": "用户观点是从最终用户的具体目标来考虑的。如果产品达到这些目标，就是有质量的。",
            "name": "15.1.1.2 用户观点"
        }
    },
    {
        "start_id": "SS15.1.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.2",
            "content": "用户观点是从最终用户的具体目标来考虑的。如果产品达到这些目标，就是有质量的。",
            "name": "15.1.1.2 用户观点"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.1.1.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.1.1.3",
            "content": "制造商观点是从产品原始规格说明的角度来定义质量。如果产品符合规格说明，就是有质量的",
            "name": "15.1.1.3 制造商观点"
        }
    },
    {
        "start_id": "SS15.1.1.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.3",
            "content": "制造商观点是从产品原始规格说明的角度来定义质量。如果产品符合规格说明，就是有质量的",
            "name": "15.1.1.3 制造商观点"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.1.1.4",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.1.1.4",
            "content": "产品观点认为质量是产品的固有属性（比如功能和特性）",
            "name": "15.1.1.4 产品观点"
        }
    },
    {
        "start_id": "SS15.1.1.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.4",
            "content": "产品观点认为质量是产品的固有属性（比如功能和特性）",
            "name": "15.1.1.4 产品观点"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.1.1.5",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.1.1.5",
            "content": "基于价值的观点根据客户愿意为产品支付多少钱来评测质量。",
            "name": "15.1.1.5 基于价值的观点"
        }
    },
    {
        "start_id": "S15.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.1.2",
            "name": "15.1.2 设计质量和符合质量"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.3",
            "content": "“用户满意度 = 合格的产品 + 好的质量 + 按预算和进度安排交付”\n如果一个软件产品能给最终用户带来实质性的益处，他们可能会心甘情愿地忍受偶尔的可靠性或性能问题。现代关于软件质量的观点要求关注客户满意度以及与产品需求的一致性。",
            "name": "15.1.3 质量之外"
        }
    },
    {
        "start_id": "SS15.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.2.1",
            "content": "设计质量是指设计师赋予产品的特性。材料等级、公差和性能等规格说明决定了设计质量。在软件开发中，设计质量包括设计满足需求模型规定的功能和特性的程度。",
            "name": "15.1.2.1 设计质量"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.1.2.2",
            "content": "在软件开发中，符合质量关注的是实现遵从设计的程度以及所得到的系统满足需求和性能目标的程度。",
            "name": "15.1.2.2 符合质量"
        }
    },
    {
        "start_id": "T15.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.2",
            "name": "15.2 软件质量"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T15.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        }
    },
    {
        "start_id": "S15.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.2.1",
            "content": "(1) 在一定程度上应用有效的软件过程；\n(2) 创造有用的产品；\n(3) 为生产者和使用者提供明显的价值。",
            "name": "15.2.1 软件质量的定义"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.2",
            "name": "15.2.2 质量因素"
        }
    },
    {
        "start_id": "SS15.2.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.1.1",
            "content": "有效的软件过程为生产高质量的软件产品奠定了基础。过程的管理方面所做的工作是检验和平衡，以避免项目混乱（低质量的关键因素）。软件工程实践允许开发人员分析问题、设计可靠的解决方案，这些都是生产高质量软件的关键所在。最后，诸如变更管理和技术评审等普适性活动与其他部分的软件工程活动密切相关。",
            "name": "15.2.1.1 有效地软件过程"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.2.1.2",
            "content": "有用的产品是指交付最终用户要求的内容、功能和特征，但最重要的是，以可靠、无误的方式交付这些东西。有用的产品总是满足利益相关者明确提出的那些需求，另外也要满足一些高质量软件应有的隐性需求（例如可用性）",
            "name": "15.2.1.2 有用的产品"
        }
    },
    {
        "start_id": "SS15.2.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.1.2",
            "content": "有用的产品是指交付最终用户要求的内容、功能和特征，但最重要的是，以可靠、无误的方式交付这些东西。有用的产品总是满足利益相关者明确提出的那些需求，另外也要满足一些高质量软件应有的隐性需求（例如可用性）",
            "name": "15.2.1.2 有用的产品"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.2.1.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.2.1.3",
            "content": "通过为软件产品的生产者和使用者增值，高质量软件为软件组织和最终用户群体带来了收益。软件组织获益是因为高质量的软件在维护、改错及客户支持方面的工作量都降低了，从而使软件工程师减少了返工，将更多的时间花费在开发新的应用上，软件组织因此而获得增值。用户群体也得到增值，因为应用所提供的有用的能力在某种程度上加快了一些业务流程。最后的结果是：（1)软件产品的收入增加；（2)当应用可支持业务流程时，收益更好；（3）提高了信息可获得性，这对商业来讲是至关重要的。",
            "name": "15.2.1.3 为软件产品的生产者和使用者带来增值"
        }
    },
    {
        "start_id": "S15.2.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.2.2",
            "name": "15.2.2 质量因素"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.2.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.3",
            "content": "1.用户能够多快确定是否可以使用软件产品来帮助他们完成任务？（适当性）\n2.用户学会如何使用完成任务所需的系统功能需要多长时间？（易学性）\n3.在随后的测试阶段，用户能否回忆起如何使用系统功能，而不必重新进行学习？（易学性）\n4.用户使用系统完成任务需要多长时间？（可操作性）\n5.系统是否会试图防止用户出错？（错误保护）\n6.对于用户界面外观的问题，答案是否给出了满意的回答？（美观性） \n7.界面是否符合第12章中的黄金规则所规定的预期？（可访问性）\n8.用户界面是否符合预期用户所需的可访问性检查清单？（可访问性）",
            "name": "15.2.3 定性质量评估"
        }
    },
    {
        "start_id": "SS15.2.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.2.1",
            "name": "15.2.2.1 McCall的软件质量因素"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.2.2.2",
            "content": "1.功能性。软件满足已确定需求的程度，由以下子属性表征：适合性、准确性、互操作性、依从性(遵照功能需求)和安全保密性。\n2.可靠性。软件可用的时间长度，由以下子属性表征：成熟性、容错性和易恢复性。\n3.易用性。软件容易使用的程度，由以下子属性表征：易理解性、易学习性和易操作性。\n4.效率。软件优化使用系统资源的程度，由以下子属性表征：时间特性和资源利用特性。\n5.维护性。软件易于修复的程度，由以下子属性表征：易分析性、易改变性、易测试性和稳定性。\n6.可移植性。软件可以从一个环境移植到另一个环境的容易程度，由以下子属性表征：适应性、易安装性、符合性 (符合一定的标准和约定)和易替换性 (软件是否容易被替换)。",
            "name": "15.2.2.2 ISO 9126质量因素"
        }
    },
    {
        "start_id": "P15.2.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.2.2.1.1",
            "content": "1.正确性。程序满足其需求规格说明和完成用户任务目标的程度。\n2.可靠性。期望程序以所要求的精度完成其预期功能的程度。\n3.效率。程序完成其功能所需的计算资源和代码的数量。\n4.完整性。对未授权的人员访问软件或数据的可控程度。\n5.易用性。对程序进行学习、操作、准备输入和解释输出所需要的工作量。",
            "name": "15.2.2.1.1 操作特性 (产品运行)"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P15.2.2.1.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P15.2.2.1.2",
            "content": "1.维护性。查出和修复程序中的一个错误所需要的工作量。\n2.灵活性。修改一个运行的程序所需的工作量。\n3.易测试性。测试程序以确保它能完成预期功能所需要的工作量。",
            "name": "15.2.2.1.2 承受变更的能力 (产品修改)"
        }
    },
    {
        "start_id": "P15.2.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.2.2.1.2",
            "content": "1.维护性。查出和修复程序中的一个错误所需要的工作量。\n2.灵活性。修改一个运行的程序所需的工作量。\n3.易测试性。测试程序以确保它能完成预期功能所需要的工作量。",
            "name": "15.2.2.1.2 承受变更的能力 (产品修改)"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P15.2.2.1.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P15.2.2.1.3",
            "content": "1.可移植性。将程序从一个硬件和(或)软件系统环境移植到另一个环境所需要的工作量。\n2.可复用性。程序 (或部分程序)在另一个应用系统中使用的程度。\n3.互操作性。将一个(子)系统连接到另一系统所需要的工作量。",
            "name": "15.2.2.1.3 对新环境的适应能力 (产品转移)"
        }
    },
    {
        "start_id": "SS15.2.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.2.2",
            "content": "1.功能性。软件满足已确定需求的程度，由以下子属性表征：适合性、准确性、互操作性、依从性(遵照功能需求)和安全保密性。\n2.可靠性。软件可用的时间长度，由以下子属性表征：成熟性、容错性和易恢复性。\n3.易用性。软件容易使用的程度，由以下子属性表征：易理解性、易学习性和易操作性。\n4.效率。软件优化使用系统资源的程度，由以下子属性表征：时间特性和资源利用特性。\n5.维护性。软件易于修复的程度，由以下子属性表征：易分析性、易改变性、易测试性和稳定性。\n6.可移植性。软件可以从一个环境移植到另一个环境的容易程度，由以下子属性表征：适应性、易安装性、符合性 (符合一定的标准和约定)和易替换性 (软件是否容易被替换)。",
            "name": "15.2.2.2 ISO 9126质量因素"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.2.2.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.2.2.3",
            "content": "1.有效性。用户实现目标的准确性和完整性。\n2.效率。为了完全达到用户目标和预期的准确性而花费的资源。\n3.满意度。有用、信任、快乐、舒适。\n4.远离风险。缓解经济、健康、安全和环境风险。\n5.语境覆盖。完整性、灵活性。",
            "name": "15.2.2.3 使用质量模型"
        }
    },
    {
        "start_id": "SS15.2.2.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.2.3",
            "content": "1.有效性。用户实现目标的准确性和完整性。\n2.效率。为了完全达到用户目标和预期的准确性而花费的资源。\n3.满意度。有用、信任、快乐、舒适。\n4.远离风险。缓解经济、健康、安全和环境风险。\n5.语境覆盖。完整性、灵活性。",
            "name": "15.2.2.3 使用质量模型"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.2.2.4",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.2.2.4",
            "content": "1.功能适应性。完整、正确、适当。\n2.性能效率。时间、资源利用、容量。\n3.兼容性。共存、互操作性。\n4.可用性。适当性、易学性、可操作性、错误保护、美观性、可访问性。\n5.可靠性。成熟度、可用性、容错性、可恢复性。\n6.安全性。保密性、完整性、可审核性、真实性。\n7.可维护性。保密性、完整性、可审核性、真实性。\n8.可移植性。适应性、可安装性、可替换性。",
            "name": "15.2.2.4 产品质量模型"
        }
    },
    {
        "start_id": "S15.2.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.2.3",
            "content": "1.用户能够多快确定是否可以使用软件产品来帮助他们完成任务？（适当性）\n2.用户学会如何使用完成任务所需的系统功能需要多长时间？（易学性）\n3.在随后的测试阶段，用户能否回忆起如何使用系统功能，而不必重新进行学习？（易学性）\n4.用户使用系统完成任务需要多长时间？（可操作性）\n5.系统是否会试图防止用户出错？（错误保护）\n6.对于用户界面外观的问题，答案是否给出了满意的回答？（美观性） \n7.界面是否符合第12章中的黄金规则所规定的预期？（可访问性）\n8.用户界面是否符合预期用户所需的可访问性检查清单？（可访问性）",
            "name": "15.2.3 定性质量评估"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.2.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.4",
            "content": "主观性和特殊性也适用于软件质量的确定。要想对软件质量进行直接量化很难。\n\n可以提出一组可应用于软件质量定量评估的软件度量：\n1.也就是说，我们从不真正测量质量，而是测量质量的一些表现。\n2.复杂因素在于所测量的变量和软件质量间的精确关系。",
            "name": "15.2.4 定量质量评估"
        }
    },
    {
        "start_id": "T15.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T15.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.4",
            "name": "15.4 实现软件质量"
        }
    },
    {
        "start_id": "S15.3.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.1",
            "content": "如果生产一个存在严重质量问题的软件系统，你将受到损失，因为没有人想去购买。另一方面，如果你花费无限的时间、极大的工作量和高额的资金来开发一个绝对完美的软件，那么完成该软件将花费很长的时间，生产成本是极其高昂的，以至于破产。要么没人购买，要么几乎耗尽所有资源、错过市场机会。所以企业界的人们努力达到奇妙的中间状态：\n1.一方面，产品要足够好，不会立即被抛弃；\n2.另一方面，又不是那么完美，不需花费太长时间和太多成本。",
            "name": "15.3.1 困境论述"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.2",
            "content": "足够好的软件提供用户期望的高质量功能和特性，但同时也提供了一些难解的或特殊的错误。软件供应商希望广大的最终用户忽视错误，因为他们对其他的应用功能是如此满意。",
            "name": "15.3.2 “足够好”的软件"
        }
    },
    {
        "start_id": "S15.3.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.2",
            "content": "足够好的软件提供用户期望的高质量功能和特性，但同时也提供了一些难解的或特殊的错误。软件供应商希望广大的最终用户忽视错误，因为他们对其他的应用功能是如此满意。",
            "name": "15.3.2 “足够好”的软件"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.3.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.3",
            "content": "质量成本包括追求质量过程中或在履行质量有关的活动中引起的费用以及质量不佳引起的费用等。\n质量成本可分为：1.预防成本。2.评估成本。3.失效成本。",
            "name": "15.3.3 质量的成本"
        }
    },
    {
        "start_id": "S15.3.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.3",
            "content": "质量成本包括追求质量过程中或在履行质量有关的活动中引起的费用以及质量不佳引起的费用等。\n质量成本可分为：1.预防成本。2.评估成本。3.失效成本。",
            "name": "15.3.3 质量的成本"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.4",
            "name": "15.3.4 风险"
        }
    },
    {
        "start_id": "SS15.3.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.3.1",
            "content": "质量是重要的，但是花费太多的时间和金钱才能达到我们实际需要的软件质量水平。毫无疑问，质量是有成本的，但缺乏质量也有成本。真正的问题是：我们应该担心哪些成本？\n要回答这个问题，必须既要了解实现质量的成本，又要了解低质量软件导致的成本。",
            "name": "15.3.3.1 质量成本的争论"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.3.2",
            "name": "15.3.3.2 质量成本的3个分类"
        }
    },
    {
        "start_id": "P15.3.3.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.3.2.1",
            "content": "预防成本包括：（1)计划和协调所有质量控制和质量保证所需管理活动的成本；（2)为开发完整的需求模型和设计模型所增加的技术活动的成本；（3)测试计划的成本；（4)与这些活动有关的所有培训成本。不要害怕带来相当大的预防成本。请放心，你的投资将带来丰厚的回报。评估成本包括为深入了解产品“第一次通过”每个过程的条件而进行的活动。",
            "name": "15.3.3.2.1 预防成本"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P15.3.3.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P15.3.3.2.2",
            "content": "评估成本的例子包括：(1)对软件工程工作产品进行技术评审（第16章）的成本；（2)数据收集和度量估算（第23章）的成本；（3)测试和调试（第19-21章）的成本。失效成本是那些在将产品交付客户之前若没有出现错误就不会发生的费用。",
            "name": "15.3.3.2.2 评估成本"
        }
    },
    {
        "start_id": "P15.3.3.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.3.2.2",
            "content": "评估成本的例子包括：(1)对软件工程工作产品进行技术评审（第16章）的成本；（2)数据收集和度量估算（第23章）的成本；（3)测试和调试（第19-21章）的成本。失效成本是那些在将产品交付客户之前若没有出现错误就不会发生的费用。",
            "name": "15.3.3.2.2 评估成本"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P15.3.3.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P15.3.3.2.3",
            "content": "失效成本可分为内部失效成本和外部失效成本。内部失效成本发生在软件发布之前发现错误时，内部失效成本包括：（1)为纠正错误进行返工（修复）所需的成本；（2)返工时无意中产生副作用，必须对副作用加以缓解而发生的成本；（3)组织为评估失效的模型而收集质量数据，由此发生的相关成本。外部失效成本是在产品已经发布给客户之后发现了缺陷时的相关成本。外部成本的例子包括：解决投诉，产品退货和更换，帮助作业支持，以及与保修工作相关的人力成本。不良的声誉和由此产生的业务损失是另一个外部失效成本，这是很难量化但非常现实的。生产了低质量的软件产品时，不好的事情就要发生。",
            "name": "15.3.3.2.3 失效成本"
        }
    },
    {
        "start_id": "S15.3.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.4",
            "name": "15.3.4 风险"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.3.5",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.5",
            "content": "政府或企业雇用一个较大的软件开发商或咨询公司来分析需求，然后设计和创建一个基于软件的“系统”，用以支撑某个重大的活动。系统可能支持主要的企业功能（例如，养老金管理)，或某项政府职能（例如，卫生保健管理或国土安全）。\n工作始于双方良好的意愿，但是到了系统交付时，情况已变得糟糕，系统延期，未能提供预期的特性和功能，而且易出错，不能得到客户的认可，接下来就要打官司。在大多数情况下，顾客称开发商马虎大意（已带到了软件实践中），因此拒绝付款。而开发商则常常声称，顾客一再改变其要求，并在其他方面破坏了开发伙伴关系。无论是哪一种情况，交付系统的质量都会有问题。",
            "name": "15.3.5 疏忽和责任"
        }
    },
    {
        "start_id": "SS15.3.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.4.1",
            "content": "设计和实现低劣的应用系统所带来的损失并不总是限于金钱和时间。",
            "name": "15.3.4.1 低质量软件带来风险"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.3.4.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.4.2",
            "content": "在2000年11月，巴拿马的一家医院，28位病人在治疗多种癌症过程中接收了过量的伽玛射线照射。此后数月内，其中5例死于辐射病，15人发展成严重的并发症。是什么造成了这一悲剧？\n为了计算每位病人接受的辐射剂量，医院的技术人员对一家美国公司开发的软件包进行了修改。为了提供额外的能力，这3个巴拿马医疗物理学家“调整”了软件，他们被指控犯有二级谋杀罪，这家美国公司正在两个国家面临着严重的诉讼。\n\n事故就是对软件创作者的教训：\n软件质量问题很重要，不管是嵌入在汽车引擎中的，工厂里的机械手臂中的，还是嵌入在医院的治疗设备中的，这些应用必须做到万无一失，低劣部署的代码可以杀人。",
            "name": "15.3.4.2 一个极端的例子与警示"
        }
    },
    {
        "start_id": "S15.3.5",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.5",
            "content": "政府或企业雇用一个较大的软件开发商或咨询公司来分析需求，然后设计和创建一个基于软件的“系统”，用以支撑某个重大的活动。系统可能支持主要的企业功能（例如，养老金管理)，或某项政府职能（例如，卫生保健管理或国土安全）。\n工作始于双方良好的意愿，但是到了系统交付时，情况已变得糟糕，系统延期，未能提供预期的特性和功能，而且易出错，不能得到客户的认可，接下来就要打官司。在大多数情况下，顾客称开发商马虎大意（已带到了软件实践中），因此拒绝付款。而开发商则常常声称，顾客一再改变其要求，并在其他方面破坏了开发伙伴关系。无论是哪一种情况，交付系统的质量都会有问题。",
            "name": "15.3.5 疏忽和责任"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.3.6",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.6",
            "name": "15.3.6 质量和安全"
        }
    },
    {
        "start_id": "S15.3.6",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.6",
            "name": "15.3.6 质量和安全"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.3.7",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.7",
            "name": "15.3.7 管理活动的影响"
        }
    },
    {
        "start_id": "SS15.3.6.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.6.1",
            "content": "随着基于Web的系统和移动系统重要性的增加，应用的安全性已变得日益重要。简而言之，没有表现出高质量的软件比较容易被攻击。因此，低质量的软件会间接地增加安全风险，随之而来的是费用和问题。软件安全与质量息息相关。必须一开始就在设计、构建、测试、编码阶段以及在整个软件生命周期（过程）中考虑安全性、可靠性、可得性、可信性。即使是已认识到软件安全问题的人也会主要关注生命周期的晚些阶段。越早发现软件问题越好。",
            "name": "15.3.6.1 质量和安全的关系"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.3.6.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.6.2",
            "content": "有两种类型的软件问题，一种是隐藏的错误，这是实现的问题。另一种是软件缺陷，这是设计中的构建问题。人们对错误关注太多，却对缺陷关注不够。\n要构造安全的系统，就必须注重质量，并必须在设计时开始关注。",
            "name": "15.3.6.2 两种类型的软件问题"
        }
    },
    {
        "start_id": "SS15.3.7.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.7.1",
            "content": "软件质量受管理决定的影响往往和受技术决定的影响是一样的。即使最好的软件工程实践也能被糟糕的商业决策和有问题的项目管理活动破坏。\nMeskimen定律能最好地概括软件质量面临的困境：“从来没有时间做好，但总是有时间再做一遍！”\n应选择主动做好，而不是被动重做。",
            "name": "15.3.7.1 质量受到管理活动影响"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.3.7.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.7.2",
            "content": "每个项目任务开始时，项目领导人都要作决策，这些决策可能对产品质量有重大影响，决策包括：1.估算决策。2.进度安排决策。3.面向风险的决策。",
            "name": "15.3.7.2 三种决策"
        }
    },
    {
        "start_id": "P15.3.7.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.7.2.1",
            "content": "在确定交付日期和制定总预算之前，给软件团队提供项目估算数据是很少见的。反而是团队进行了“健康检查”，以确保交付日期和里程碑是合理的。在许多情况下,存在着巨大的上市时间压力，迫使软件团队接受不现实的交付日期。结果，由于抄了近路,可以获得更高质量软件的活动被忽略掉了，产品质量受到损害。如果交付日期是不合理的，那么坚持立场就是重要的。这就解释了为什么你需要更多的时间，或者也可以建议在指定的时间交付一个（高质量的）功能子集。",
            "name": "15.3.7.2.1 估算决策"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P15.3.7.2.2",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P15.3.7.2.2",
            "content": "一旦建立了软件项目时间表（第25章)，就会按照依赖性安排任务的先后顺序。例如，由于A构件依赖于B、C和D构件中的处理，因此直到B、C和D构件完全测试后，才能安排A构件进行测试。项目计划将反映这一点。但是，如果时间很紧，为了做进一步的关键测试，A必须是可用的。在这种情况下，可能会决定在没有其附属构件(这些附属构件的运行要稍落后于时间表）的情况下测试A,这样对于交付前必须完成的其他测试，就可以使用A了，毕竟，期限正在逼近。因此，A可能有隐藏的缺陷，只有晚些时候才能发现，质量会受到影响。",
            "name": "15.3.7.2.2 进度安排决策"
        }
    },
    {
        "start_id": "P15.3.7.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.7.2.2",
            "content": "一旦建立了软件项目时间表（第25章)，就会按照依赖性安排任务的先后顺序。例如，由于A构件依赖于B、C和D构件中的处理，因此直到B、C和D构件完全测试后，才能安排A构件进行测试。项目计划将反映这一点。但是，如果时间很紧，为了做进一步的关键测试，A必须是可用的。在这种情况下，可能会决定在没有其附属构件(这些附属构件的运行要稍落后于时间表）的情况下测试A,这样对于交付前必须完成的其他测试，就可以使用A了，毕竟，期限正在逼近。因此，A可能有隐藏的缺陷，只有晚些时候才能发现，质量会受到影响。",
            "name": "15.3.7.2.2 进度安排决策"
        },
        "relation": "Next_P",
        "relation_properties": {},
        "end_id": "P15.3.7.2.3",
        "end_labels": [
            "Problem"
        ],
        "end_properties": {
            "id": "P15.3.7.2.3",
            "content": "风险管理（第26章）是成功软件项目的关键特性之一。必须知道哪里可能会出问题，并建立一项如果确实出问题时的应急计划。太多的软件团队喜欢盲目乐观，在什么都不会出问题的假设下建立开发计划。更糟的是，他们没有办法处理真的出了差错的事情。结果，当风险变成现实后，便会一片混乱，并且随着疯狂程度的上升，质量水平必然下降。",
            "name": "15.3.7.2.3 面对风险的决策"
        }
    },
    {
        "start_id": "T15.4",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.4",
            "name": "15.4 实现软件质量"
        },
        "relation": "Next_TP",
        "relation_properties": {},
        "end_id": "T15.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.5",
            "content": "软件正在融入我们日常生活的各个方面，人们对于软件系统质量的关注也逐渐多起来。但是很难给出软件质量的一个全面描述。在这一章，质量被定义为一个有效的软件过程，用来在一定程度上创造有用的产品，为那些生产者和使用者提供适度的价值。\n这些年来，提出了各种各样的软件质量度量和因素，都试图定义一组属性，如果可以实现，那么我们将实现较高的软件质量。McCall的质量因素和ISO 25010的质量因素建立了很多特性（如可靠性、可用性、维护性、功能性和可移植性）作为质量存在的指标。\n每个软件组织都面临软件质量困境。从本质上说，每个人都希望建立高质量的系统，但生产“完美”软件所需的时间和工作量在市场主导的世界里根本无法达到。这样问题就转化为，我们是否应该生产“足够好”的软件？虽然许多公司是这样做的，但是这样做有很大的负面影响，必须加以考虑。\n不管选择什么方法，质量都是有成本的，质量成本可以从预防、评估和失效方面来说。预防成本包括所有将预防缺陷放在首位的软件工程活动。评估成本是与评估软件工作产品以确定其质量的活动有关的成本。失效成本包括失效的内部代价和低劣质量造成的外部影响。\n软件质量是通过软件工程方法、扎实的管理措施和全面质量控制的应用而实现的一一所有这些都是靠软件质量保证基础设施支持的。",
            "name": "15.5 小结"
        }
    },
    {
        "start_id": "S15.4.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.4.1",
            "content": "良好的软件质量不会自己出现，它是良好的项目管理和扎实的软件工程实践的结果。四大管理和实践活动可以帮助软件团队实现高质量的软件。",
            "name": "15.4.1 实现高质量软件的四大管理和实践活动"
        },
        "relation": "Next_ST",
        "relation_properties": {},
        "end_id": "S15.4.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.4.2",
            "content": "缺陷预测是识别可能存在质量问题的软件构件的重要方式。缺陷预测模型使用统计技术来检查软件度量和包含已知软件缺陷的软件构件的组合之间的关系。它们是软件开发人员快速识别容易出错的类的高效方法。这可以减少成本和开发时间。\n机器学习是人工智能（AI)技术的一种应用，它为系统提供了无须显式编程就能从经验中学习和改进的能力。换句话说，机器学习关注开发能够访问数据并利用数据进行自学的计算机程序。机器学习技术可以用来自动化发现软件度量和缺陷构件之间的预测关系。机器学习系统处理大量的数据集，这些数据集包含有缺陷的和无缺陷的软件构件的代表性度量组合。这些数据用于优化分类算法。一旦系统通过这种类型的训练构建了一个预测模型，它就可以基于未来软件产品的相关数据进行质量评估和缺陷预测。构建这种类型的分类器是现代数据科学家工作的重要部分。",
            "name": "15.4.2 机器学习和缺陷预测"
        }
    },
    {
        "start_id": "SS15.4.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.4.1.1",
            "content": "软件工程方法。如果希望建立高质量的软件，必须理解要解决的问题，还须能够创造一个符合问题的设计，该设计同时还要有一些性质，即这些性质可以产生具有质量维度和因素的软件。",
            "name": "15.4.1.1 软件工程方法 "
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.4.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.4.1.2",
            "content": "项目管理技术：\n(1) 项目经理使用估算以确认交付日期是可以达到的；\n(2) 进度依赖关系明确，团队能够抵抗走捷径的诱惑；\n(3) 进行了风险规划，这样出了问题就不会引起混乱，软件质量将受到积极的影响。",
            "name": "15.4.1.2 项目管理技术"
        }
    },
    {
        "start_id": "SS15.4.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.4.1.2",
            "content": "项目管理技术：\n(1) 项目经理使用估算以确认交付日期是可以达到的；\n(2) 进度依赖关系明确，团队能够抵抗走捷径的诱惑；\n(3) 进行了风险规划，这样出了问题就不会引起混乱，软件质量将受到积极的影响。",
            "name": "15.4.1.2 项目管理技术"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.4.1.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.4.1.3",
            "content": "质量控制。其包括一套软件工程活动，以帮助确保每个工作产品符合其质量目标：\n1.评审模型以确保它们是完整的和一致的。\n2.检查代码，以便在测试开始前发现和纠正错误。\n3.应用一系列的测试步骤以发现处理逻辑、数据处理以及接口通信中的错误。\n4.当任何一个工作成果不符合质量目标时，应结合测量和反馈使软件团队调整软件过程。",
            "name": "15.4.1.3 质量控制"
        }
    },
    {
        "start_id": "SS15.4.1.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.4.1.3",
            "content": "质量控制。其包括一套软件工程活动，以帮助确保每个工作产品符合其质量目标：\n1.评审模型以确保它们是完整的和一致的。\n2.检查代码，以便在测试开始前发现和纠正错误。\n3.应用一系列的测试步骤以发现处理逻辑、数据处理以及接口通信中的错误。\n4.当任何一个工作成果不符合质量目标时，应结合测量和反馈使软件团队调整软件过程。",
            "name": "15.4.1.3 质量控制"
        },
        "relation": "Next_SS",
        "relation_properties": {},
        "end_id": "SS15.4.1.4",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.4.1.4",
            "content": "质量保证。其包含一组审核和报告功能，用以评估质量控制活动的有效性和完整性。",
            "name": "15.4.1.4 质量保证"
        }
    },
    {
        "start_id": "T1.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.1",
            "name": "1.1 软件的本质"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH1",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH1",
            "name": "第1章 软件与软件工程"
        }
    },
    {
        "start_id": "S1.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.1.1",
            "name": "1.1.1 定义软件"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.1",
            "name": "1.1 软件的本质"
        }
    },
    {
        "start_id": "SS1.1.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.1.1",
            "content": "①软件是一种产品：扮演着信息转换的角色；产生、管理、查询、修改、显示、传递信息。\n②软件是生产产品的载体，提供以下基础平台：计算机控制 (e.g., 操作系统)信息通信 (e.g., 网络软件)应用软件开发 (e.g., 软件工具)",
            "name": "1.1.1.1 软件的双重角色"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.1",
            "name": "1.1.1 定义软件"
        }
    },
    {
        "start_id": "SS1.1.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.1.2",
            "content": "软件是一组要素的集合：程序、文档、数据。\n\n①程序的正常运行离不开必要的文档和数据：\n②文档是开发、使用和维护程序所需要的图文资料；\n③数据是使程序能够适当地处理信息的数据结构（包括数据库、一些配置文件等）。",
            "name": "1.1.1.2 什么是软件"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.1",
            "name": "1.1.1 定义软件"
        }
    },
    {
        "start_id": "SS1.1.1.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.1.3",
            "content": "软件是逻辑的而非物理的系统元素。因此，软件和硬件具有完全不同的特性：软件不会“磨损”。",
            "name": "1.1.1.3 软件与硬件具有不同的特性"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.1",
            "name": "1.1.1 定义软件"
        }
    },
    {
        "start_id": "P1.1.1.3.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.1.3.1",
            "content": "软件是设计开发的，而不是传统意义上生产制造的：硬件和软件可通过优秀的设计获得高品质产品，然而硬件在制造阶段可能会引入质量问题，这在软件中并不存在（或者易于纠正）；\n软件产品成本主要在于开发设计，硬件的成本在批量生产时仍然很高。",
            "name": "1.1.1.3.1 软件是设计开发出的产品"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.1.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.1.3",
            "content": "软件是逻辑的而非物理的系统元素。因此，软件和硬件具有完全不同的特性：软件不会“磨损”。",
            "name": "1.1.1.3 软件与硬件具有不同的特性"
        }
    },
    {
        "start_id": "P1.1.1.3.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.1.3.2",
            "content": "①磨损的硬件部件可以用备用部件替换，而软件却不存在备用部件。\n②每个软件的缺陷都暗示了设计的缺陷或者在从设计转化到机器可执行代码（实现）的过程中产生的错误。\n③软件维护要应对变更请求，比硬件维护更为复杂。\n④不断的变更是软件退化的根本原因。",
            "name": "1.1.1.3.2 软件不会“磨损”"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.1.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.1.3",
            "content": "软件是逻辑的而非物理的系统元素。因此，软件和硬件具有完全不同的特性：软件不会“磨损”。",
            "name": "1.1.1.3 软件与硬件具有不同的特性"
        }
    },
    {
        "start_id": "P1.1.1.3.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.1.3.3",
            "content": "工程学科的发展将产生一系列标准的设计器件。可复用构件的使用可以使得工程师专心于设计中真正创新的部分。在硬件设计中，构件复用是工程进程中通用的方法 (例如，标准螺丝钉、可订购的集成电路)。\n\n现代可复用软件构件封装了数据和对数据的处理。例如，图形窗口、下拉菜单和各种交互机制。",
            "name": "1.1.1.3.3 基于构件的构造模式"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.1.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.1.3",
            "content": "软件是逻辑的而非物理的系统元素。因此，软件和硬件具有完全不同的特性：软件不会“磨损”。",
            "name": "1.1.1.3 软件与硬件具有不同的特性"
        }
    },
    {
        "start_id": "S1.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.1.2",
            "name": "1.1.2 软件应用领域"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.1",
            "name": "1.1 软件的本质"
        }
    },
    {
        "start_id": "SS1.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.2.1",
            "name": "1.1.2.1 计算机软件的7类应用"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.2",
            "name": "1.1.2 软件应用领域"
        }
    },
    {
        "start_id": "P1.1.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.1",
            "content": "系统软件是一整套服务于其他程序的程序：\n①某些系统软件（例如编译器、编辑器、文件管理软件）处理复杂但确定的信息结构。\n②另一些系统应用程序（例如操作系统构件、驱动程序、网络软件、远程通信处理器）主要处理的是不确定的数据。\n\n系统软件多具有以下特点：\n①和计算机硬件大量交互；\n②多用户大量使用；\n③需要调度、资源共享和复杂进程管理的同步操作；\n④复杂的数据结构以及多种外部接口。",
            "name": "1.1.2.1.1 系统软件"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.2.1",
            "name": "1.1.2.1 计算机软件的7类应用"
        }
    },
    {
        "start_id": "P1.1.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.2",
            "content": "应用软件是解决特定业务需要的独立应用程序。这类应用软件处理商务或技术数据，以协助业务操作或协助做出管理/技术决策。",
            "name": "1.1.2.1.2 应用软件"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.2.1",
            "name": "1.1.2.1 计算机软件的7类应用"
        }
    },
    {
        "start_id": "P1.1.2.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.3",
            "content": "工程／科学软件：这类软件通常带着“数值计算”算法的特征，工程和科学软件涵盖了广泛的应用领域，天文学到火山学，从自动压力分析到轨道动力学，从计算机辅助设计到分子生物学，从遗传分\n析到气象学。",
            "name": "1.1.2.1.3 工程/科学软件"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.2.1",
            "name": "1.1.2.1 计算机软件的7类应用"
        }
    },
    {
        "start_id": "P1.1.2.1.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.4",
            "content": "嵌入式软件存在于某个产品或者系统中，可实现和控制面向最终用户和系统本身的特性和功能。\n①嵌入式软件可以执行有限的和内部的功能（例如微波炉的按键控制）\n②可以提供重要的功能和控制能力（例如汽车中的燃油控制、仪表板显示、刹车系统等汽车电子功能）。",
            "name": "1.1.2.1.4 嵌入式软件"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.2.1",
            "name": "1.1.2.1 计算机软件的7类应用"
        }
    },
    {
        "start_id": "P1.1.2.1.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.5",
            "content": "产品线软件包括可复用的构件，并为多个不同用户的使用提供特定功能。其关注有限的及内部的市场（例如库存控制产品）或者大众消费品市场。\n软件产品线都使用相同的底层应用软件和数据体系结构来开发，并使用可在整个产品线中进行复用的一组软件构件来实现。",
            "name": "1.1.2.1.5 产品线软件"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.2.1",
            "name": "1.1.2.1 计算机软件的7类应用"
        }
    },
    {
        "start_id": "P1.1.2.1.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.6",
            "content": "Web/移动App：以网络为中心，其概念涵盖了宽泛的应用软件产品，包括基于浏览器的App、云计算、基于服务的计算和安装在移动设备上的软件。\n最简单可以是一组超文本链接文件，仅仅用文本和有限的图形表达信息。随着Web 2.0的出现，网络应用正在发展为复杂的计算环境：比如，网游、网络社区应用。",
            "name": "1.1.2.1.6 Web/移动app"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.2.1",
            "name": "1.1.2.1 计算机软件的7类应用"
        }
    },
    {
        "start_id": "P1.1.2.1.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.1.2.1.7",
            "content": "人工智能软件。利用启发式方法（非数值算法）解决常规计算和直接分析无法解决的复杂问题。\n这个领域的应用程序包括机器人、决策系统、模式识别（图像和语音）机器学习、定理证明和博弈等。",
            "name": "1.1.2.1.7 人工智能软件"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.1.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.1.2.1",
            "name": "1.1.2.1 计算机软件的7类应用"
        }
    },
    {
        "start_id": "S1.1.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.1.3",
            "name": "1.1.3 遗留软件"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.1",
            "name": "1.1 软件的本质"
        }
    },
    {
        "start_id": "SS1.1.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.3.1",
            "content": "遗留软件是那些已经过时但仍在运行的软件，它们：①开发年代久远；②一直在使用；③在使用过程中被不断地修改以满足商业需要和计算平台的变化；④可能仍然支持着核心业务。\n它们通常难以维护和升级，但对业务至关重要，因此需要特别的关注和管理。\n\n“遗留软件系统……他们在几十年前诞生，他们不断被修改以满足商业需要和计算平台的变化。这类系统的繁衍使得大型机构十分头痛，因为他们的维护代价高昂且系统演化风险高。”——Dayani-Fard",
            "name": "1.1.3.1 遗留软件的定义"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.3",
            "name": "1.1.3 遗留软件"
        }
    },
    {
        "start_id": "SS1.1.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.3.2",
            "content": "遗留软件通常具有数不清的问题：\n设计难以扩展；\n代码令人费解；\n文档混乱，可能缺失；\n变更管理混乱；\n测试记录未归档；\n……",
            "name": "1.1.3.2 遗留软件的“质量差”问题"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.3",
            "name": "1.1.3 遗留软件"
        }
    },
    {
        "start_id": "SS1.1.3.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.1.3.3",
            "content": "由于遗留软件常常支撑着核心业务，对其变更必须非常谨慎。如果它能够满足用户的需求并可靠运行，则不要修改它。\n然而，随着时间的推移，遗留系统经常会出于下述原因而发生演化：\n①进行适应性变化，以满足新的计算环境或者技术的需要；（满足新需求）\n②根据新的业务需求进行升级；（升级）\n③扩展以及具有与更多现代系统或数据库的协作能力；（扩展）\n④改建以适应多样化的网络环境；（改建）",
            "name": "1.1.3.3 遗留软件为什么要演化?"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.1.3",
            "name": "1.1.3 遗留软件"
        }
    },
    {
        "start_id": "T1.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.2",
            "name": "1.2 定义软件工程学科"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH1",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH1",
            "name": "第1章 软件与软件工程"
        }
    },
    {
        "start_id": "S1.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.2.1",
            "content": "①软件工程：将系统化的、规范化的、可量化的方法应用于软件的开发、运行和维护，即将工程化的方法应用于软件；  ——IEEE [IEEE93a]\n②软件工程：建立和使用一套合理的工程原则，从而经济地获得可靠的、可在实际机器上高效运行的软件。   ——Fritz Bauer [Nau69]",
            "name": "1.2.1 软件工程的定义"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.2",
            "name": "1.2 定义软件工程学科"
        }
    },
    {
        "start_id": "S1.2.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.2.2",
            "content": "软件工程是一种层次化技术。任何工程方法（包括软件工程）必须构建在质量承诺的基础之上。你也许听说过全面质量管理（TQM）、六西格玛和类似的理念促进了持续不断的过程改进文化，正是这种文化最终引导人们开发出更有效地软件工程方法。支撑软件工程的根基在于【质量关注点】。",
            "name": "1.2.2 软件工程是一种层次化技术"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.2",
            "name": "1.2 定义软件工程学科"
        }
    },
    {
        "start_id": "SS1.2.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.2.2.1",
            "name": "1.2.2.1 软件工程层次"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.2.2",
            "content": "软件工程是一种层次化技术。任何工程方法（包括软件工程）必须构建在质量承诺的基础之上。你也许听说过全面质量管理（TQM）、六西格玛和类似的理念促进了持续不断的过程改进文化，正是这种文化最终引导人们开发出更有效地软件工程方法。支撑软件工程的根基在于【质量关注点】。",
            "name": "1.2.2 软件工程是一种层次化技术"
        }
    },
    {
        "start_id": "P1.2.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.2.2.1.1",
            "content": "软件工程的基础是【过程】层。过程定义了一个框架，给出了开发步骤，构建该框架是有效实施软件工程技术必不可少的。\n软件过程将各个技术层次结合在一起，使得合理、及时地开发计算机软件成为可能。软件过程构成了软件项目管理控制的基础，建立了工作环境以便应用技术方法、提交工作产品（模型、文档、数据、报告、表格等）、建立里程碑、保证质量以及正确地管理变更。",
            "name": "1.2.2.1.1 过程层"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.2.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.2.2.1",
            "name": "1.2.2.1 软件工程层次"
        }
    },
    {
        "start_id": "P1.2.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.2.2.1.2",
            "content": "软件工程【方法】为构建软件提供技术上的解决方法（“如何做”）。\n方法覆盖面很广，包括沟通、需求分析、设计建模、编程、测试和技术支持。",
            "name": "1.2.2.1.2 方法层"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.2.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.2.2.1",
            "name": "1.2.2.1 软件工程层次"
        }
    },
    {
        "start_id": "P1.2.2.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.2.2.1.3",
            "content": "软件工程【工具】为过程和方法提供自动化或半自动化的支持。\n这些工具可以集成起来，使得一个工具产生的信息可被另外一个工具使用，这样就建立了软件开发的支撑系统。成为“计算机辅助软件工程”。",
            "name": "1.2.2.1.3 工具层"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.2.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.2.2.1",
            "name": "1.2.2.1 软件工程层次"
        }
    },
    {
        "start_id": "T1.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.3",
            "content": "软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。\n①活动(activity)主要实现宽泛的目标（如与利益相关者进行沟通)，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系。\n②动作(action，如体系结构设计）包含主要工作产品(如体系结构设计模型)生产过程中的一系列任务。\n③任务(task)关注小而明确的目标，能够产生实际产品（如构建一个单元测试)。\n\n在软件工程领域，过程不是对如何构建计算机软件的严格规定，而是一种具有可适应性的调整方法，以便于工作人员(软件团队）可以挑选适合的工作动作和任务集合。\n其目标通常是【及时、高质量地交付软件】，以满足软件项目资助方和最终用户的需求。\n \n当开发产品或构建系统时，遵循一系列可预测的步骤（即路线图）是非常重要的，它有助于及时交付高质量的产品。\n软件开发中所遵循的路线图就称为“软件过程”。",
            "name": "1.3 软件过程"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH1",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH1",
            "name": "第1章 软件与软件工程"
        }
    },
    {
        "start_id": "S1.3.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.3.1",
            "content": "框架是事物的基本组织、结构。\n\n过程框架定义了若干个框架活动，为实现完整的软件工程奠定了基础的框架：\n①定义了若干小的框架活动，为完整的软件开发过程建立了基础；\n②每一个活动由一组软件工程动作组成：\n③每一个动作都包括一系列相互关联的可考核的任务。（每一个任务完成一个动作定义的一部分工作。）",
            "name": "1.3.1 过程框架"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.3",
            "content": "软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。\n①活动(activity)主要实现宽泛的目标（如与利益相关者进行沟通)，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系。\n②动作(action，如体系结构设计）包含主要工作产品(如体系结构设计模型)生产过程中的一系列任务。\n③任务(task)关注小而明确的目标，能够产生实际产品（如构建一个单元测试)。\n\n在软件工程领域，过程不是对如何构建计算机软件的严格规定，而是一种具有可适应性的调整方法，以便于工作人员(软件团队）可以挑选适合的工作动作和任务集合。\n其目标通常是【及时、高质量地交付软件】，以满足软件项目资助方和最终用户的需求。\n \n当开发产品或构建系统时，遵循一系列可预测的步骤（即路线图）是非常重要的，它有助于及时交付高质量的产品。\n软件开发中所遵循的路线图就称为“软件过程”。",
            "name": "1.3 软件过程"
        }
    },
    {
        "start_id": "SS1.3.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.3.1.1",
            "content": "通用过程框架：适用于绝大多数软件项目，包含五个最基本的框架活动：沟通、策划、建模、构建、部署。",
            "name": "1.3.1.1 通用的5个框架活动"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.3.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.3.1",
            "content": "框架是事物的基本组织、结构。\n\n过程框架定义了若干个框架活动，为实现完整的软件工程奠定了基础的框架：\n①定义了若干小的框架活动，为完整的软件开发过程建立了基础；\n②每一个活动由一组软件工程动作组成：\n③每一个动作都包括一系列相互关联的可考核的任务。（每一个任务完成一个动作定义的一部分工作。）",
            "name": "1.3.1 过程框架"
        }
    },
    {
        "start_id": "P1.3.1.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.1",
            "content": "在技术工作开始之前，和客户（及其他利益相关者）的沟通与协作是极其重要\n的，其目的是理解利益相关者的项目目标，并收集需求以定义软件特性和功能。",
            "name": "1.3.1.1.1 沟通"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.1.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.1.1",
            "content": "通用过程框架：适用于绝大多数软件项目，包含五个最基本的框架活动：沟通、策划、建模、构建、部署。",
            "name": "1.3.1.1 通用的5个框架活动"
        }
    },
    {
        "start_id": "P1.3.1.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.2",
            "content": "如果有地图，任何复杂的旅程都可以变得简单。软件项目好比是一个复杂的旅程，策划活动就是创建一个\"地图\"，以指导团队的项目旅程，这个地图称为软件项目计划，它定义和描述了软件工程工作，包括需要执行的技术任务、可能的风险、资源需求、工作产品和工作进度计划。",
            "name": "1.3.1.1.2 策划"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.1.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.1.1",
            "content": "通用过程框架：适用于绝大多数软件项目，包含五个最基本的框架活动：沟通、策划、建模、构建、部署。",
            "name": "1.3.1.1 通用的5个框架活动"
        }
    },
    {
        "start_id": "P1.3.1.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.3",
            "content": "无论你是庭园设计师、桥梁建造者、航空工程师、木匠还是建筑师，每天的工作都离不开模型。你会画一张草图来辅助理解整个项目大的构想——体系结构、不同的构件如何结合，以及其他一些特性。如果需要，可以把草图不断细化，以便更好地理解问题并找到解决方案。软件工程师也是如此，需要利用模型来更好地理解软件需求，并完成符合这些需求的软件设计。",
            "name": "1.3.1.1.3 建模"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.1.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.1.1",
            "content": "通用过程框架：适用于绝大多数软件项目，包含五个最基本的框架活动：沟通、策划、建模、构建、部署。",
            "name": "1.3.1.1 通用的5个框架活动"
        }
    },
    {
        "start_id": "P1.3.1.1.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.4",
            "content": "必须对所做的设计进行构建，包括编码（手写的或者自动生成的）和测试，后者用于发现编码中的错误。",
            "name": "1.3.1.1.4 构建"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.1.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.1.1",
            "content": "通用过程框架：适用于绝大多数软件项目，包含五个最基本的框架活动：沟通、策划、建模、构建、部署。",
            "name": "1.3.1.1 通用的5个框架活动"
        }
    },
    {
        "start_id": "P1.3.1.1.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.1.1.5",
            "content": "软件（全部或者部分增量）交付给用户，用户对其进行评测并基于评测给出反馈意见。",
            "name": "1.3.1.1.5 部署"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.1.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.1.1",
            "content": "通用过程框架：适用于绝大多数软件项目，包含五个最基本的框架活动：沟通、策划、建模、构建、部署。",
            "name": "1.3.1.1 通用的5个框架活动"
        }
    },
    {
        "start_id": "S1.3.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.3.2",
            "content": "软件过程框架活动由很多普适性活动来补充实现。通常这些普适性活动贯穿软件项目始终，以帮助软件团队管理和控制项目进度、质量、变更和风险。",
            "name": "1.3.2 普适性活动"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.3",
            "content": "软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。\n①活动(activity)主要实现宽泛的目标（如与利益相关者进行沟通)，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系。\n②动作(action，如体系结构设计）包含主要工作产品(如体系结构设计模型)生产过程中的一系列任务。\n③任务(task)关注小而明确的目标，能够产生实际产品（如构建一个单元测试)。\n\n在软件工程领域，过程不是对如何构建计算机软件的严格规定，而是一种具有可适应性的调整方法，以便于工作人员(软件团队）可以挑选适合的工作动作和任务集合。\n其目标通常是【及时、高质量地交付软件】，以满足软件项目资助方和最终用户的需求。\n \n当开发产品或构建系统时，遵循一系列可预测的步骤（即路线图）是非常重要的，它有助于及时交付高质量的产品。\n软件开发中所遵循的路线图就称为“软件过程”。",
            "name": "1.3 软件过程"
        }
    },
    {
        "start_id": "SS1.3.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.3.2",
            "content": "软件过程框架活动由很多普适性活动来补充实现。通常这些普适性活动贯穿软件项目始终，以帮助软件团队管理和控制项目进度、质量、变更和风险。",
            "name": "1.3.2 普适性活动"
        }
    },
    {
        "start_id": "P1.3.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.1",
            "content": "项目组根据计划来评估项目进度，并且采取必要的措施来保证项目按进度计划进行。",
            "name": "1.3.2.1.1 软件项目跟踪和控制"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        }
    },
    {
        "start_id": "P1.3.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.2",
            "content": "对可能影响项目成果或者产品质量的风险进行评估。",
            "name": "1.3.2.1.2 风险管理"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        }
    },
    {
        "start_id": "P1.3.2.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.3",
            "content": "确定和执行保证软件质量的活动。",
            "name": "1.3.2.1.3 软件质量保证"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        }
    },
    {
        "start_id": "P1.3.2.1.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.4",
            "content": "评估软件工程产品，尽量在传播到下一个活动之前发现错误并清除。",
            "name": "1.3.2.1.4 技术评审"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        }
    },
    {
        "start_id": "P1.3.2.1.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.5",
            "content": "定义和收集过程、项目以及产品的度量，以帮助团队在发布软件时满足利益相关者的要求。同时，测量还可与其他框架活动和普适性活动配合使用。",
            "name": "1.3.2.1.5 测量"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        }
    },
    {
        "start_id": "P1.3.2.1.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.6",
            "content": "在整个软件过程中管理变更所带来的影响。",
            "name": "1.3.2.1.6 软件配置管理"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        }
    },
    {
        "start_id": "P1.3.2.1.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.7",
            "content": "定义工作产品（包括软件构件）复用的标准，并且建立构件复用机制。",
            "name": "1.3.2.1.7 可复用性管理"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        }
    },
    {
        "start_id": "P1.3.2.1.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.3.2.1.8",
            "content": "包括生成产品（如建模、文档、日志、表格和列表等）所必需的活动。",
            "name": "1.3.2.1.8 工作产品的准备和生产"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.3.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.3.2.1",
            "name": "1.3.2.1 典型的普适性活动"
        }
    },
    {
        "start_id": "S1.3.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.3.3",
            "content": "软件工程过程并不是教条的法则，不要求软件团队机械地执行；而应该是灵活可适应的（根据软件所需解决的问题、项目特点、开发团队和组织文化等进行适应性调整）。因此，不同项目所采用的项目过程可能有很大不同。\n\n这些不同主要体现在以下几个方面：\n1.活动、动作和任务的总体流程以及相互依赖关系。\n2.在每一个框架活动中，动作和任务细化的程度。\n3.工作产品的定义和要求的程度。\n4.质量保证活动应用的方式。\n5.项目跟踪和控制活动应用的方式。\n6.过程描述的详细程度和严谨程度。\n7.客户和利益相关者对项目的参与程度。\n8.软件团队所赋予的自主权。\n9.团队组织和角色的明确程度。",
            "name": "1.3.3 过程的适应性调整"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.3",
            "content": "软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。\n①活动(activity)主要实现宽泛的目标（如与利益相关者进行沟通)，与应用领域、项目大小、结果复杂性或者实施软件工程的重要程度没有直接关系。\n②动作(action，如体系结构设计）包含主要工作产品(如体系结构设计模型)生产过程中的一系列任务。\n③任务(task)关注小而明确的目标，能够产生实际产品（如构建一个单元测试)。\n\n在软件工程领域，过程不是对如何构建计算机软件的严格规定，而是一种具有可适应性的调整方法，以便于工作人员(软件团队）可以挑选适合的工作动作和任务集合。\n其目标通常是【及时、高质量地交付软件】，以满足软件项目资助方和最终用户的需求。\n \n当开发产品或构建系统时，遵循一系列可预测的步骤（即路线图）是非常重要的，它有助于及时交付高质量的产品。\n软件开发中所遵循的路线图就称为“软件过程”。",
            "name": "1.3 软件过程"
        }
    },
    {
        "start_id": "T1.4",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.4",
            "name": "1.4 软件工程实践"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH1",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH1",
            "name": "第1章 软件与软件工程"
        }
    },
    {
        "start_id": "S1.4.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.4.1",
            "name": "1.4.1 软件工程实践的精髓"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.4",
            "name": "1.4 软件工程实践"
        }
    },
    {
        "start_id": "SS1.4.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.4.1.1",
            "content": "虽然难于承认，但我们遇到的问题很多都源于我们的傲慢。我们只听了几秒钟就断言“好，我懂了，让我们开始解决这个问题吧”。不幸的是，理解一个问题不总是那么容易，需要花一点时间回答几个简单问题：\n①谁将从问题的解决中获益？也就是说，谁是利益相关者？\n②有哪些是未知的？哪些数据、功能、特征和行为是解决问题必需的？\n③问题可以划分吗？是否可以描述为更小、更容易理解的问题？\n④问题可以图形化描述吗？可以建立分析模型吗？",
            "name": "1.4.1.1 理解问题"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.4.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.4.1",
            "name": "1.4.1 软件工程实践的精髓"
        }
    },
    {
        "start_id": "SS1.4.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.4.1.2",
            "content": "现在你理解了要解决的问题（或者你这样认为），并迫不及待地开始编码。在编码之前，稍稍慢下来做一点点设计：\n①以前曾经见过类似问题吗？在潜在的解决方案中，是否可以识别一些模式？\n②是否已经有软件实现了所需要的数据、功能、特征和行为？\n③类似问题是否解决过？如果是，解决方案所包含元素是否可以复用？\n④可以定义子问题吗？如果可以，子问题是否已有解决方案？\n⑤能用一种可以快速实现的方式来描述解决方案吗？能构建出设计模型吗？",
            "name": "1.4.1.2 策划解决方案"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.4.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.4.1",
            "name": "1.4.1 软件工程实践的精髓"
        }
    },
    {
        "start_id": "SS1.4.1.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.4.1.3",
            "content": "前面所创建的设计勾画了所要构建的系统的路线图。也许存在没有想到的路径，也可能在实施过程中会发现更好的解决路径，但是这个计划可以保证在实施过程中不至于迷失方向。需要考虑的问题是：\n①解决方案和计划一致吗？\n②源码是否可追溯到设计模型？\n③解决方案的每个组成部分是否可以证明正确？\n④设计和代码是否经过评审？\n⑤或者更好的算法是否经过正确性证明？",
            "name": "1.4.1.3 实施计划"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.4.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.4.1",
            "name": "1.4.1 软件工程实践的精髓"
        }
    },
    {
        "start_id": "SS1.4.1.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.4.1.4",
            "content": "你不能保证你的解决方案是最完美的，但是你可以保证设计足够的测试来发现尽可能多的错误。为此，需回答：\n①能否测试解决方案的每个部分？\n②是否实现了合理的测试策略？\n③解决方案是否产生了与所要求的数据、功能、特征和行为一致的结果？\n④是否按照项目共同利益者的需求进行了确认？",
            "name": "1.4.1.4 检查结果"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.4.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.4.1",
            "name": "1.4.1 软件工程实践的精髓"
        }
    },
    {
        "start_id": "S1.4.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.4.2",
            "name": "1.4.2 通用原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.4",
            "name": "1.4 软件工程实践"
        }
    },
    {
        "start_id": "SS1.4.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS1.4.2.1",
            "name": "1.4.2.1 David Hooker的7个关注软件工程整体实践原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S1.4.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S1.4.2",
            "name": "1.4.2 通用原则"
        }
    },
    {
        "start_id": "P1.4.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.1",
            "content": "一个软件系统因能为用户提供价值而具有存在价值，所有的决策都应该基于这个思想。在确定系统需求之前，在关注系统功能之前，在决定硬件平台或者开发过程之前，问问你自己：这确实能为系统增加真正的价值吗？如果答案是不，那就坚决不做。所有的其他原则都以这条原则为基础。",
            "name": "1.4.2.1.1 第一原则：存在价值"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.4.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.2.1",
            "name": "1.4.2.1 David Hooker的7个关注软件工程整体实践原则"
        }
    },
    {
        "start_id": "P1.4.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.2",
            "content": "在软件设计中需要考虑很多因素。所有的设计都应该尽可能简洁，但不是过于简化。这有助于构建更易于理解和易于维护的系统。这并不是说有些特性应该以“简洁”为借口而取消。的确，优雅的设计通常也是简洁的设计，但简洁不意味着“快速和粗糙”。事实上，它经常是经过大量思考和多次工作迭代才达到的，这样做的回报是所得到的软件更易于维护且错误更少。",
            "name": "1.4.2.1.2 第二原则：保持简洁"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.4.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.2.1",
            "name": "1.4.2.1 David Hooker的7个关注软件工程整体实践原则"
        }
    },
    {
        "start_id": "P1.4.2.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.3",
            "content": "在软件设计中需要考虑很多因素。所有的设计都应该尽可能简洁，但不是过于简化。这有助于构建更易于理解和易于维护的系统。这并不是说有些特性应该以“简洁”为借口而取消。的确，优雅的设计通常也是简洁的设计，但简洁不意味着“快速和粗糙”。事实上，它经常是经过大量思考和多次工作迭代才达到的，这样做的回报是所得到的软件更易于维护且错误更少。",
            "name": "1.4.2.1.3 第三原则：保持愿景"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.4.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.2.1",
            "name": "1.4.2.1 David Hooker的7个关注软件工程整体实践原则"
        }
    },
    {
        "start_id": "P1.4.2.1.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.4",
            "content": "在需求说明、设计、编写文档和实现过程中，牢记要让别人理解你所做的事情。对于任何一个软件产品，其工作产品都可能有很多用户。进行需求说明时应时刻想到用户，设计中始终想到实现，编码时考虑到那些要维护和扩展系统的人。一些人可能不得不调试你所编写的代码，这使得他们成了你所编写代码的使用者，尽可能地使他们的工作简单化会大大提升系统的价值。",
            "name": "1.4.2.1.4 第四原则：关注使用者"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.4.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.2.1",
            "name": "1.4.2.1 David Hooker的7个关注软件工程整体实践原则"
        }
    },
    {
        "start_id": "P1.4.2.1.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.5",
            "content": "在现今的计算环境中，需求规格说明随时会改变，硬件平台几个月后就会淘汰，软件生命周期都是以月而不是年来衡量的。然而，真正具有“产业实力”的软件系统必须持久耐用。为了做到这一点，系统必须能适应各种变化，能成功做到这一点的系统都是那些一开始就以这种路线来设计的系统。永远不要把自己的设计局限于一隅，经常问问“如果出现……应该怎样应对”，构建可以解决通用问题的系统，为各种可能的方案做好准备，而不是仅仅针对某一个具体问题。[2]",
            "name": "1.4.2.1.5 第五原则：面向未来"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.4.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.2.1",
            "name": "1.4.2.1 David Hooker的7个关注软件工程整体实践原则"
        }
    },
    {
        "start_id": "P1.4.2.1.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.6",
            "content": "复用既省时又省力。软件系统开发过程中，高水平的复用是一个很难实现的目标。曾有人宣称代码和设计复用是面向对象技术带来的主要好处，然而，这种投入的回报不会自动实现。提前做好复用计划将降低开发费用，并增加可复用构件以及构件化系统的价值。",
            "name": "1.4.2.1.6 第六原则：提前计划复用"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.4.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.2.1",
            "name": "1.4.2.1 David Hooker的7个关注软件工程整体实践原则"
        }
    },
    {
        "start_id": "P1.4.2.1.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P1.4.2.1.7",
            "content": "这最后一条规则可能是最容易被忽略的。在行动之前清晰定位、完整思考通常能产生更好的结果。仔细思考可以提高做好事情的可能性，而且也能获得更多的知识，明确如何把事情再次做好。如果仔细思考过后还是把事情做错了，那么，这就变成了很有价值的经验。思考就是学习和了解本来一无所知的事情，使其成为研究答案的起点。把明确的思想应用在系统中，就产生了价值。使用前6条原则需要认真思考，这将带来巨大的潜在回报。",
            "name": "1.4.2.1.7 第七原则：认真思考"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS1.4.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS1.4.2.1",
            "name": "1.4.2.1 David Hooker的7个关注软件工程整体实践原则"
        }
    },
    {
        "start_id": "T1.5",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.5",
            "name": "1.5 这一切都是如何开始的"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH1",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH1",
            "name": "第1章 软件与软件工程"
        }
    },
    {
        "start_id": "S1.5.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S1.5.1",
            "content": "①每个软件工程项目都来自业务需求：\n②对现有应用程序缺陷的纠正；\n③改变遗留系统以适应新的业务关键；\n④扩展现有应用程序功能和特性；\n⑤开发某种新的产品、服务或系统。\n\n软件项目的初期，业务需求通常是在谈话过程中非正式地表达出来。",
            "name": "1.5.1 软工项目来自业务需求"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T1.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T1.5",
            "name": "1.5 这一切都是如何开始的"
        }
    },
    {
        "start_id": "T1.6",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T1.6",
            "content": "软件是以计算机为基础的系统和产品中的关键部分，并且是世界舞台上最重要的技术之一。在过去的60年里，软件已经从特定问题求解和信息分析的工具发展为独立的产业。如何在有限的时间内利用有限的资金开发高质量的软件，仍然是我们所面对的难题。\n\n软件——程序、数据和描述信息——覆盖了技术和应用的很多领域。遗留软件仍旧给维护人员带来了特殊的挑战。\n软件工程包括【过程、方法和工具】，这些工具使得快速构建高质量的复杂计算机系统成为可能。\n软件过程包括五个框架活动——沟通、策划、建模、构建和部署，这些活动适用于所有的软件项目。\n\n软件工程实践按照一组核心原则，是一项解决问题的活动。随着你对于软件工程的了解越来越多，你会逐渐理解开始一个软件工程项目的时候为什么要考虑这些原则。",
            "name": "1.6 小结"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH1",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH1",
            "name": "第1章 软件与软件工程"
        }
    },
    {
        "start_id": "T3.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.1",
            "name": "3.1 什么是敏捷"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH3",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH3",
            "name": "第3章 敏捷和敏捷过程"
        }
    },
    {
        "start_id": "S3.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.1.1",
            "content": "1.个体与交互胜过过程与工具\n2.可用的软件胜过完备的文档\n3.客户协作胜过合同谈判\n4.响应变化胜过遵循计划",
            "name": "3.1.1 敏捷宣言"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.1",
            "name": "3.1 什么是敏捷"
        }
    },
    {
        "start_id": "S3.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.1.2",
            "name": "3.1.2 敏捷价值观"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.1",
            "name": "3.1 什么是敏捷"
        }
    },
    {
        "start_id": "S3.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.1",
            "content": "不但要促进你团队内部的开发人员之间沟通、还能够促进你的团队和你的project stakeholder之间的沟通。",
            "name": "3.1.2.1 沟通"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.2",
            "name": "3.1.2 敏捷价值观"
        }
    },
    {
        "start_id": "S3.1.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.2",
            "content": "画一两张图表来代替几十甚至几百行的代码，类似这种方法成为简化软件和软件（开发）过程的关键。这一点对开发人员而言非常重要－它简单，容易发现出新的想法，随着你（对软件）的理解的加深，也能够很容易的改进。",
            "name": "3.1.2.2 简单"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.2",
            "name": "3.1.2 敏捷价值观"
        }
    },
    {
        "start_id": "S3.1.2.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.3",
            "content": "Kent Beck在Extreme Programming Explained中有句话讲得非常好：“过度自信是编程的职业病，反馈则是其处方。”通过图表来交流你的想法，你可以快速获得反馈，并能够按照建议行事。",
            "name": "3.1.2.3 反馈"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.2",
            "name": "3.1.2 敏捷价值观"
        }
    },
    {
        "start_id": "S3.1.2.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.4",
            "content": "1、有勇气主动挑战工作，并承担责任。\n2、有勇气只进行简单的设计，并相信它能够满足客户需求。\n3、有勇气编写测试代码，并相信测试代码能够满足需求。\n4、有勇气拥抱变化，积极适应变化，响应客户需求。\n5、有勇气在需求变化时重构代码。\n6、有勇气不断采用新的开发技术或方法，不断改进，以提高用户满意度。\n7、有勇气对自己的阶段工作进行回顾，总结自己错误的行为并及时纠正。\n8、有勇气面对各种困难和风险，鼓励并带领伙伴一起齐心协力、克服困难、渡过难关。\n9、有勇气向客户承诺并达到它。\n10、有勇气对用户说“不”。尊重用户价值，对用户负责，不欺瞒用户。\n11、有勇气挑战权威，表达自己正确的见解并用实践证明。\n12、有勇气接受任何成员的好建议并改进之。",
            "name": "3.1.2.4 勇气"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.2",
            "name": "3.1.2 敏捷价值观"
        }
    },
    {
        "start_id": "S3.1.2.5",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "S3.1.2.5",
            "content": "最优秀的开发人员都拥有谦逊的美德，他们总能认识到自己并不是无所不知的。事实上，无论是开发人员还是客户，甚至所有的 project stakeholder，都有他们自己的专业领域，都能够为项目做出贡献。一个有效的做法是假设参与项目的每一个人都有相同的价值，都应该被尊重。\n",
            "name": "3.1.2.4 尊重（谦逊）"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.2",
            "name": "3.1.2 敏捷价值观"
        }
    },
    {
        "start_id": "S3.1.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.1.3",
            "content": "敏捷开发是一种软件开发方法论，可以应对客户快速变更的需求。它强调以人为核心，采用迭代的方式，循序渐进地开发软件。",
            "name": "3.1.3 敏捷开发"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.1",
            "name": "3.1 什么是敏捷"
        }
    },
    {
        "start_id": "S3.1.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.1.4",
            "name": "3.1.4 敏捷"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.1",
            "name": "3.1 什么是敏捷"
        }
    },
    {
        "start_id": "SS3.1.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.1.4.1",
            "content": "敏捷团队是能够适当响应变化的灵活团队：\n变化就是软件开发本身，软件构建有变化、团队成员在变化、使用新技术会带来变化。\n各种变化都会对开发的软件产品以及项目本身造成影响。我们必须接受“支持变化”的思想，它应当根植于软件开发的每一件事中，因为它是软件的心脏与灵魂。\n敏捷团队意识到软件是由团队中所有人共同开发完成的，这些人的个人技能和合作能力是项目成功的关键所在。 \n普遍存在的变化是敏捷的基本动力。",
            "name": "3.1.4.1 变化以及敏捷团队"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.1.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.4",
            "name": "3.1.4 敏捷"
        }
    },
    {
        "start_id": "SS3.1.4.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.1.4.2",
            "content": "它鼓励能够形成沟通（组员之间、技术和商务人员之间、软件工程师和经理之间）更便利的团队结构和协作态度。\n它强调可运行软件的快速交付而不那么看重中间产品（这并不总是好事情）；\n它将客户作为开发团队的成员以消除一直普遍存在多数软件项目中的“区分你我”的态度；\n它意识到在不确定的世界里计划是有局限性的，项目计划必须是可以灵活调整的。",
            "name": "3.1.4.2 敏捷不仅仅是有效地响应变化"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.1.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.1.4",
            "name": "3.1.4 敏捷"
        }
    },
    {
        "start_id": "T3.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.2",
            "name": "3.2 敏捷及变更成本"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH3",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH3",
            "name": "第3章 敏捷和敏捷过程"
        }
    },
    {
        "start_id": "S3.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.2.1",
            "content": "软件开发的传统方法中（有几十年的开发经验作支持），变更的成本费用随着计划的进展成非线性增长。这种方法在软件开发团队收集需求时（在项目的早期）相对容易适应变更。\n\n如果我们在经过数月的开发时间之后将会怎么样？团队在进行确认测试的过程中（也许是在项目后期的某个活动中），一个重要的利益相关者要求变更一个主要的功能：这一变更需要对软件的体系结构设计进行修改，包括设计和构建三个新组件，修改另外五个组件，设计新的测试等。费用会迅速升级，而这方面的开销则是可观的。",
            "name": "3.2.1 传统软件开发方法的变更"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.2",
            "name": "3.2 敏捷及变更成本"
        }
    },
    {
        "start_id": "S3.2.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.2.2",
            "content": "敏捷的拥护者认为，一个设计良好的敏捷过程“拉平”了变更成本曲线，使软件开发团队在没有超常规的时间和费用影响的情况下，在软件项目后期能够适应各种变化。\n敏捷过程包括增量交付。当增量交付与其他敏捷实践耦合时，例如连续单元测试及结对编程，引起变更的费用会衰减。\n虽然关于拉平曲线的程度的讨论仍然在进行，但是证据表明，敏捷变更费用显著降低。",
            "name": "3.2.2  敏捷的变更"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.2",
            "name": "3.2 敏捷及变更成本"
        }
    },
    {
        "start_id": "T3.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.3",
            "name": "3.3 什么是敏捷过程"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH3",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH3",
            "name": "第3章 敏捷和敏捷过程"
        }
    },
    {
        "start_id": "S3.3.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.3.1",
            "content": "1. 我们最优先要做的是通过尽早、持续地交付有价值的软件来使客户满意。\n2. 即使在开发的后期，也欢迎需求变更。敏捷过程利用变更为客户创造竞争优势。\n3. 经常交付可运行软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。\n4. 在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。\n5. 围绕有积极性的个人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。\n6. 在团队内部，最富有效果和效率的信息传递方法是面对面交谈。\n7. 可运行软件是进度的首要度量标准。\n8. 敏捷过程提倡可持续的开发速度。责任人（sponsor）、开发者和用户应该能够保持一个长期的、恒定的开发速度 。\n9. 不断地关注优秀的技能和好的设计会增强敏捷能力。\n10. 简单是必要的。\n11. 最好的架构、需求和设计出自于自组织团队。\n12. 每隔一定时间，团队会反省如何才能更有效地工作，并相应调整自己的行为。\n★并不是每一个敏捷模型都同等使用这12项原则，一些模型可以选择忽略（或至少淡化）一个或多个原则的重要性。",
            "name": "3.3.1 敏捷原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.3",
            "name": "3.3 什么是敏捷过程"
        }
    },
    {
        "start_id": "S3.3.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.3.2",
            "name": "3.3.2 敏捷过程的特征"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.3",
            "name": "3.3 什么是敏捷过程"
        }
    },
    {
        "start_id": "SS3.3.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.3.2.1",
            "content": "任何敏捷软件过程的特征都是以某种方式提出若干关键假设，这些假设适用于大多数软件项目：\n1. 提前预测哪些需求是稳定的以及那些需求会变更是非常困难的。同样，预测项目开发过程中客户优先级的变更也很困难。\n2. 对很多软件来说，设计和构建是交错进行的。也就是说，两种活动应当顺序开展以保证通过构建实施来验证设计模型，而在通过构建验证之前很难估计应该设计到什么程度。\n3. 分析、设计、构建和测试并不像我们设想的那么容易预测。（从制定计划的角度来看）。",
            "name": "3.3.2.1 敏捷过程的三大假设"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.3.2",
            "name": "3.3.2 敏捷过程的特征"
        }
    },
    {
        "start_id": "SS3.3.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.3.2.2",
            "content": "“如何建立能解决不可预测性的过程？”\n答案就在于过程的可适应性（对于快速变更的项目和技术条件）。因此，敏捷过程必须具有可适应性",
            "name": "3.3.2.2 敏捷过程的一个重要问题"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.3.2",
            "name": "3.3.2 敏捷过程的特征"
        }
    },
    {
        "start_id": "S3.3.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.3.3",
            "name": "3.3.3 人的因素"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.2",
            "name": "3.2 敏捷及变更成本"
        }
    },
    {
        "start_id": "SS3.3.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.3.3.1",
            "content": "“敏捷开发关注个人的才智和技巧，根据特定人员和团队来塑造过程。”这一描述的关键点在于“构造可以满足人员及团队需求的过程模型”，而非选择其他的过程模型。",
            "name": "3.3.3.1 构造而非选择"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.3.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.3.3",
            "name": "3.3.3 人的因素"
        }
    },
    {
        "start_id": "SS3.3.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.3.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.3.3",
            "name": "3.3.3 人的因素"
        }
    },
    {
        "start_id": "P3.3.3.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.1",
            "content": "同在传统软件工程中一样，在敏捷开发中，“能力”一词包含了个人内在才能、特定的软件相关技能以及对所选过程的全局知识。",
            "name": "3.3.3.2.1 基本能力"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        }
    },
    {
        "start_id": "P3.3.3.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.2",
            "content": "虽然敏捷团队成员能完成不同的任务，为项目提供不同的技能，但是所有人必须瞄准同一个目标，即在承诺的时间内向客户提交可运行的软件增量。为了实现这一目标，项目组还应当做出或大或小的连续的适应性变化，以使过程更适合于团队的需要。",
            "name": "3.3.3.2.2 共同目标"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        }
    },
    {
        "start_id": "P3.3.3.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.3",
            "content": "项目组成员之间，项目组与所有其他利益相关者之间必须精诚合作。",
            "name": "3.3.3.2.3 精诚合作"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        }
    },
    {
        "start_id": "P3.3.3.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.4",
            "content": "包括敏捷团队在内，任何一个好的软件项目组必须有能够掌握自身命运的自由。这意味着应当赋予项目组在技术和项目问题上的自主决策权。",
            "name": "3.3.3.2.4 决策能力"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        }
    },
    {
        "start_id": "P3.3.3.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.5",
            "content": "软件项目经理应当认识到：敏捷项目组被迫不断面对不确定的事情，被迫不断和变更作斗争。有时，项目组不得不接受今天正在解决的问题明天根本不需解决这样的现实。",
            "name": "3.3.3.2.5 模糊问题解决能力"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        }
    },
    {
        "start_id": "P3.3.3.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.6",
            "content": "敏捷团队必须成为具有凝聚力的团队，这样的团队展现出的相互信任和尊重使其形成“一个强有力的组织，确保整体的实力大于各部分实力之和”。",
            "name": "3.3.3.2.6 相互信任和尊重"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        }
    },
    {
        "start_id": "P3.3.3.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.3.3.2.7",
            "content": "自组织在敏捷开发中具有三重含义：\n（1）敏捷团队组织自身以完成工作 (组织团队)；\n（2）团队组织最能适应当前环境的过程 (组织过程)；\n（3）团队组织最好的进度安排以完成软件增量交付 (组织进度)。\n\n自组织具有一些技术上的好处，但是更为重要的是它能促进合作，鼓舞士气。本质上，这也就是项目组的自我管理。",
            "name": "3.3.3.2.7 自组织"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.3.3.2",
            "name": "3.3.3.2 对敏捷团队以及成员的要求"
        }
    },
    {
        "start_id": "T3.4",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.4",
            "name": "3.4 Scrum"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH3",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH3",
            "name": "第3章 敏捷和敏捷过程"
        }
    },
    {
        "start_id": "S3.4.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.1",
            "content": "Scrum原则与敏捷宣言是一致的，应用Scrum原则指导过程中的开发活动，过程由“需求、分析、设计、演化和交付”等框架性活动组成。",
            "name": "3.4.1 Scrum团队和制品"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.4",
            "name": "3.4 Scrum"
        }
    },
    {
        "start_id": "S3.4.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.2",
            "content": "在开始每个冲刺之前，产品负责人会提出他的开发目标，以在即将开始的冲刺中完成增量。",
            "name": "3.4.2 冲刺规划会议"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.4",
            "name": "3.4 Scrum"
        }
    },
    {
        "start_id": "S3.4.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.3",
            "content": "Scrum会议可帮助团队尽早发现潜在的问题。",
            "name": "3.4.3 每日Scrum会议"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.4",
            "name": "3.4 Scrum"
        }
    },
    {
        "start_id": "S3.4.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.4",
            "content": "开发团队认为增量已完成时，就要召开冲刺评审会议，时间安排在冲刺结束时。",
            "name": "3.4.4 冲刺评审会议"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.4",
            "name": "3.4 Scrum"
        }
    },
    {
        "start_id": "S3.4.5",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.4.5",
            "content": "理想情况下，在开始另一个冲刺规划会议前， Scrum master将与开发团队一起安排一场3小时的“冲刺回顾”会议。在会议上，团队将讨论：在冲刺中哪些方面进展顺利？哪些方面需要改进？ 团队在下一个冲刺中将致力于改进什么？",
            "name": "3.4.5 冲刺回顾"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.4",
            "name": "3.4 Scrum"
        }
    },
    {
        "start_id": "T3.5",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.5",
            "name": "3.5 其他敏捷过程"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH3",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH3",
            "name": "第3章 敏捷和敏捷过程"
        }
    },
    {
        "start_id": "S3.5.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.5.1",
            "name": "3.5.1 XP框架"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.5",
            "name": "3.5 其他敏捷过程"
        }
    },
    {
        "start_id": "SS3.5.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.1.1",
            "content": "极限编程Extreme Programming是使用最广泛的敏捷过程。其具有三个特点：\n1.是一些相互关联的准则和惯例的集合；\n2.追求变更曲线平坦化；\n3.适合于小团队、高风险的项目。",
            "name": "3.5.1.1 极限编程介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.5.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.5.1",
            "name": "3.5.1 XP框架"
        }
    },
    {
        "start_id": "SS3.5.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.1.2",
            "content": "XP使用面向对象方法作为推荐的开发范型，它包含了策划、设计、编码和测试4个框架活动的规则和实践。",
            "name": "3.5.1.2 极限编程活动"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.5.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.5.1",
            "name": "3.5.1 XP框架"
        }
    },
    {
        "start_id": "P3.5.1.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.1.2.1",
            "content": "1.创建“故事”卡片，描述软件所需功能与特性，由客户用自然语言书写。\n2.评估每个故事，确定开发成本（以周数为单位）。\n3.客户与XP团队共同决定故事分组，确定下一个发行版本（软件增量）。\n4.对发布版本做出基本承诺。\n排序待开发故事：先实现快速、高权值、高风险的故事。\n5.首个版本发布后，XP团队计算项目速度。\n6.开发中，客户可增删改故事或调整权值，XP团队据此调整计划。",
            "name": "3.5.1.2.1 策划"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.1.2",
            "content": "XP使用面向对象方法作为推荐的开发范型，它包含了策划、设计、编码和测试4个框架活动的规则和实践。",
            "name": "3.5.1.2 极限编程活动"
        }
    },
    {
        "start_id": "P3.5.1.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.1.2.2",
            "content": "1.严格遵循KIS原则，即追求简洁而非复杂。避免为假定未来需求而设计额外功能。\n2.推荐使用CRC卡来明确与当前软件增量相关的面向对象类。CRC卡包括类、责任和协作者。\n3.在故事设计遇阻时，应立即构建可执行原型（Spike解决方案），通过实践验证设计，降低实现风险，并确认初步估计。\n4.鼓励重构，即在保持代码外部行为不变的前提下，改进其内部结构。重构旨在优化设计和代码，但工作量随软件规模增长而显著增加。",
            "name": "3.5.1.2.2 设计"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.1.2",
            "content": "XP使用面向对象方法作为推荐的开发范型，它包含了策划、设计、编码和测试4个框架活动的规则和实践。",
            "name": "3.5.1.2 极限编程活动"
        }
    },
    {
        "start_id": "P3.5.1.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.1.2.3",
            "content": "1.推荐在故事开发和初步设计后，先开发覆盖所有故事的单元测试，再开始编码。这样能在编码完成后立即测试，提供即时反馈。\n2.提倡结对编程，两人共用一台计算机开发代码，实时解决问题和保证质量，同时专注手头问题。\n3.结对编程中，成员角色略有不同，一人负责编码细节，另一人确保编码标准。\n4.完成工作后，代码需与其他人集成。团队或结对者自己负责集成，后者采用“连续集成”策略，避免兼容性和接口问题。",
            "name": "3.5.1.2.3 编码"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.1.2",
            "content": "XP使用面向对象方法作为推荐的开发范型，它包含了策划、设计、编码和测试4个框架活动的规则和实践。",
            "name": "3.5.1.2 极限编程活动"
        }
    },
    {
        "start_id": "P3.5.1.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.1.2.4",
            "content": "1.单元测试应使用自动框架，便于执行与重复，支持代码修改后的即时回归测试。\n2.个人测试集成到“通用测试集”，每日系统验证，为XP团队提供进度指示并及早预警。\n3.频繁小修比截止期前大修更省时。\n4.XP验收测试由客户主导，针对用户故事实现的功能与特征。",
            "name": "3.5.1.2.4 测试"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.1.2",
            "content": "XP使用面向对象方法作为推荐的开发范型，它包含了策划、设计、编码和测试4个框架活动的规则和实践。",
            "name": "3.5.1.2 极限编程活动"
        }
    },
    {
        "start_id": "S3.5.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.5.2",
            "name": "3.5.2 看板法"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.5",
            "name": "3.5 其他敏捷过程"
        }
    },
    {
        "start_id": "SS3.5.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.2.1",
            "content": "看板法是一种精益方法学，提供了描述改进过程或工作流的方法。",
            "name": "3.5.2.1 看板法介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "SS3.5.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.1",
            "content": "看板法是一种精益方法学，提供了描述改进过程或工作流的方法。",
            "name": "3.5.2.1 看板法介绍"
        }
    },
    {
        "start_id": "SS3.5.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "SS3.5.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.1",
            "content": "看板法是一种精益方法学，提供了描述改进过程或工作流的方法。",
            "name": "3.5.2.1 看板法介绍"
        }
    },
    {
        "start_id": "P3.5.2.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.1",
            "content": "1.使用看板图可视化工作流。看板图按列组织，分别表示软件功能的每个元素的发展阶段。板上的卡片应包含单个用户故事或最近发现的写在便利贴上的缺陷，团队会随着项目进展将标记从“要做”推进到“正在进行”，再到“已完成”。",
            "name": "3.5.2.2.1 可视化工作流"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        }
    },
    {
        "start_id": "P3.5.2.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.2",
            "content": "2.在给定时间内要限制当下工作负荷。鼓励开发人员在开始另一项任务之前完成当前任务。这将缩短交付时间，提高工作质量，并提高团队向利益相关者频繁交付软件功能的能力。",
            "name": "3.5.2.2.2 限制工作负荷"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        }
    },
    {
        "start_id": "P3.5.2.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.3",
            "content": "3.通过了解当前价值流，分析停滞位置，定义变更以及实施变更来管理工作流以减少浪费。",
            "name": "3.5.2.2.3 减少浪费"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        }
    },
    {
        "start_id": "P3.5.2.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.4",
            "content": "4.明确的过程策略。",
            "name": "3.5.2.2.4 明确过程策略"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        }
    },
    {
        "start_id": "P3.5.2.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.5",
            "content": "5.通过创建反馈循环聚焦持续改进，基于过程数据引入变更，并在进行变更后评价变更对过程的影响。",
            "name": "3.5.2.2.5 创建反馈循环"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        }
    },
    {
        "start_id": "P3.5.2.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.2.2.6",
            "content": "6.过程变更中要相互合作，并根据需要让所有团队成员和其他利益相关人参与进来。",
            "name": "3.5.2.2.6 变更中的相互合作"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        }
    },
    {
        "start_id": "SS3.5.2.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.2.3",
            "content": "看板法的团队回合与Scrum框架中的会议类似。如果将看板法引入现有项目，则并非所有项目都将在待定项栏目中启动。",
            "name": "3.5.2.3 团队会议"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "SS3.5.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.2.2",
            "name": "3.5.2.2 看板法的6个核心实践"
        }
    },
    {
        "start_id": "S3.5.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S3.5.3",
            "name": "3.5.3 DevOps"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T3.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T3.5",
            "name": "3.5 其他敏捷过程"
        }
    },
    {
        "start_id": "SS3.5.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.3.1",
            "content": "DevOps由Patrick DeBois创建，旨在将开发和运维相结合。",
            "name": "3.5.3.1 DevOps介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.5.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.5.3",
            "name": "3.5.3 DevOps"
        }
    },
    {
        "start_id": "SS3.5.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS3.5.3.2",
            "name": "3.5.3.2 DevOps的5个持续循环阶段"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S3.5.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S3.5.3",
            "name": "3.5.3 DevOps"
        }
    },
    {
        "start_id": "P3.5.3.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.1",
            "content": "将软件可交付成果分解到多次冲刺中开发，增量由开发团队的质量保证成员进行测试。",
            "name": "3.5.3.2.1 持续开发"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.3.2",
            "name": "3.5.3.2 DevOps的5个持续循环阶段"
        }
    },
    {
        "start_id": "P3.5.3.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.2",
            "content": "自动化测试工具用于帮助团队成员同时测试多个代码增量，以确保在集成之前他们没有缺陷。",
            "name": "3.5.3.2.2 持续测试"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.3.2",
            "name": "3.5.3.2 DevOps的5个持续循环阶段"
        }
    },
    {
        "start_id": "P3.5.3.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.3",
            "content": "将具有新功能的代码段添加到现有代码和运行环境中，然后对其进行检查以确保部署后没有错误。",
            "name": "3.5.3.2.3 持续集成"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.3.2",
            "name": "3.5.3.2 DevOps的5个持续循环阶段"
        }
    },
    {
        "start_id": "P3.5.3.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.4",
            "content": "在此阶段，将继承代码部署（安装）到生产环境，其中包括准备接收新功能的分布在全球的多个站点。",
            "name": "3.5.3.2.4 持续部署"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.3.2",
            "name": "3.5.3.2 DevOps的5个持续循环阶段"
        }
    },
    {
        "start_id": "P3.5.3.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P3.5.3.2.5",
            "content": "开发团队成员的运维人员通过监控软件在生产环境中的性能，并在用户发现问题之前主动查找问题，以提高软件质量。",
            "name": "3.5.3.2.5 持续监控"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS3.5.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS3.5.3.2",
            "name": "3.5.3.2 DevOps的5个持续循环阶段"
        }
    },
    {
        "start_id": "T3.6",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T3.6",
            "content": "在现代经济中，市场条件变化迅速，客户和最终用户的要求不断更新，新一轮竞争威胁会没有任何征兆地出现。从业者必须使软件工程工作保持敏捷——要定义灵活机动、有适应能力和精益的过程以适应现代商务的需求。\n软件工程的敏捷理念强调4个关键问题:自组织团队对所开展工作具有控制力的重要性;团队成员之间以及开发参与者和客户之间的交流与合作;对“变更代表机遇”的认识;强调快速交付让客户满意的软件。敏捷过程模型能解决上述问题。\n现实情况是，没有一种敏捷方法适合每个项目。敏捷开发人员在自主团队中工作，并有权创建自己的过程模型。\nScrum强调使用一组软件过程模式，这些模式已证明对时间紧迫、需求变更和业务关键的项目有效。Scrum团队没有理由不使用看板图来帮助其组织日常规划会议\n极限编程(XP）按照策划、设计、编码和测试4个框架活动组织，并提出一系列新颖且有力的技术，以保证敏捷团队创建的体现利益相关者指定优先级特征和功能的软件能频繁发布。没有什么能部阻止人们使用DevOps技术来缩短部署时间。",
            "name": "3.6 小结"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH3",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH3",
            "name": "第3章 敏捷和敏捷过程"
        }
    },
    {
        "start_id": "T6.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T6.1",
            "name": "6.1 核心原则"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH6",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH6",
            "name": "第6章 指导实践的原则"
        }
    },
    {
        "start_id": "S6.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.1.1",
            "name": "6.1.1 指导过程的原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T6.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.1",
            "name": "6.1 核心原则"
        }
    },
    {
        "start_id": "SS6.1.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.1.1.1",
            "name": "6.1.1.1 介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.1.1",
            "name": "6.1.1 指导过程的原则"
        }
    },
    {
        "start_id": "SS6.1.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.1.1",
            "name": "6.1.1 指导过程的原则"
        }
    },
    {
        "start_id": "P6.1.1.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.1",
            "content": "关于你所选择的过程模型是传统的还是敏捷的，敏捷开发的基本原则会提供判断方法。你所做的工作的每方面都应着重于活动的经济性——保持你的技术方法尽可能简单，保持你的工作产品尽可能简洁，无论何时尽可能根据具体情况做出决定。",
            "name": "6.1.1.2.1 原则1：敏捷"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "P6.1.1.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.2",
            "content": "每个过程活动、动作及任务的出口条件都应关注所生产的工作产品的质量。",
            "name": "6.1.1.2.2 原则2：每一步都关注质量"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "P6.1.1.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.3",
            "content": "过程不是信奉经验，其中没有信条。必要的时候，就让你的方法适应于由问题、人员以及项目本身施加的限制。",
            "name": "6.1.1.2.3 原则3：做好适应的准备"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "P6.1.1.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.4",
            "content": "软件工程过程和实践是重要的，但最根本的还是人。必须建立一个彼此信任和尊重的自组织团队。",
            "name": "6.1.1.2.4 原则4：建立一个有效的团队"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "P6.1.1.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.5",
            "content": "建立沟通和协调机制。项目失败是由于遗漏了重要信息，或是利益相关者未能尽力去创造一个成功的最终产品。这些属于管理的问题，必须设法解决。",
            "name": "6.1.1.2.5 原则5：建立沟通和协调机制"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "P6.1.1.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.6",
            "content": "管理变更。管理变更的方法可以是正式的或非正式的，但是必须建立一 种机制，来管理变更要求的提出、变更的评估、变更的批准以及变更实施的方式。",
            "name": "6.1.1.2.6 原则6：管理变更"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "P6.1.1.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.7",
            "content": "在进行软件开发时会出现很多问题。建立应急计划是非常重要的。某些应急计划会成为安全工程任务的基准(第18章)。",
            "name": "6.1.1.2.7 原则7：评估风险"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "P6.1.1.2.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.1.2.8",
            "content": "唯有那些能为其他过程活动、动作或任务提供价值的工作产品才值得创造。每一个工作产品都会作为软件工程实践的一部分传递给别人。一定要确保工作产品所传达的是必要信息，不会模棱两可或残缺不全。",
            "name": "6.1.1.2.8 原则8：创造能给别人带来价值的工作产品"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.1.2",
            "name": "6.1.1.2 适用于通过过程框架的8个原则"
        }
    },
    {
        "start_id": "S6.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.1.2",
            "name": "6.1.2 指导实践的原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T6.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.1",
            "name": "6.1 核心原则"
        }
    },
    {
        "start_id": "SS6.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.1.2.1",
            "name": "6.1.2.1 介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.1.2",
            "name": "6.1.2 指导实践的原则"
        }
    },
    {
        "start_id": "SS6.1.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.1.2",
            "name": "6.1.2 指导实践的原则"
        }
    },
    {
        "start_id": "P6.1.2.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.1",
            "content": "更具技术性的表达方式是：分析和设计中应经常强调关注点分离( Separation of Concerns, SoCs)。一个大问题分解为一组小元素(或关注点)之后就比较容易求解。",
            "name": "6.1.2.2.1 原则1：分治策略（分割和攻克）"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "P6.1.2.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.2",
            "content": "在这一核心原则中， 抽象就是对系统中些复杂元素的简单化、用一个专业用语来交流信息。我使用报表这一抽象概念，是假设你可以理解什么是报表，报表表示的是目录的普通结构，可以将经典的功能应用其中。在软件工程实践中可以使用许多不同层次的抽象，每个抽象都通告或暗示着必须交流的信息。在分析和设计中，软件团队通常从高度抽象的模型开始(如报表)然后逐渐将这些模型提炼成软低层次的抽象(如专栏或SUM功能)。",
            "name": "6.1.2.2.2 原则2：理解抽象的使用"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "P6.1.2.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.3",
            "content": "无论是创建分析模型、开发软件设计、开发源代码还是创建测试用例、一致性原则都建议采用用户熟悉的上下文以使软件易于使用。例如，为手机应用设计一个用户界面，一致的菜单选择、一致的色彩设计以及一致的可识别图标都有助于增强用户体验。",
            "name": "6.1.2.2.3 原则3：力求一致性"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "P6.1.2.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.4",
            "content": "软件所涉及的信息传送是多方面的——从数据库到最终用户、从遗留的应用系统到WebApp、从最终用户到图形用户界面(GUI)、从操作系统到应用、从一个软件构件到另一个构件，这个列表几乎是无穷无尽的。在每一种情况下，信息都会流经界面，因而，就有可能出现错误、遗漏或者歧义的情况。这一原则的含义是必须特别注意界面的分析、设计、构建以及测试。",
            "name": "6.1.2.2.4 原则4：关注信息传送"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "P6.1.2.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.5",
            "content": "对重要事务的分制(原则1)建立了软件的哲学.模块化则提供了实现这一哲学的机制。任何一个复杂的系统都可以被分割成许多模块(构件)、但是好的软件工程实践不仅如此，它还要求模块必须是有效的。也就是说，每个模块都应该专门集中表示系统中约束良好的一个方面。另外，模块应当以相对简单的方式与其他模块、数据源以及环境方面关联。",
            "name": "6.1.2.2.5 原则5：构建能展示有效模块化的软件"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "P6.1.2.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.6",
            "content": "软件工程师使用模式为他们过去遇到的问题进行分类，并重用其解决方案。通过允许复杂系统中的构件独立发展，可以将这些设计模式应用于更广泛的系程和系统集成问题。模式将在第14章中进一步讨论。",
            "name": "6.1.2.2.6 原则6：寻找模型"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "P6.1.2.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.7",
            "content": "当我们用大量不同的观点检测一个问题及其求解方法时，就很有能获得更深刻的认识，并发现错误和遗漏。统一建模语言（UML）提供了一种从多个视角描述问题解决方案的方式。",
            "name": "6.1.2.2.7 原则7：在可能的时候，用大量不同的观点描述问题及其的解决办法"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "P6.1.2.2.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.1.2.2.8",
            "content": "从长期看，缺陷暴露出来时，软件需要修正；环境发生变化时，软件需要适应；利益相关者需要更多功能时，软件需要增强。如果可靠的软件工程能够贯穿于整个软件过程，就会便于这些维护活动的实施。",
            "name": "6.1.2.2.8 原则8：记住，有人将要对软件进行维护"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.1.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.1.2.2",
            "name": "6.1.2.2 指导实践的8个原则"
        }
    },
    {
        "start_id": "T6.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T6.2",
            "name": "6.2 指导每个框架活动的原则"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH6",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH6",
            "name": "第6章 指导实践的原则"
        }
    },
    {
        "start_id": "S6.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.1",
            "name": "6.2.1 沟通原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T6.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.2",
            "name": "6.2 指导每个框架活动的原则"
        }
    },
    {
        "start_id": "SS6.2.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.1.1",
            "name": "6.2.1.1 介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.1",
            "name": "6.2.1 沟通原则"
        }
    },
    {
        "start_id": "SS6.2.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.1",
            "name": "6.2.1 沟通原则"
        }
    },
    {
        "start_id": "P6.2.1.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.1",
            "content": "在沟通之前，一定要确保你能够理解他人的观点，对对方的需求有所了解，然后再倾听。仔细倾听讲话者的每一句话，而不是急于叙述你对这些话的看法。如果有什么事情不清楚，可以要求他澄清，但是不要经常打断别人的讲述。当别人正在陈述的时候不要在言语或动作上表现出异议(比如转动眼睛或者摇头)。",
            "name": "6.2.1.2.1 原则1：倾听"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.2",
            "content": "在与其他人碰面之前花点时间去理解问题。如果必要的话，做一些调查来理解业务领域的术语。如果你负责主持一个会议，那么在开会之前准备一个议事日程。",
            "name": "6.2.1.2.2原则2：有准备的沟通"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.3",
            "content": "每个沟通会议都应该有个主持人(推动者），其作用是：\n(1)保持会议向着有效的方向进行；\n(2)调解会议中发生的冲突；\n(3)确保遵循我们所说的沟通原则。",
            "name": "6.2.1.2.3 原则3：沟通活动需要有人推动"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.4",
            "content": "但是，如果能以一些其他表示方式把相关信息是现出来，通常可以工作得更好，例如可以在集中讨论中使用草图或文档草稿。",
            "name": "6.2.1.2.4 原则4：最好当面沟通"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.5",
            "content": "任何解决方法都可能有缺陷。参与沟通的记录员应该记录下所有要点和决定。",
            "name": "6.2.1.2.5 原则5：记笔记并且记录所有决定"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.6",
            "content": "当项目组成员的想法需要汇集在一起用以阐述一个产品或者某个系统的功能或特性时，就产生了协作与合作的问题。每次小型的协作都可能建立起项目成员间的相互信任，并且为项目组创建一致的目标。",
            "name": "6.2.1.2.6 原则6：保持通力合作"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.7",
            "content": "在任何交流中，参与的人越多，话题转移到其他地方的可能性就越大。推动者应该保持谈话模块化，只有某个话题完全解决之后才能开始别的话题(不过还应该注意原则9)。",
            "name": "6.2.1.2.7 原则7：把讨论集中在限定的范围内"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.8",
            "content": "语言沟通的效果很有限，当语言无法表述某项工作的时候，草图或者绘图通常可以让表述变得更为清晰。",
            "name": "6.2.1.2.8 原则8：如果某些东西很难表述清楚，就采用图形表示"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.9",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.9",
            "content": "交流如同所有其他软件工程活动一样需要时间，与其永无止境地迭代，不如让参与者认识到还有很多话题需要讨论(参见原则2),“转换话题”有时是达到敏捷交流的最好方式。",
            "name": "6.2.1.2.9 原则9：敏捷地转换话题"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "P6.2.1.2.10",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.1.2.10",
            "content": "很多时候软件工程师和利益相关者必须商讨一些问题，如功能和特性、优先级和交付日期等。若要团队合作得好，那么各方要有一个共同的目标，并且协商还需要各方的协调。",
            "name": "6.2.1.2.10 原则10：协商不是一场竞赛或者一场游戏，双赢才能发挥协商的最大价值"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.1.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.1.2",
            "name": "6.2.1.2 沟通的10个原则"
        }
    },
    {
        "start_id": "S6.2.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.2",
            "name": "6.2.2 策划原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T6.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.2",
            "name": "6.2 指导每个框架活动的原则"
        }
    },
    {
        "start_id": "SS6.2.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.2.1",
            "name": "6.2.2.1 介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.2",
            "name": "6.2.2 策划原则"
        }
    },
    {
        "start_id": "SS6.2.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.2",
            "name": "6.2.2 策划原则"
        }
    },
    {
        "start_id": "P6.2.2.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.1",
            "content": "如果你不知道要去哪里，就不可能使用路线图。范围可以为软件开发团队提供一个目的地。",
            "name": "6.2.2.2.1 原则1：理解项目范围"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.2",
            "content": "为了适应这种情况，软件工程师必须经常商谈交付的顺序、时间表以及其他与项目相关的问题。",
            "name": "6.2.2.2.2 原则2：让利益相关者参与策划"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.3",
            "content": "在工作开始的时候，有很多事情有可能改变，那么就必须调整计划以适应这些变化。另外，在付每个软件增量之后，迭代式增量过程模型应该包含根据用户反馈的信息来修改计划的时间。",
            "name": "6.2.2.2.3 原则3：要认识道计划的指定应按照迭代方式进行"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.4",
            "content": "估算的目的是基于项目组对将要完成工作的当前理解，提供一种关于工作量、成本和任务工期的指标。如果信息是含糊的\n或者不可靠的，估算也将是不可靠的。",
            "name": "6.2.2.2.4 原则4：基于已知的估算"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.5",
            "content": "如果团队已经明确了哪些风险最容易发生且影响最大，那么应急计划就是必需的了。另外，项目计划（包括进度计划）应该可以调整，以适应那些可能发生的一种或多种风险。",
            "name": "6.2.2.2.5 原则5：计划时考虑风险"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.6",
            "content": "人们不能每天百分百地投入工作。变化总是在发生。甚至最好的软件工程师都会犯错误，这些现实情况都应该在项目制定计划的时候考虑。",
            "name": "6.2.2.2.6 原则6：保证可实现性"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.7",
            "content": "粒度指的是表示或者执行某些计划要素的细节。“细粒度”的计划可以提供重要的工作任务细节，这些细节是在相对短的时间段内计划完成的（这样就常常会有跟踪和控制的问题)。“粗粒度”的计划提供了更宽泛的长时间工作任务。通常，粒度随项目的进行而从细到粗。在很多个月内都不会发生的活动则不需要细化（太多的东西将会发生变化）。",
            "name": "6.2.2.2.7 原则7：调整计划粒度"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.8",
            "content": "计划中应该确定软件开发团队如何确保开发的质量。如果要执行正式技术评审°的话，应该将其列入进度；如果在构建过程中用到了结对编程（第3章)，那么在计划中要明确描述。",
            "name": "6.2.2.2.8 原则8：制定计划一确保质量"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.9",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.9",
            "content": "即使最好的策划也有可能被无法控制的变化破坏。软件开发团队应该确定在软件开发过程中如何适应变化，例如，客户会随时提出变更吗？如果提出了一个变更，团队是不是要立即实现？变更会带来怎样的影响和开销？",
            "name": "6.2.2.2.9 原则9：描述如何适应变化"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "P6.2.2.2.10",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.2.2.10",
            "content": "项目每次会落后进度一天的时间。因此，需要每天都追踪计划的进展，找出计划与实际执行不一致的问题所在，当任务进行出现延误时，计划也要随之做出调整。",
            "name": "6.2.2.2.10 原则10：经常跟踪并根据需要调整计划"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.2.2",
            "name": "6.2.2.2 策划的10个原则"
        }
    },
    {
        "start_id": "S6.2.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.3",
            "name": "6.2.3 建模原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T6.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.2",
            "name": "6.2 指导每个框架活动的原则"
        }
    },
    {
        "start_id": "SS6.2.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.3.1",
            "name": "6.2.3.1 介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.3",
            "name": "6.2.3 建模原则"
        }
    },
    {
        "start_id": "SS6.2.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.3",
            "name": "6.2.3 建模原则"
        }
    },
    {
        "start_id": "P6.2.3.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.1",
            "content": "敏捷的意义是尽可能快地将软件提供给用户。可以达到这个目标的模型是值得软件团队构建的，但是，我们需要避免那些降低了开发过程的速度以及不能提供新的见解的模型。",
            "name": "6.2.3.2.1 原则1：软件团队的主要目标是构建软件而不是创建模型"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.2",
            "content": "每次发生变化时，创建的模型必须是最新的。更重要的是，每创建一个新模型所花费的时间，还不如花费在构建软件（编码或测试)。因此，只创建那些可以使软件的构建更加简便和快速的模型。",
            "name": "6.2.3.2.2 原则2：轻装前进——不要创建任何不需要的模型"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.3",
            "content": "不要建造过于复杂的软件保持模型简单，产生的软件必然也会简单。最终的结果是，软件易于集成、易于测试且易于维护（对于变更）。另外，简单的模型易于开发团队成员理解和评判，从而使得持续不断的反馈可以对最终结果进行优化。",
            "name": "6.2.3.2.3 原则3：尽量创建能描述问题和软件的最简单模型"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.4",
            "content": "假设模型将要发生变化，但做这种假设并不草率。问题在于，如果没有相当完整的需求模型，那么所创建的设计（设计模型）会常常丢失重要功能和特性。",
            "name": "6.2.3.2.4原则4：用能适应变化的方式构建模型"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.5",
            "content": "每次创建模型时，都问一下自己为什么这么做。如果不能为模型的存在提供可靠的理由，就不要再在这个模型上花费时间。",
            "name": "6.2.3.2.5 原则5：明确描述创建每一个模型的目的"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.6",
            "content": "例如，一个电子游戏应用需要的建模技术与自动驾驶汽车所使用的实时嵌入式的巡航定速软件所需的建模技术或许会完全不同。",
            "name": "6.2.3.2.6 原则6：调整模型来适应待开发系统"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.7",
            "content": "当构建需求模型和设计模型时，软件工程师要达到减少返工的目的。也就是说，努力使模型绝对完美和内部一致的做法是不值当的。无休止地使模型“完美”并不能满足敏捷的要求。",
            "name": "6.2.3.2.7 原则7：尽量构建有用的模型而不是完美的模型"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.8",
            "content": "如果模型能够成功地传递信息，那么表述形式是次要的。虽然软件团队的每个人在建模期间都应使用一致的表达方式，但模型最重要的特性是交流信息，以便软件工程执行下一个任务。如果模型可以成功地做到这一点，不正确的表达方式就可以忽略。",
            "name": "6.2.3.2.8 原则8：对于模型的构造方法不要过于死板。"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.9",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.9",
            "content": "如果你是个有经验的软件工程师，就应相信直觉。软件工作中有许多教训——其中有些是潜意识的。如果有些事情告诉你设计的模型注定会失败（尽管你不能明确地证明），你就有理由再花一些时间来检查模型或开发另一个模型。",
            "name": "6.2.3.2.9 原则9：仔细注意模型"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "P6.2.3.2.10",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.3.2.10",
            "content": "任何模型都是为了传递信息，模型应该能够独立地表达信息，不需要任何人去解释它。每个模型都应经过软件团队的评审。评审的目的是提供反馈，用于纠正模型中的错误、改变误解，并增加不经意遗漏的功能和特性。",
            "name": "6.2.3.2.10 原则10：尽可能快地获得反馈"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.3.2",
            "name": "6.2.3.2 建模的10个原则"
        }
    },
    {
        "start_id": "S6.2.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.4",
            "name": "6.2.4 构建原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T6.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.2",
            "name": "6.2 指导每个框架活动的原则"
        }
    },
    {
        "start_id": "SS6.2.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.4.1",
            "name": "6.2.4.1 介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.4",
            "name": "6.2.4 构建原则"
        }
    },
    {
        "start_id": "SS6.2.4.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.4.2",
            "name": "6.2.4.2 编码原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.4",
            "name": "6.2.4 构建原则"
        }
    },
    {
        "start_id": "P6.2.4.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.2.1",
            "content": "原则1：理解所要解决的问题。\n原则2：理解基本的设计原则和概念。\n原则3：选择一种能够满足构建软件以及运行环境要求的编程语言。\n原则4：选择一种能提供工具以简化工作的编程环境。\n原则5：构件级编码完成后进行单元测试。",
            "name": "6.2.4.2.1 准备原则"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.2",
            "name": "6.2.4.2 编码原则"
        }
    },
    {
        "start_id": "P6.2.4.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.2.2",
            "content": "原则6：遵循结构化编程方法来约束算法。\n原则7：考虑使用结对编程。\n原则8：选择能满足设计要求的数据结构。\n原则9：理解软件体系结构并开发出与其相符的接口。",
            "name": "6.2.4.2.2 编程原则"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.2",
            "name": "6.2.4.2 编码原则"
        }
    },
    {
        "start_id": "P6.2.4.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.2.3",
            "content": "原则10：适当进行代码走查。\n原则11：进行单元测试并改正所发现的错误。\n原则12：重构代码来改进代码质量。",
            "name": "6.2.4.2.3 确认原则"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.2",
            "name": "6.2.4.2 编码原则"
        }
    },
    {
        "start_id": "SS6.2.4.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.4",
            "name": "6.2.4 构建原则"
        }
    },
    {
        "start_id": "P6.2.4.3.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.1",
            "name": "6.2.4.3.1 介绍"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.2",
            "content": "件测试的目标就是要揭示错误。而最严重的错误（从用户的角度来看）是那种导致程序无法满足需求的错误。",
            "name": "6.2.4.3.2 原则1：所有的测试都应该可以追溯到用户需求"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.3",
            "content": "测试计划（第19章）在分析模型一完成就应该开始。测试用例的详细定义可以在设计模型确定以后开始。因此，所有的测试在编码前都应该计划和设计好了。",
            "name": "6.2.4.33 原则2：测试计划应该远在测试之前就开始着手"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.4",
            "content": "简单地说，Pareto原则认为在软件测试过程中80%的错误都可以在大概20%的程序构件中找到根源。接下来的问题当然就是要分离那些可疑的构件，然后对其进行彻底的测试。",
            "name": "6.2.4.3.4 原则3：将Pareto原则应用于软件测试"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.5",
            "content": "最初计划并执行的测试通常着眼于单个程序模块，随着测试的进行，着眼点要慢慢转向在集成的构件簇中寻找错误，最后在整个系统中寻找错误。",
            "name": "6.2.4.3.5 原则4：测试应该从“微观”开始，逐步走向“宏观”"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.6",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.6",
            "content": "即便是一个中等大小的程序，其路径排列组合的数目都非常庞大。因此，在测试中对每个路径组合进行测试是不可能的。然而，充分覆盖程序逻辑并确保构件级设计中的所有条件都通过测试是有可能的。",
            "name": "6.2.4.3.6 原则5：穷举测试是不可能的"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.7",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.7",
            "content": "通常在最新的模块或者开发人员缺乏理解的模块中进行这些测试",
            "name": "6.2.4.3.7 原则6：为系统的每个模块做相应的缺陷密度测试"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.8",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.8",
            "content": "有超过85%的软件缺陷源于软件文档（需求、规格说明、代码走查和用户手册）。这对系统文档测试是有价值的。",
            "name": "6.2.4.3.8 原则7：静态测试技术能得到很好的结果"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.9",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.9",
            "content": "未发现的缺陷总数是软件质量好坏的指示器，未发现的缺陷类型可以很好地度量软件的稳定性。统计超时发现缺陷的模式可以预测缺陷的期望值。",
            "name": "6.2.4.3.9 原则8：跟踪缺陷，查找并测试未覆盖缺陷的模式"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "P6.2.4.3.10",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.4.3.10",
            "content": "在维护和修改软件构件时，未预料到的交互操作会无意识地影响另外的一些构件。在软件产品变更后要准备检测系统行为，进行一组回归测试（第19章）是很重要的。",
            "name": "6.2.4.3.10 原则9：包含在演示软件中的测试用例是正确的行为"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.4.3",
            "name": "6.2.4.3 测试原则"
        }
    },
    {
        "start_id": "S6.2.5",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S6.2.5",
            "name": "6.2.5 部署原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T6.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T6.2",
            "name": "6.2 指导每个框架活动的原则"
        }
    },
    {
        "start_id": "SS6.2.5.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.5.1",
            "name": "6.2.5.1 介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.5",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.5",
            "name": "6.2.5 部署原则"
        }
    },
    {
        "start_id": "SS6.2.5.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS6.2.5.2",
            "name": "6.2.5.2 部署的5个原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S6.2.5",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S6.2.5",
            "name": "6.2.5 部署原则"
        }
    },
    {
        "start_id": "P6.2.5.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.1",
            "content": "客户期望的结果通常比软件团队承诺交付的要多，这会很快令客户失望。这将导致客户反馈变得没有积极意义并且还会挫伤软件开发团队的士气。建议软件工程师必须认真地处理与客户有冲突的信息。（例如，对不可能在交付时完成的工作做出了承诺；在某次软件增量交付时交付了多于当初承诺要交付的工作，这将使得下次增量所要做的工作随之变少。）",
            "name": "6.2.5.2.1 原则1：客户对于软件的期望必须得到管理"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.5.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.5.2",
            "name": "6.2.5.2 部署的5个原则"
        }
    },
    {
        "start_id": "P6.2.5.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.2",
            "content": "所有可执行软件、支持数据文件、支持文档和一些相关的信息都必须组装起来，并经过实际用户的完整测试。所有的安装脚本和其他一些可操作的功能都应该在所有可能的计算配置（例如硬件、操作系统、外围设备、网络)环境中实施充分的检验。",
            "name": "6.2.5.2.2 原则2：完整的交付包应该经过安装和测试"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.5.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.5.2",
            "name": "6.2.5.2 部署的5个原则"
        }
    },
    {
        "start_id": "P6.2.5.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.3",
            "content": "最终用户希望在问题发生时能得到及时的响应和准确的信息。如果技术支持跟不上或者根本就没有技术支持，那么客户会立即表示不满。支持应该是有计划的，准备好支持的材料并且建立适当的记录保持机制，这样软件开发团队就能按照支持请求种类进行分类评估。",
            "name": "6.2.5.2.3 原则3：技术支持必须在软件交付之前就确定下来"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.5.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.5.2",
            "name": "6.2.5.2 部署的5个原则"
        }
    },
    {
        "start_id": "P6.2.5.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.4",
            "content": "必须为最终用户提供适当的说明材料。软件开发团队交付的不仅仅是软件本破身，也应该提供培训材料（如果需要的话）和故障解决方案，还应该发布关于“本次增量与以前版本有何不同”的描述。",
            "name": "6.2.5.2.4 原则4：必须为最终用户提供适当的说明材料"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.5.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.5.2",
            "name": "6.2.5.2 部署的5个原则"
        }
    },
    {
        "start_id": "P6.2.5.2.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P6.2.5.2.5",
            "content": "迫于时间的压力，某些软件组织会交付一些低质量的增量，还会在增量中向客户提出警告：这些缺陷将在下次发布时解决。这样做是错误的。在软件商务活动中有这样一条谚语：“客户在几天后就会忘掉你所交付的高质量软件，但是他们永远忘不掉那些低质量的产品所出现的问题。软件会时刻提醒着问题的存在。”",
            "name": "6.2.5.2.5 原则5：有缺陷的软件应该显改正再交付"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS6.2.5.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS6.2.5.2",
            "name": "6.2.5.2 部署的5个原则"
        }
    },
    {
        "start_id": "T6.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T6.3",
            "content": "\"需求建模的目标是创建各种表现形式，用其描述什么是客户需求，为生成的软件设计建立基础，一旦软件建立这些需求将用于验证。需求模型在系统级表示层和软件设计之间构造了桥梁。系统表示层描述了整个系统和业务功能，软件设计描述了软件应用的体系结构、用户接口和构建级的结构。\n  基于场景的模型从用户的角度描述软件需求。用例是主要的建模元素，它以叙述方式或以模板驱动方式描述了参与者和软件之间的交互活动。在需求获取过程中得到的用地定义了特定功能或交互活动的关键步骤。用例的正式程度和详细程度各不相同,但它们可以为所有的其他分析建模活动提供必要的输入。还可以使用活动图说明场景，活动图是描述特定场景内的处理流的图形表现形式。用例中的时序关系可以使用顺序图来建模。\n  为了识别分析类，基于类的建模使用从用例和其他编写的应用描述中导出的信息。可以使用语法解析从文本说明中提取候选类、属性和操作，并使用解析结果制定用于定义类的标准。\n  CRC索引卡可以用于定义类之间的联系。此外，可以使用各种UML建模方法定义类之间的层次、关系、关联、聚合和依赖。\n  在需求分析阶段的行为建模描述了软件的动态，行为建模采用来自基于场景和基于类的输入来表达分析类的状态。为达到这一目的，要识别状态，定义引起类（或系统）由一种状态转换到另一个状态的事件，还要识别完成转换后发生活动。UML状态图、活动图、泳道图和顺序图可以被用于行为建模。\"",
            "name": "6.3 小结"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH6",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH6",
            "name": "第6章 指导实践的原则"
        }
    },
    {
        "start_id": "T8.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.1",
            "name": "8.1 需求分析"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH8",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH8",
            "name": "第8章 需求建模——一种推荐的方法"
        }
    },
    {
        "start_id": "S8.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.1.1",
            "name": "8.1.1 总体目标和原理"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.1",
            "name": "8.1 需求分析"
        }
    },
    {
        "start_id": "SS8.1.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.1.1",
            "content": "在整个需求建模过程中，软件工程师的主要关注点集中在“做什么”而不是“怎么做”方面。包括：\n在特定环境下发生哪些用户交互？\n系统处理什么对象？\n系统必须执行什么功能？\n系统展示什么行为？\n定义什么接口？\n有什么约束？",
            "name": "8.1.1.1 主要关注点"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.1",
            "name": "8.1.1 总体目标和原理"
        }
    },
    {
        "start_id": "SS8.1.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.1.2",
            "content": "需求模型的三个主要目标：\n(1) 描述客户需要什么，分析正确性； \n(2) 为软件设计奠定基础；\n(3) 定义在软件完成后可以被确认的一组需求。",
            "name": "8.1.1.2 三个主要目标"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.1",
            "name": "8.1.1 总体目标和原理"
        }
    },
    {
        "start_id": "S8.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.1",
            "name": "8.1 需求分析"
        }
    },
    {
        "start_id": "SS8.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.1",
            "content": "模型应关注在问题或业务域内可见的需求，抽象的级别应该相对高一些。“不要陷入细节”，即不要试图解释系统将如何工作。",
            "name": "8.1.2.1 模型关注可见需求"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        }
    },
    {
        "start_id": "SS8.1.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.2",
            "content": "需求模型的每个元素都应能增加对软件需求的整体理解，并提供对信息域、功能和系统行为的深入理解。(存在即有用)",
            "name": "8.1.2.2 模型元素存在即有用"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        }
    },
    {
        "start_id": "SS8.1.2.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.3",
            "content": "关于基础结构和其他非功能的模型应推延到设计阶段再考虑。",
            "name": "8.1.2.3 基础结构和非功能模型暂缓考虑"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        }
    },
    {
        "start_id": "SS8.1.2.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.4",
            "content": "最小化整个系统内的关联。类和功能之间的联系非常重要，但是，如果“互联”的层次非常高，应该想办法减少互联。",
            "name": "8.1.2.4 最小化整个系统内联"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        }
    },
    {
        "start_id": "SS8.1.2.5",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.5",
            "content": "确认需求模型为所有利益相关者都带来价值。对模型来说，每个客户都有自己的使用目的。\n例如利益相关的业务人员将使用模型确认需求，设计人员将使用模型作为设计的基础；质量保证人员将使用模型帮助规划验收测试。",
            "name": "8.1.2.5 确认需求模型为所有利益相关者都带来价值"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        }
    },
    {
        "start_id": "SS8.1.2.6",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.2.6",
            "content": "尽可能保持模型简洁。如果没有提供新的信息，不要添加附加图表；如果一个简单列表就够用，就不要使用复杂的表示方法。",
            "name": "8.1.2.6 保持模型简洁"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.2",
            "name": "8.1.2 分析的经验原则"
        }
    },
    {
        "start_id": "S8.1.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.1.3",
            "name": "8.1.3 需求建模原则"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.1",
            "name": "8.1 需求分析"
        }
    },
    {
        "start_id": "SS8.1.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.1",
            "content": "信息域包含流入系统（来自终端用户、其他系统或外部设备）的数据，流出系统（通过用户界面、网络界面、图形或者其他形式的数据，以及数据存储区中收集和整理的永久保存的数据。",
            "name": "8.1.3.1 原则1：问题的信息域必须得到表达和理解"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.3",
            "name": "8.1.3 需求建模原则"
        }
    },
    {
        "start_id": "SS8.1.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.2",
            "content": "软件功能可以为终端用户带来直接好处，而那些为用户课件的功能提供内部支持的功能也可以直接受益。一些功能可以变换流入系统的数据。在其他情况下，功能会在某种程度上影响内部软件处理或外部系统元素的控制。",
            "name": "8.1.3.2 原则2：必须定义软件执行的功能"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.3",
            "name": "8.1.3 需求建模原则"
        }
    },
    {
        "start_id": "SS8.1.3.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.3",
            "content": "计算机软件的行为受其与外部环境的交互作用的驱动。终端用户提供的输入、外部系统提供的控制数据或通过网络收集的监视数据都使软件以特定方式运行。",
            "name": "8.1.3.3 原则3：必须表示软件的行为"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.3",
            "name": "8.1.3 需求建模原则"
        }
    },
    {
        "start_id": "SS8.1.3.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.4",
            "content": "需求建模是解决软件工程问题的第一步，为更好地理解问题并为解决方案（设计）建立基础。复杂的问题很难整体解决，因此应该使用分而治之的策略，将一个大而复杂的问题划分为多个子问题，直到每个子问题都相对容易理解为止。（关注点的划分或分离）",
            "name": "8.1.3.4 原则4：描述信息、功能和行为的模型必须以分层的方式进行分割以揭示细节"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.3",
            "name": "8.1.3 需求建模原则"
        }
    },
    {
        "start_id": "SS8.1.3.5",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.1.3.5",
            "content": "分析建模首先从终端用户的角度描述问题。描述问题的“本质”时没有考虑解决方案的实现方式。\n例如，电子游戏要求玩家在进入危险的迷宫时向其主角“指示”前进的方向（问题的本质）。\n实现细节指出如何实现问题的本质。对于电子游戏，可能会使用语音输入、键入键盘指令、游戏手柄等方法实现。",
            "name": "8.1.3.5 原则5：分析任务应从基本信息转向实现细节"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.1.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.1.3",
            "name": "8.1.3 需求建模原则"
        }
    },
    {
        "start_id": "T8.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.2",
            "name": "8.2 基于场景建模"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH8",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH8",
            "name": "第8章 需求建模——一种推荐的方法"
        }
    },
    {
        "start_id": "S8.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.2.1",
            "name": "8.2.1 参与者和用户概要文件"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.2",
            "name": "8.2 基于场景建模"
        }
    },
    {
        "start_id": "SS8.2.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.1.1",
            "content": "UML参与者对与系统对象进行交互的实体进行建模。",
            "name": "8.2.1.1 参与者"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.2.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.1",
            "name": "8.2.1 参与者和用户概要文件"
        }
    },
    {
        "start_id": "SS8.2.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.1.2",
            "content": "UML profile提供了一种将现有模型扩展到其他域或平台的方法。",
            "name": "8.2.1.2 用户概要文件"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.2.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.1",
            "name": "8.2.1 参与者和用户概要文件"
        }
    },
    {
        "start_id": "S8.2.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.2.2",
            "name": "8.2.2 创建用例"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.2",
            "name": "8.2 基于场景建模"
        }
    },
    {
        "start_id": "SS8.2.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.2.1",
            "content": "用例的定义 [Ivar Jacobson] ：用例只是帮助定义系统之外存在什么以及系统应完成什么。",
            "name": "8.2.2.1 用例的定义"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.2",
            "name": "8.2.2 创建用例"
        }
    },
    {
        "start_id": "SS8.2.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.2.2",
            "content": "用例从某个特定参与者的角度出发，采用简明的语言描述一个特定的使用场景。问题是：\n(1) 编写什么?\n(2) 写多少?\n(3) 编写说明应该多详细? \n(4) 如何组织说明?",
            "name": "8.2.2.2 创建用例的疑问"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.2",
            "name": "8.2.2 创建用例"
        }
    },
    {
        "start_id": "P8.2.2.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.2.2.2.1",
            "content": "用例应该基于需求工程工作（起始和获取）提供的信息来编写，包括确定利益相关者、定义问题范围、说明运行目标、建立优先级顺序、概述功能需求以及描述系统将处理的信息（对象）。用例从特定参与者的角度出发，描述一个特定的使用场景，通常通过需求收集会议、与利益相关者的交流或评估活动图来获得",
            "name": "8.2.2.2.1 编写什么？ "
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.2.2.2",
            "content": "用例从某个特定参与者的角度出发，采用简明的语言描述一个特定的使用场景。问题是：\n(1) 编写什么?\n(2) 写多少?\n(3) 编写说明应该多详细? \n(4) 如何组织说明?",
            "name": "8.2.2.2 创建用例的疑问"
        }
    },
    {
        "start_id": "P8.2.2.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.2.2.2.2",
            "content": "用例的数量取决于所需系统功能的列表，每个功能或活动都可能对应一个用例。随着与利益相关者的交谈增多，需求收集团队将为每个标记的功能开发用例。",
            "name": "8.2.2.2.2 写多少？"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.2.2.2",
            "content": "用例从某个特定参与者的角度出发，采用简明的语言描述一个特定的使用场景。问题是：\n(1) 编写什么?\n(2) 写多少?\n(3) 编写说明应该多详细? \n(4) 如何组织说明?",
            "name": "8.2.2.2 创建用例的疑问"
        }
    },
    {
        "start_id": "P8.2.2.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.2.2.2.3",
            "content": "用例的描述可以是非正式的描述性风格，也可以是更正式的结构化形式。用例描述应该详细到能够捕捉信息的产生者、使用者和系统本身之间的交互，包括主场景和次场景，以及异常处理。",
            "name": "8.2.2.2.3 编写说明应该有多详细？"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.2.2.2",
            "content": "用例从某个特定参与者的角度出发，采用简明的语言描述一个特定的使用场景。问题是：\n(1) 编写什么?\n(2) 写多少?\n(3) 编写说明应该多详细? \n(4) 如何组织说明?",
            "name": "8.2.2.2 创建用例的疑问"
        }
    },
    {
        "start_id": "P8.2.2.2.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.2.2.2.4",
            "content": "用例可以通过用户活动的顺序序列来表现交互，每个行动由声明性的语句表示。\n组织说明时，应该包括主场景（主要的交互步骤）和次场景（可供选择的行为或错误条件）。\n异常处理描述了导致系统展示出不同行为的场景，包括失败条件或参与者选择了替代方案。\n组织用例时，可以使用“头脑风暴”来推动团队合理地完成每个用例中的异常处理。",
            "name": "8.2.2.2.4 如何组织说明？"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.2.2.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.2.2.2",
            "content": "用例从某个特定参与者的角度出发，采用简明的语言描述一个特定的使用场景。问题是：\n(1) 编写什么?\n(2) 写多少?\n(3) 编写说明应该多详细? \n(4) 如何组织说明?",
            "name": "8.2.2.2 创建用例的疑问"
        }
    },
    {
        "start_id": "S8.2.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.2.3",
            "name": "8.2.3 编写用例"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.2",
            "name": "8.2 基于场景建模"
        }
    },
    {
        "start_id": "SS8.2.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.3.1",
            "content": "当用例需要包括关键活动或描述具有大量异常处理的复杂步骤时，非正式用例可能不足以满足需求，因此需要更正式的方法。",
            "name": "8.2.3.1 为什么需要正式的用例描述？"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.2.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.3",
            "name": "8.2.3 编写用例"
        }
    },
    {
        "start_id": "SS8.2.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.3.2",
            "content": "包括用例名称、选代、主要参与者、情境目标、前提条件、触发器、场景、异常处理、优先级、何时有效、使用频率、参与者的连接渠道、次要参与者及其连接渠道、未解决的问题。",
            "name": "8.2.3.2 SafeHome监视的用例模板中包含的关键元素"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.2.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.3",
            "name": "8.2.3 编写用例"
        }
    },
    {
        "start_id": "SS8.2.3.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.2.3.3",
            "content": "每种需求建模方法都有其局限性，用例方法也无例外：\n1.如果描述不清晰，用例可能会误导或有歧义。\n2.对于必须特别详细和精准的需求建模情景 (例如安全关键系统)，图形化的表示方法更有助于理解。",
            "name": "8.2.3.3 图形化用户场景"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.2.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.2.3",
            "name": "8.2.3 编写用例"
        }
    },
    {
        "start_id": "T8.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.3",
            "name": "8.3 基于类建模"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH8",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH8",
            "name": "第8章 需求建模——一种推荐的方法"
        }
    },
    {
        "start_id": "S8.3.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.3.1",
            "name": "8.3.1 识别分析类"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.3",
            "name": "8.3 基于类建模"
        }
    },
    {
        "start_id": "SS8.3.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.1.1",
            "content": "通过检查问题描述进行。\n从名词中筛选：\n  ①外部实体 (其他系统、设备、人员)\n  ②事物 (报告、显示、字母、信号)\n  ③偶发事件或事件\n  ④角色 (经理、工程师、销售人员)\n  ⑤组织单元 (部门、组、团队) \n  ⑥场地 (制造车间或码头)\n  ⑦结构 (传感器、四轮交通工具、计算机)\n统称信息(过于宽泛)、基本属性(过于简单)、纯操作不宜选做类",
            "name": "8.3.1.1 识别类"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.1",
            "name": "8.3.1 识别分析类"
        }
    },
    {
        "start_id": "SS8.3.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.1.2",
            "content": "分析师考虑在每个潜在类是否应使用如下基本特征：\n①保留信息：必须记录潜在类的信息才能保证系统正常工作\n②所需服务：有一组可确认的，能改变属性值的操作\n③多个属性：只有一个属性的类可能在设计中有用，但在分析阶段，更适合作为另一个类的某个属性\n④公共属性：可定义一组属性，它们适用于该潜在类的所有实例\n⑤公共操作：可定义一组操作，它们适用于该潜在类的所有实例\n⑥必要需求：在问题空间中出现的外部实体、或者任何系统解决方案的运行所必需的信息\n应注意到：\n(1)某些被拒绝的潜在类将成为被接受类的属性；\n(2)对问题的不同陈述可能导致作出“接受或拒绝”不同的决定。",
            "name": "8.3.1.2 分析类——寻找潜在类"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.1",
            "name": "8.3.1 识别分析类"
        }
    },
    {
        "start_id": "S8.3.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.3.2",
            "name": "8.3.2 定义属性和操作"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.3",
            "name": "8.3 基于类建模"
        }
    },
    {
        "start_id": "SS8.3.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.2.1",
            "content": "为了给分析类开发一个有意义的属性集合，软件工程师应该研究用例并选择那些合理的\"属于\"类的\"事物\"。\n\n属性： “属于”类的事物。\n属性描述已经被选择包含在分析模型中的对象。在本质上，正是属性定义了对象——它们阐明了在问题空间中对象意味着什么。每个类都应回答如下问题：什么数据项（组合项或基本项）能够在当前问题环境内完整地定义这个类？此外，如果有超过一个项和某个类相关联，就应避免把这个项定义为属性。",
            "name": "8.3.2.1 属性定义"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.2",
            "name": "8.3.2 定义属性和操作"
        }
    },
    {
        "start_id": "SS8.3.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.2.2",
            "content": "操作定义了某个对象的行为。尽管存在很多不同类型的操作，但通常可以粗略地划分为4种类型：(1）以某种方式操作数据（例如添加、删除、重新格式化、选择）;(2）执行计算的操作；(3）请求某个对象的状态的操作；(4）监视某个对象发生某个控制事件的操作。",
            "name": "8.3.2.2 操作定义"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.2",
            "name": "8.3.2 定义属性和操作"
        }
    },
    {
        "start_id": "S8.3.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.3.3",
            "content": "分析师能通过考虑对象间所发生的通信获得对其他操作更为深入的了解。对象通过传递信息与另一个对象通信。在继续对操作进行说明之前，我们探测到了更详实的信息。在许多情况下，两个分析类以某种方式彼此关联。在UML中，这些关系称为关联。",
            "name": "8.3.3 UML类模型"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.3",
            "name": "8.3 基于类建模"
        }
    },
    {
        "start_id": "S8.3.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.3.4",
            "name": "8.3.4 类–职责–协作者建模"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.3",
            "name": "8.3 基于类建模"
        }
    },
    {
        "start_id": "SS8.3.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.1",
            "content": "类﹣职责﹣协作者（CRC）建模提供了一个简单方法，可以识别和组织与系统或产品需求相关的类。职责是和类相关的属性和操作。协作者是提供完成某个职责所需要信息或动作的类。\n\n类，在前面的8.3.1节中已经介绍了识别类和对象的基本原则。\n职责，8.3.2节介绍了识别职责（属性和操作）的基本原则。\n协作。类用一种或两种方法来实现其职责，(1）类可以使用其自身的操作控制各自的属性，从而实现特定的职责；(2）类可以和其他类协作。要识别协作可以通过确认类本身是否能够实现自身的每个职责。如果不能实现每个职责，那么需要和其他类交互。",
            "name": "8.3.4.1 模型介绍"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.4",
            "name": "8.3.4 类–职责–协作者建模"
        }
    },
    {
        "start_id": "SS8.3.4.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.2",
            "content": "1.实体类，也称模型或业务类，是从问题说明中直接提取出来的。\n2.边界类用于创建用户可见的和在使用软件时交互的接口(如交互屏幕或打印的报表)。\n3.控制类用于管理“工作单元”。控制类可以管理：\n(1) 实体类的创建或更新；(2) 边界类获取信息后的实例化。(3) 对象集合间的复杂通信。(4) 对象间或用户和应用系统间交换数据的确认。",
            "name": "8.3.4.2 拓展类的三种分类方式"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.4",
            "name": "8.3.4 类–职责–协作者建模"
        }
    },
    {
        "start_id": "SS8.3.4.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.3",
            "name": "8.3.4.3 职责的5个指导原则"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.4",
            "name": "8.3.4 类–职责–协作者建模"
        }
    },
    {
        "start_id": "P8.3.4.3.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.1",
            "content": "1.把“不灵巧”类(几乎没有职责的类)作为一些“灵巧”类(有很多职责的类)的从属。\n2.每个对象只了解和执行一些事情 (通常是适度集中)，并提高系统的内聚性，这将提高软件的可维护性并减少变更的副作用影响。\n3.应该评估每个CRC模型索引卡上标记的职责，以确定某个类是否应该具有超长的职责列表，如果有这种情况就表明职责太集中，需要将一个类分成多个类或子系统。\n4.每个类的职责应表现在同一抽象层上；",
            "name": "8.3.4.3.1 智能系统应分布在所有类中以求最佳地满足问题的需求"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.3",
            "name": "8.3.4.3 职责的5个指导原则"
        }
    },
    {
        "start_id": "P8.3.4.3.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.2",
            "content": "在类的层级结构的上层保持职责 (属性和操作)的通用性，(因为它们更有一般性，将适用于所有的子类)。\n",
            "name": "8.3.4.3.2 每个职责的说明应尽可能具有普遍性"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.3",
            "name": "8.3.4.3 职责的5个指导原则"
        }
    },
    {
        "start_id": "P8.3.4.3.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.3",
            "content": "这实现了面向对象原则中的封装，数据和操作数据的处理应包装在一个内聚单元中。",
            "name": "8.3.4.3.3 信息和与之相关的行为应放在同一个类中"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.3",
            "name": "8.3.4.3 职责的5个指导原则"
        }
    },
    {
        "start_id": "P8.3.4.3.4",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.4",
            "content": "通常应由一个单独的类负责保存和操作某特定类型的信息。通常这个职责不应由多个类分担。如果信息是分布的，软件将变得更加难以维护，测试也会面临更多挑战。",
            "name": "8.3.4.3.4 某个事物的信息应局限于一个类中而不要分布在多个类中"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.3",
            "name": "8.3.4.3 职责的5个指导原则"
        }
    },
    {
        "start_id": "P8.3.4.3.5",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P8.3.4.3.5",
            "content": "很多情况下，各种相关对象必须在同一时间展示同样的行为；\n例如，一个视频游戏，必须显示如下类：Player, PlayerBody, PlayerArms, PlayerLegs, PlayerHead。每个类都有各自的属性，并且所有这些属性都需要在用户操作游戏时进行更新和显示。因此，每个对象必须共享职责update()和display()。",
            "name": "8.3.4.3.5 职责应由相关类共享"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS8.3.4.3",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS8.3.4.3",
            "name": "8.3.4.3 职责的5个指导原则"
        }
    },
    {
        "start_id": "SS8.3.4.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.4",
            "name": "8.3.4.4 协作的必要性"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.4",
            "name": "8.3.4 类–职责–协作者建模"
        }
    },
    {
        "start_id": "SS8.3.4.5",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.3.4.5",
            "content": "当开发出一个完整的CRC模型时，利益相关者代表可以使用如下方法评审模型1．所有参加（CRC模型）评审的人员拿到一部分CRC模型索引卡。每个评审员不能有两张存在协作关系的卡片。2．评审组长细致地阅读用例。当评审组长看到一个已命名的对象时，给拥有相应类索引卡的人员一个令牌。3．当令牌传递时，该类卡的拥有者需要描述卡上记录的职责。评审组确定（一个或多个）职责是否满足用例需求。4．如果发现错误，则对索引卡进行修改。修改可能包括定义新类（和相关的CRC索引卡），或者在已有的卡上修改职责和协作列表。",
            "name": "8.3.4.5 评审模型"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.3.4",
            "name": "8.3.4 类–职责–协作者建模"
        }
    },
    {
        "start_id": "T8.4",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.4",
            "name": "8.4 功能建模"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH8",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH8",
            "name": "第8章 需求建模——一种推荐的方法"
        }
    },
    {
        "start_id": "S8.4.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.4.1",
            "name": "8.4.1 介绍"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.4",
            "name": "8.4 功能建模"
        }
    },
    {
        "start_id": "S8.4.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.4.2",
            "content": "无论过程抽象的层次如何，UML活动图都可以用来表示处理细节。从分析阶段，仅在功能相对复杂的情况下才会使用活动图。UML活动图通过提供特定场景内交互流的图形化表示来补充用例，类似于流程图。活动图使用圆角矩形表示特定的系统功能，箭头表示通过系统的流，菱形表示决策分支（标记菱形发出的每个箭头），实水平线表示并行发生的活动。",
            "name": "8.4.2 过程视图"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.4",
            "name": "8.4 功能建模"
        }
    },
    {
        "start_id": "S8.4.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.4.3",
            "content": "UML 顺序图可用于行为建模。顺序图还可用于显示事件如何引发从一个对象到另一个对象的转移。一旦通过检查用例确定了事件，建模人员就创建了一个顺序图，即用时间函数表示事件是如何引发从一个对象流到另一个对象。顺序图是用例的简化版本，它表示了导致行为从一个类流到另一个类的关键类和事件。\n一旦构建了完整的序列图，就可以将导致系统对象之间转换的所有事件整理为一组输人事件和输出事件集合（来自对象）。对于将要构建的系统而言，这些信息对于创建系统的有效设计很有用。",
            "name": "8.4.3 UML顺序图"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.4",
            "name": "8.4 功能建模"
        }
    },
    {
        "start_id": "T8.5",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.5",
            "name": "8.5 行为建模"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH8",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH8",
            "name": "第8章 需求建模——一种推荐的方法"
        }
    },
    {
        "start_id": "S8.5.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.5.1",
            "name": "8.5.1 介绍"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.5",
            "name": "8.5 行为建模"
        }
    },
    {
        "start_id": "S8.5.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.5.2",
            "content": "用例与事件的关系：用例描述了参与者和系统之间的活动顺序，事件则是系统和参与者之间交换信息的事实。 事件的识别：在用例场景中，加下划线的部分表示事件。每个事件都需要确认参与者，并标记交换的所有信息，同时列出所有条件或限制。 事件的例子：以“房主使用键盘键入4位密码”为例，这是一个由房主（Homeowner）向控制面板（ControlPanel）发送的事件，称为输入密码。这个事件传输的信息是4位数字密码，但重要的是已交换信息的事实，而不是信息本身。 事件对控制流的影响：某些事件对用例的控制流有明显影响，而其他事件则没有直接影响。例如，“输入密码”事件不会明显改变控制流，但“比较密码”的结果会明显影响信息流和控制流。 事件的分配：一旦确定了所有事件，这些事件将被分配给所涉及的对象，对象负责生成事件或识别已经在其他地方发生的事件。",
            "name": "8.5.2 识别用例事件"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.5",
            "name": "8.5 行为建模"
        }
    },
    {
        "start_id": "S8.5.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.5.3",
            "content": "UML状态图用于展示系统中每个类的状态变化，包括主动状态和被动状态，以及导致状态变化的事件（触发器）。\n状态转移涉及守卫（必须满足的条件）和动作（与状态转移相关的行为），这些要素帮助详细描述对象在不同状态下的行为和响应。",
            "name": "8.5.3 UML状态图"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.5",
            "name": "8.5 行为建模"
        }
    },
    {
        "start_id": "S8.5.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S8.5.4",
            "name": "8.5.4 UML活动图"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T8.5",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T8.5",
            "name": "8.5 行为建模"
        }
    },
    {
        "start_id": "SS8.5.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.5.4.1",
            "content": "UML活动图通过展示特定场景下的迭代流来补充用例，提供了系统如何对内部事件做出反应的图形化表示。它能够展示用例中无法直接描述的额外细节，例如用户尝试输入账号和密码的次数限制。",
            "name": "8.5.4.1 UML活动图的作用"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.5.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.5.4",
            "name": "8.5.4 UML活动图"
        }
    },
    {
        "start_id": "SS8.5.4.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS8.5.4.2",
            "content": "UML泳道图是活动图的变形，它允许建模人员展示活动流，并指出哪个参与者或分析类负责特定的活动。泳道图通过纵向分割图中的并行条（泳道）来表示职责，类似于游泳池中的泳道。\n活动图和泳道图都是以过程为导向的，它们可以一起表示参与者如何调用特定功能以满足系统需求。通过将活动图重新排列并分配到相应的泳道中，可以更清晰地展示不同分析类或参与者的职责和活动。",
            "name": "8.5.4.2 UML泳道图的应用"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S8.5.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S8.5.4",
            "name": "8.5.4 UML活动图"
        }
    },
    {
        "start_id": "T8.6",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T8.6",
            "content": "\"需求建模的目标是创建各种表现形式，用其描述什么是客户需求，为生成的软件设计建立基础，一旦软件建立这些需求将用于验证。需求模型在系统级表示层和软件设计之间构造了桥梁。系统表示层描述了整个系统和业务功能，软件设计描述了软件应用的体系结构、用户接口和构建级的结构。\n  基于场景的模型从用户的角度描述软件需求。用例是主要的建模元素，它以叙述方式或以模板驱动方式描述了参与者和软件之间的交互活动。在需求获取过程中得到的用地定义了特定功能或交互活动的关键步骤。用例的正式程度和详细程度各不相同,但它们可以为所有的其他分析建模活动提供必要的输入。还可以使用活动图说明场景，活动图是描述特定场景内的处理流的图形表现形式。用例中的时序关系可以使用顺序图来建模。\n  为了识别分析类，基于类的建模使用从用例和其他编写的应用描述中导出的信息。可以使用语法解析从文本说明中提取候选类、属性和操作，并使用解析结果制定用于定义类的标准。\n  CRC索引卡可以用于定义类之间的联系。此外，可以使用各种UML建模方法定义类之间的层次、关系、关联、聚合和依赖。\n  在需求分析阶段的行为建模描述了软件的动态，行为建模采用来自基于场景和基于类的输入来表达分析类的状态。为达到这一目的，要识别状态，定义引起类（或系统）由一种状态转换到另一个状态的事件，还要识别完成转换后发生活动。UML状态图、活动图、泳道图和顺序图可以被用于行为建模。\"",
            "name": "8.6 小结"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH8",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH8",
            "name": "第8章 需求建模——一种推荐的方法"
        }
    },
    {
        "start_id": "T15.1",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.1",
            "name": "15.1 什么是质量"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH15",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH15",
            "name": "第15章 质量概念"
        }
    },
    {
        "start_id": "S15.1.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.1.1",
            "name": "15.1.1 David-Garvin关于质量的5个观点"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.1",
            "name": "15.1 什么是质量"
        }
    },
    {
        "start_id": "SS15.1.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.1",
            "content": "先验论观点认为质量是马上就能识别的东西，却不能清楚地定义。",
            "name": "15.1.1.1 先验论观点"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.1",
            "name": "15.1.1 David-Garvin关于质量的5个观点"
        }
    },
    {
        "start_id": "SS15.1.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.2",
            "content": "用户观点是从最终用户的具体目标来考虑的。如果产品达到这些目标，就是有质量的。",
            "name": "15.1.1.2 用户观点"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.1",
            "name": "15.1.1 David-Garvin关于质量的5个观点"
        }
    },
    {
        "start_id": "SS15.1.1.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.3",
            "content": "制造商观点是从产品原始规格说明的角度来定义质量。如果产品符合规格说明，就是有质量的",
            "name": "15.1.1.3 制造商观点"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.1",
            "name": "15.1.1 David-Garvin关于质量的5个观点"
        }
    },
    {
        "start_id": "SS15.1.1.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.4",
            "content": "产品观点认为质量是产品的固有属性（比如功能和特性）",
            "name": "15.1.1.4 产品观点"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.1",
            "name": "15.1.1 David-Garvin关于质量的5个观点"
        }
    },
    {
        "start_id": "SS15.1.1.5",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.1.5",
            "content": "基于价值的观点根据客户愿意为产品支付多少钱来评测质量。",
            "name": "15.1.1.5 基于价值的观点"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.1.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.1",
            "name": "15.1.1 David-Garvin关于质量的5个观点"
        }
    },
    {
        "start_id": "S15.1.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.1.2",
            "name": "15.1.2 设计质量和符合质量"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.1",
            "name": "15.1 什么是质量"
        }
    },
    {
        "start_id": "SS15.1.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.2.1",
            "content": "设计质量是指设计师赋予产品的特性。材料等级、公差和性能等规格说明决定了设计质量。在软件开发中，设计质量包括设计满足需求模型规定的功能和特性的程度。",
            "name": "15.1.2.1 设计质量"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.2",
            "name": "15.1.2 设计质量和符合质量"
        }
    },
    {
        "start_id": "SS15.1.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.1.2.2",
            "content": "在软件开发中，符合质量关注的是实现遵从设计的程度以及所得到的系统满足需求和性能目标的程度。",
            "name": "15.1.2.2 符合质量"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.1.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.1.2",
            "name": "15.1.2 设计质量和符合质量"
        }
    },
    {
        "start_id": "S15.1.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.1.3",
            "content": "“用户满意度 = 合格的产品 + 好的质量 + 按预算和进度安排交付”\n如果一个软件产品能给最终用户带来实质性的益处，他们可能会心甘情愿地忍受偶尔的可靠性或性能问题。现代关于软件质量的观点要求关注客户满意度以及与产品需求的一致性。",
            "name": "15.1.3 质量之外"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.1",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.1",
            "name": "15.1 什么是质量"
        }
    },
    {
        "start_id": "T15.2",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.2",
            "name": "15.2 软件质量"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH15",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH15",
            "name": "第15章 质量概念"
        }
    },
    {
        "start_id": "S15.2.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.2.1",
            "content": "(1) 在一定程度上应用有效的软件过程；\n(2) 创造有用的产品；\n(3) 为生产者和使用者提供明显的价值。",
            "name": "15.2.1 软件质量的定义"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.2",
            "name": "15.2 软件质量"
        }
    },
    {
        "start_id": "SS15.2.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.1.1",
            "content": "有效的软件过程为生产高质量的软件产品奠定了基础。过程的管理方面所做的工作是检验和平衡，以避免项目混乱（低质量的关键因素）。软件工程实践允许开发人员分析问题、设计可靠的解决方案，这些都是生产高质量软件的关键所在。最后，诸如变更管理和技术评审等普适性活动与其他部分的软件工程活动密切相关。",
            "name": "15.2.1.1 有效地软件过程"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.2.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.1",
            "content": "(1) 在一定程度上应用有效的软件过程；\n(2) 创造有用的产品；\n(3) 为生产者和使用者提供明显的价值。",
            "name": "15.2.1 软件质量的定义"
        }
    },
    {
        "start_id": "SS15.2.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.1.2",
            "content": "有用的产品是指交付最终用户要求的内容、功能和特征，但最重要的是，以可靠、无误的方式交付这些东西。有用的产品总是满足利益相关者明确提出的那些需求，另外也要满足一些高质量软件应有的隐性需求（例如可用性）",
            "name": "15.2.1.2 有用的产品"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.2.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.1",
            "content": "(1) 在一定程度上应用有效的软件过程；\n(2) 创造有用的产品；\n(3) 为生产者和使用者提供明显的价值。",
            "name": "15.2.1 软件质量的定义"
        }
    },
    {
        "start_id": "SS15.2.1.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.1.3",
            "content": "通过为软件产品的生产者和使用者增值，高质量软件为软件组织和最终用户群体带来了收益。软件组织获益是因为高质量的软件在维护、改错及客户支持方面的工作量都降低了，从而使软件工程师减少了返工，将更多的时间花费在开发新的应用上，软件组织因此而获得增值。用户群体也得到增值，因为应用所提供的有用的能力在某种程度上加快了一些业务流程。最后的结果是：（1)软件产品的收入增加；（2)当应用可支持业务流程时，收益更好；（3）提高了信息可获得性，这对商业来讲是至关重要的。",
            "name": "15.2.1.3 为软件产品的生产者和使用者带来增值"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.2.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.1",
            "content": "(1) 在一定程度上应用有效的软件过程；\n(2) 创造有用的产品；\n(3) 为生产者和使用者提供明显的价值。",
            "name": "15.2.1 软件质量的定义"
        }
    },
    {
        "start_id": "S15.2.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.2.2",
            "name": "15.2.2 质量因素"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.2",
            "name": "15.2 软件质量"
        }
    },
    {
        "start_id": "SS15.2.2.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.2.1",
            "name": "15.2.2.1 McCall的软件质量因素"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.2",
            "name": "15.2.2 质量因素"
        }
    },
    {
        "start_id": "P15.2.2.1.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.2.2.1.1",
            "content": "1.正确性。程序满足其需求规格说明和完成用户任务目标的程度。\n2.可靠性。期望程序以所要求的精度完成其预期功能的程度。\n3.效率。程序完成其功能所需的计算资源和代码的数量。\n4.完整性。对未授权的人员访问软件或数据的可控程度。\n5.易用性。对程序进行学习、操作、准备输入和解释输出所需要的工作量。",
            "name": "15.2.2.1.1 操作特性 (产品运行)"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.2.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.2.2.1",
            "name": "15.2.2.1 McCall的软件质量因素"
        }
    },
    {
        "start_id": "P15.2.2.1.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.2.2.1.2",
            "content": "1.维护性。查出和修复程序中的一个错误所需要的工作量。\n2.灵活性。修改一个运行的程序所需的工作量。\n3.易测试性。测试程序以确保它能完成预期功能所需要的工作量。",
            "name": "15.2.2.1.2 承受变更的能力 (产品修改)"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.2.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.2.2.1",
            "name": "15.2.2.1 McCall的软件质量因素"
        }
    },
    {
        "start_id": "P15.2.2.1.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.2.2.1.3",
            "content": "1.可移植性。将程序从一个硬件和(或)软件系统环境移植到另一个环境所需要的工作量。\n2.可复用性。程序 (或部分程序)在另一个应用系统中使用的程度。\n3.互操作性。将一个(子)系统连接到另一系统所需要的工作量。",
            "name": "15.2.2.1.3 对新环境的适应能力 (产品转移)"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.2.2.1",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.2.2.1",
            "name": "15.2.2.1 McCall的软件质量因素"
        }
    },
    {
        "start_id": "SS15.2.2.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.2.2",
            "content": "1.功能性。软件满足已确定需求的程度，由以下子属性表征：适合性、准确性、互操作性、依从性(遵照功能需求)和安全保密性。\n2.可靠性。软件可用的时间长度，由以下子属性表征：成熟性、容错性和易恢复性。\n3.易用性。软件容易使用的程度，由以下子属性表征：易理解性、易学习性和易操作性。\n4.效率。软件优化使用系统资源的程度，由以下子属性表征：时间特性和资源利用特性。\n5.维护性。软件易于修复的程度，由以下子属性表征：易分析性、易改变性、易测试性和稳定性。\n6.可移植性。软件可以从一个环境移植到另一个环境的容易程度，由以下子属性表征：适应性、易安装性、符合性 (符合一定的标准和约定)和易替换性 (软件是否容易被替换)。",
            "name": "15.2.2.2 ISO 9126质量因素"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.2",
            "name": "15.2.2 质量因素"
        }
    },
    {
        "start_id": "SS15.2.2.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.2.3",
            "content": "1.有效性。用户实现目标的准确性和完整性。\n2.效率。为了完全达到用户目标和预期的准确性而花费的资源。\n3.满意度。有用、信任、快乐、舒适。\n4.远离风险。缓解经济、健康、安全和环境风险。\n5.语境覆盖。完整性、灵活性。",
            "name": "15.2.2.3 使用质量模型"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.2",
            "name": "15.2.2 质量因素"
        }
    },
    {
        "start_id": "SS15.2.2.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.2.2.4",
            "content": "1.功能适应性。完整、正确、适当。\n2.性能效率。时间、资源利用、容量。\n3.兼容性。共存、互操作性。\n4.可用性。适当性、易学性、可操作性、错误保护、美观性、可访问性。\n5.可靠性。成熟度、可用性、容错性、可恢复性。\n6.安全性。保密性、完整性、可审核性、真实性。\n7.可维护性。保密性、完整性、可审核性、真实性。\n8.可移植性。适应性、可安装性、可替换性。",
            "name": "15.2.2.4 产品质量模型"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.2.2",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.2.2",
            "name": "15.2.2 质量因素"
        }
    },
    {
        "start_id": "S15.2.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.2.3",
            "content": "1.用户能够多快确定是否可以使用软件产品来帮助他们完成任务？（适当性）\n2.用户学会如何使用完成任务所需的系统功能需要多长时间？（易学性）\n3.在随后的测试阶段，用户能否回忆起如何使用系统功能，而不必重新进行学习？（易学性）\n4.用户使用系统完成任务需要多长时间？（可操作性）\n5.系统是否会试图防止用户出错？（错误保护）\n6.对于用户界面外观的问题，答案是否给出了满意的回答？（美观性） \n7.界面是否符合第12章中的黄金规则所规定的预期？（可访问性）\n8.用户界面是否符合预期用户所需的可访问性检查清单？（可访问性）",
            "name": "15.2.3 定性质量评估"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.2",
            "name": "15.2 软件质量"
        }
    },
    {
        "start_id": "S15.2.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.2.4",
            "content": "主观性和特殊性也适用于软件质量的确定。要想对软件质量进行直接量化很难。\n\n可以提出一组可应用于软件质量定量评估的软件度量：\n1.也就是说，我们从不真正测量质量，而是测量质量的一些表现。\n2.复杂因素在于所测量的变量和软件质量间的精确关系。",
            "name": "15.2.4 定量质量评估"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.2",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.2",
            "name": "15.2 软件质量"
        }
    },
    {
        "start_id": "T15.3",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH15",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH15",
            "name": "第15章 质量概念"
        }
    },
    {
        "start_id": "S15.3.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.1",
            "content": "如果生产一个存在严重质量问题的软件系统，你将受到损失，因为没有人想去购买。另一方面，如果你花费无限的时间、极大的工作量和高额的资金来开发一个绝对完美的软件，那么完成该软件将花费很长的时间，生产成本是极其高昂的，以至于破产。要么没人购买，要么几乎耗尽所有资源、错过市场机会。所以企业界的人们努力达到奇妙的中间状态：\n1.一方面，产品要足够好，不会立即被抛弃；\n2.另一方面，又不是那么完美，不需花费太长时间和太多成本。",
            "name": "15.3.1 困境论述"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        }
    },
    {
        "start_id": "S15.3.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.2",
            "content": "足够好的软件提供用户期望的高质量功能和特性，但同时也提供了一些难解的或特殊的错误。软件供应商希望广大的最终用户忽视错误，因为他们对其他的应用功能是如此满意。",
            "name": "15.3.2 “足够好”的软件"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        }
    },
    {
        "start_id": "S15.3.3",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.3",
            "content": "质量成本包括追求质量过程中或在履行质量有关的活动中引起的费用以及质量不佳引起的费用等。\n质量成本可分为：1.预防成本。2.评估成本。3.失效成本。",
            "name": "15.3.3 质量的成本"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        }
    },
    {
        "start_id": "SS15.3.3.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.3.1",
            "content": "质量是重要的，但是花费太多的时间和金钱才能达到我们实际需要的软件质量水平。毫无疑问，质量是有成本的，但缺乏质量也有成本。真正的问题是：我们应该担心哪些成本？\n要回答这个问题，必须既要了解实现质量的成本，又要了解低质量软件导致的成本。",
            "name": "15.3.3.1 质量成本的争论"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.3.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.3",
            "content": "质量成本包括追求质量过程中或在履行质量有关的活动中引起的费用以及质量不佳引起的费用等。\n质量成本可分为：1.预防成本。2.评估成本。3.失效成本。",
            "name": "15.3.3 质量的成本"
        }
    },
    {
        "start_id": "SS15.3.3.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.3.2",
            "name": "15.3.3.2 质量成本的3个分类"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.3.3",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.3",
            "content": "质量成本包括追求质量过程中或在履行质量有关的活动中引起的费用以及质量不佳引起的费用等。\n质量成本可分为：1.预防成本。2.评估成本。3.失效成本。",
            "name": "15.3.3 质量的成本"
        }
    },
    {
        "start_id": "P15.3.3.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.3.2.1",
            "content": "预防成本包括：（1)计划和协调所有质量控制和质量保证所需管理活动的成本；（2)为开发完整的需求模型和设计模型所增加的技术活动的成本；（3)测试计划的成本；（4)与这些活动有关的所有培训成本。不要害怕带来相当大的预防成本。请放心，你的投资将带来丰厚的回报。评估成本包括为深入了解产品“第一次通过”每个过程的条件而进行的活动。",
            "name": "15.3.3.2.1 预防成本"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.3.2",
            "name": "15.3.3.2 质量成本的3个分类"
        }
    },
    {
        "start_id": "P15.3.3.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.3.2.2",
            "content": "评估成本的例子包括：(1)对软件工程工作产品进行技术评审（第16章）的成本；（2)数据收集和度量估算（第23章）的成本；（3)测试和调试（第19-21章）的成本。失效成本是那些在将产品交付客户之前若没有出现错误就不会发生的费用。",
            "name": "15.3.3.2.2 评估成本"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.3.2",
            "name": "15.3.3.2 质量成本的3个分类"
        }
    },
    {
        "start_id": "P15.3.3.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.3.2.3",
            "content": "失效成本可分为内部失效成本和外部失效成本。内部失效成本发生在软件发布之前发现错误时，内部失效成本包括：（1)为纠正错误进行返工（修复）所需的成本；（2)返工时无意中产生副作用，必须对副作用加以缓解而发生的成本；（3)组织为评估失效的模型而收集质量数据，由此发生的相关成本。外部失效成本是在产品已经发布给客户之后发现了缺陷时的相关成本。外部成本的例子包括：解决投诉，产品退货和更换，帮助作业支持，以及与保修工作相关的人力成本。不良的声誉和由此产生的业务损失是另一个外部失效成本，这是很难量化但非常现实的。生产了低质量的软件产品时，不好的事情就要发生。",
            "name": "15.3.3.2.3 失效成本"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.3.3.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.3.2",
            "name": "15.3.3.2 质量成本的3个分类"
        }
    },
    {
        "start_id": "S15.3.4",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.4",
            "name": "15.3.4 风险"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        }
    },
    {
        "start_id": "SS15.3.4.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.4.1",
            "content": "设计和实现低劣的应用系统所带来的损失并不总是限于金钱和时间。",
            "name": "15.3.4.1 低质量软件带来风险"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.4",
            "name": "15.3.4 风险"
        }
    },
    {
        "start_id": "SS15.3.4.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.4.2",
            "content": "在2000年11月，巴拿马的一家医院，28位病人在治疗多种癌症过程中接收了过量的伽玛射线照射。此后数月内，其中5例死于辐射病，15人发展成严重的并发症。是什么造成了这一悲剧？\n为了计算每位病人接受的辐射剂量，医院的技术人员对一家美国公司开发的软件包进行了修改。为了提供额外的能力，这3个巴拿马医疗物理学家“调整”了软件，他们被指控犯有二级谋杀罪，这家美国公司正在两个国家面临着严重的诉讼。\n\n事故就是对软件创作者的教训：\n软件质量问题很重要，不管是嵌入在汽车引擎中的，工厂里的机械手臂中的，还是嵌入在医院的治疗设备中的，这些应用必须做到万无一失，低劣部署的代码可以杀人。",
            "name": "15.3.4.2 一个极端的例子与警示"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.3.4",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.4",
            "name": "15.3.4 风险"
        }
    },
    {
        "start_id": "S15.3.5",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.5",
            "content": "政府或企业雇用一个较大的软件开发商或咨询公司来分析需求，然后设计和创建一个基于软件的“系统”，用以支撑某个重大的活动。系统可能支持主要的企业功能（例如，养老金管理)，或某项政府职能（例如，卫生保健管理或国土安全）。\n工作始于双方良好的意愿，但是到了系统交付时，情况已变得糟糕，系统延期，未能提供预期的特性和功能，而且易出错，不能得到客户的认可，接下来就要打官司。在大多数情况下，顾客称开发商马虎大意（已带到了软件实践中），因此拒绝付款。而开发商则常常声称，顾客一再改变其要求，并在其他方面破坏了开发伙伴关系。无论是哪一种情况，交付系统的质量都会有问题。",
            "name": "15.3.5 疏忽和责任"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        }
    },
    {
        "start_id": "S15.3.6",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.6",
            "name": "15.3.6 质量和安全"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        }
    },
    {
        "start_id": "SS15.3.6.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.6.1",
            "content": "随着基于Web的系统和移动系统重要性的增加，应用的安全性已变得日益重要。简而言之，没有表现出高质量的软件比较容易被攻击。因此，低质量的软件会间接地增加安全风险，随之而来的是费用和问题。软件安全与质量息息相关。必须一开始就在设计、构建、测试、编码阶段以及在整个软件生命周期（过程）中考虑安全性、可靠性、可得性、可信性。即使是已认识到软件安全问题的人也会主要关注生命周期的晚些阶段。越早发现软件问题越好。",
            "name": "15.3.6.1 质量和安全的关系"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.3.6",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.6",
            "name": "15.3.6 质量和安全"
        }
    },
    {
        "start_id": "SS15.3.6.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.6.2",
            "content": "有两种类型的软件问题，一种是隐藏的错误，这是实现的问题。另一种是软件缺陷，这是设计中的构建问题。人们对错误关注太多，却对缺陷关注不够。\n要构造安全的系统，就必须注重质量，并必须在设计时开始关注。",
            "name": "15.3.6.2 两种类型的软件问题"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.3.6",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.6",
            "name": "15.3.6 质量和安全"
        }
    },
    {
        "start_id": "S15.3.7",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.3.7",
            "name": "15.3.7 管理活动的影响"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.3",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.3",
            "name": "15.3 软件质量困境"
        }
    },
    {
        "start_id": "SS15.3.7.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.7.1",
            "content": "软件质量受管理决定的影响往往和受技术决定的影响是一样的。即使最好的软件工程实践也能被糟糕的商业决策和有问题的项目管理活动破坏。\nMeskimen定律能最好地概括软件质量面临的困境：“从来没有时间做好，但总是有时间再做一遍！”\n应选择主动做好，而不是被动重做。",
            "name": "15.3.7.1 质量受到管理活动影响"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.3.7",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.7",
            "name": "15.3.7 管理活动的影响"
        }
    },
    {
        "start_id": "SS15.3.7.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.3.7.2",
            "content": "每个项目任务开始时，项目领导人都要作决策，这些决策可能对产品质量有重大影响，决策包括：1.估算决策。2.进度安排决策。3.面向风险的决策。",
            "name": "15.3.7.2 三种决策"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.3.7",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.3.7",
            "name": "15.3.7 管理活动的影响"
        }
    },
    {
        "start_id": "P15.3.7.2.1",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.7.2.1",
            "content": "在确定交付日期和制定总预算之前，给软件团队提供项目估算数据是很少见的。反而是团队进行了“健康检查”，以确保交付日期和里程碑是合理的。在许多情况下,存在着巨大的上市时间压力，迫使软件团队接受不现实的交付日期。结果，由于抄了近路,可以获得更高质量软件的活动被忽略掉了，产品质量受到损害。如果交付日期是不合理的，那么坚持立场就是重要的。这就解释了为什么你需要更多的时间，或者也可以建议在指定的时间交付一个（高质量的）功能子集。",
            "name": "15.3.7.2.1 估算决策"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.3.7.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.7.2",
            "content": "每个项目任务开始时，项目领导人都要作决策，这些决策可能对产品质量有重大影响，决策包括：1.估算决策。2.进度安排决策。3.面向风险的决策。",
            "name": "15.3.7.2 三种决策"
        }
    },
    {
        "start_id": "P15.3.7.2.2",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.7.2.2",
            "content": "一旦建立了软件项目时间表（第25章)，就会按照依赖性安排任务的先后顺序。例如，由于A构件依赖于B、C和D构件中的处理，因此直到B、C和D构件完全测试后，才能安排A构件进行测试。项目计划将反映这一点。但是，如果时间很紧，为了做进一步的关键测试，A必须是可用的。在这种情况下，可能会决定在没有其附属构件(这些附属构件的运行要稍落后于时间表）的情况下测试A,这样对于交付前必须完成的其他测试，就可以使用A了，毕竟，期限正在逼近。因此，A可能有隐藏的缺陷，只有晚些时候才能发现，质量会受到影响。",
            "name": "15.3.7.2.2 进度安排决策"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.3.7.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.7.2",
            "content": "每个项目任务开始时，项目领导人都要作决策，这些决策可能对产品质量有重大影响，决策包括：1.估算决策。2.进度安排决策。3.面向风险的决策。",
            "name": "15.3.7.2 三种决策"
        }
    },
    {
        "start_id": "P15.3.7.2.3",
        "start_labels": [
            "Problem"
        ],
        "start_properties": {
            "id": "P15.3.7.2.3",
            "content": "风险管理（第26章）是成功软件项目的关键特性之一。必须知道哪里可能会出问题，并建立一项如果确实出问题时的应急计划。太多的软件团队喜欢盲目乐观，在什么都不会出问题的假设下建立开发计划。更糟的是，他们没有办法处理真的出了差错的事情。结果，当风险变成现实后，便会一片混乱，并且随着疯狂程度的上升，质量水平必然下降。",
            "name": "15.3.7.2.3 面对风险的决策"
        },
        "relation": "Belong_SS",
        "relation_properties": {},
        "end_id": "SS15.3.7.2",
        "end_labels": [
            "SubSection"
        ],
        "end_properties": {
            "id": "SS15.3.7.2",
            "content": "每个项目任务开始时，项目领导人都要作决策，这些决策可能对产品质量有重大影响，决策包括：1.估算决策。2.进度安排决策。3.面向风险的决策。",
            "name": "15.3.7.2 三种决策"
        }
    },
    {
        "start_id": "T15.4",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.4",
            "name": "15.4 实现软件质量"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH15",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH15",
            "name": "第15章 质量概念"
        }
    },
    {
        "start_id": "S15.4.1",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.4.1",
            "content": "良好的软件质量不会自己出现，它是良好的项目管理和扎实的软件工程实践的结果。四大管理和实践活动可以帮助软件团队实现高质量的软件。",
            "name": "15.4.1 实现高质量软件的四大管理和实践活动"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.4",
            "name": "15.4 实现软件质量"
        }
    },
    {
        "start_id": "SS15.4.1.1",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.4.1.1",
            "content": "软件工程方法。如果希望建立高质量的软件，必须理解要解决的问题，还须能够创造一个符合问题的设计，该设计同时还要有一些性质，即这些性质可以产生具有质量维度和因素的软件。",
            "name": "15.4.1.1 软件工程方法 "
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.4.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.4.1",
            "content": "良好的软件质量不会自己出现，它是良好的项目管理和扎实的软件工程实践的结果。四大管理和实践活动可以帮助软件团队实现高质量的软件。",
            "name": "15.4.1 实现高质量软件的四大管理和实践活动"
        }
    },
    {
        "start_id": "SS15.4.1.2",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.4.1.2",
            "content": "项目管理技术：\n(1) 项目经理使用估算以确认交付日期是可以达到的；\n(2) 进度依赖关系明确，团队能够抵抗走捷径的诱惑；\n(3) 进行了风险规划，这样出了问题就不会引起混乱，软件质量将受到积极的影响。",
            "name": "15.4.1.2 项目管理技术"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.4.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.4.1",
            "content": "良好的软件质量不会自己出现，它是良好的项目管理和扎实的软件工程实践的结果。四大管理和实践活动可以帮助软件团队实现高质量的软件。",
            "name": "15.4.1 实现高质量软件的四大管理和实践活动"
        }
    },
    {
        "start_id": "SS15.4.1.3",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.4.1.3",
            "content": "质量控制。其包括一套软件工程活动，以帮助确保每个工作产品符合其质量目标：\n1.评审模型以确保它们是完整的和一致的。\n2.检查代码，以便在测试开始前发现和纠正错误。\n3.应用一系列的测试步骤以发现处理逻辑、数据处理以及接口通信中的错误。\n4.当任何一个工作成果不符合质量目标时，应结合测量和反馈使软件团队调整软件过程。",
            "name": "15.4.1.3 质量控制"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.4.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.4.1",
            "content": "良好的软件质量不会自己出现，它是良好的项目管理和扎实的软件工程实践的结果。四大管理和实践活动可以帮助软件团队实现高质量的软件。",
            "name": "15.4.1 实现高质量软件的四大管理和实践活动"
        }
    },
    {
        "start_id": "SS15.4.1.4",
        "start_labels": [
            "SubSection"
        ],
        "start_properties": {
            "id": "SS15.4.1.4",
            "content": "质量保证。其包含一组审核和报告功能，用以评估质量控制活动的有效性和完整性。",
            "name": "15.4.1.4 质量保证"
        },
        "relation": "Belong_ST",
        "relation_properties": {},
        "end_id": "S15.4.1",
        "end_labels": [
            "Section"
        ],
        "end_properties": {
            "id": "S15.4.1",
            "content": "良好的软件质量不会自己出现，它是良好的项目管理和扎实的软件工程实践的结果。四大管理和实践活动可以帮助软件团队实现高质量的软件。",
            "name": "15.4.1 实现高质量软件的四大管理和实践活动"
        }
    },
    {
        "start_id": "S15.4.2",
        "start_labels": [
            "Section"
        ],
        "start_properties": {
            "id": "S15.4.2",
            "content": "缺陷预测是识别可能存在质量问题的软件构件的重要方式。缺陷预测模型使用统计技术来检查软件度量和包含已知软件缺陷的软件构件的组合之间的关系。它们是软件开发人员快速识别容易出错的类的高效方法。这可以减少成本和开发时间。\n机器学习是人工智能（AI)技术的一种应用，它为系统提供了无须显式编程就能从经验中学习和改进的能力。换句话说，机器学习关注开发能够访问数据并利用数据进行自学的计算机程序。机器学习技术可以用来自动化发现软件度量和缺陷构件之间的预测关系。机器学习系统处理大量的数据集，这些数据集包含有缺陷的和无缺陷的软件构件的代表性度量组合。这些数据用于优化分类算法。一旦系统通过这种类型的训练构建了一个预测模型，它就可以基于未来软件产品的相关数据进行质量评估和缺陷预测。构建这种类型的分类器是现代数据科学家工作的重要部分。",
            "name": "15.4.2 机器学习和缺陷预测"
        },
        "relation": "Belong_TP",
        "relation_properties": {},
        "end_id": "T15.4",
        "end_labels": [
            "Topic"
        ],
        "end_properties": {
            "id": "T15.4",
            "name": "15.4 实现软件质量"
        }
    },
    {
        "start_id": "T15.5",
        "start_labels": [
            "Topic"
        ],
        "start_properties": {
            "id": "T15.5",
            "content": "软件正在融入我们日常生活的各个方面，人们对于软件系统质量的关注也逐渐多起来。但是很难给出软件质量的一个全面描述。在这一章，质量被定义为一个有效的软件过程，用来在一定程度上创造有用的产品，为那些生产者和使用者提供适度的价值。\n这些年来，提出了各种各样的软件质量度量和因素，都试图定义一组属性，如果可以实现，那么我们将实现较高的软件质量。McCall的质量因素和ISO 25010的质量因素建立了很多特性（如可靠性、可用性、维护性、功能性和可移植性）作为质量存在的指标。\n每个软件组织都面临软件质量困境。从本质上说，每个人都希望建立高质量的系统，但生产“完美”软件所需的时间和工作量在市场主导的世界里根本无法达到。这样问题就转化为，我们是否应该生产“足够好”的软件？虽然许多公司是这样做的，但是这样做有很大的负面影响，必须加以考虑。\n不管选择什么方法，质量都是有成本的，质量成本可以从预防、评估和失效方面来说。预防成本包括所有将预防缺陷放在首位的软件工程活动。评估成本是与评估软件工作产品以确定其质量的活动有关的成本。失效成本包括失效的内部代价和低劣质量造成的外部影响。\n软件质量是通过软件工程方法、扎实的管理措施和全面质量控制的应用而实现的一一所有这些都是靠软件质量保证基础设施支持的。",
            "name": "15.5 小结"
        },
        "relation": "Belong_SB",
        "relation_properties": {},
        "end_id": "CH15",
        "end_labels": [
            "Subject"
        ],
        "end_properties": {
            "id": "CH15",
            "name": "第15章 质量概念"
        }
    }
]